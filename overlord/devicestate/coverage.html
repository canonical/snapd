
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>devicestate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/snapcore/snapd/overlord/devicestate/crypto.go (72.0%)</option>
				
				<option value="file1">github.com/snapcore/snapd/overlord/devicestate/devicectx.go (53.6%)</option>
				
				<option value="file2">github.com/snapcore/snapd/overlord/devicestate/devicemgr.go (28.7%)</option>
				
				<option value="file3">github.com/snapcore/snapd/overlord/devicestate/devicestate.go (2.4%)</option>
				
				<option value="file4">github.com/snapcore/snapd/overlord/devicestate/firstboot.go (3.0%)</option>
				
				<option value="file5">github.com/snapcore/snapd/overlord/devicestate/handlers.go (0.0%)</option>
				
				<option value="file6">github.com/snapcore/snapd/overlord/devicestate/handlers_bootconfig.go (0.0%)</option>
				
				<option value="file7">github.com/snapcore/snapd/overlord/devicestate/handlers_gadget.go (0.0%)</option>
				
				<option value="file8">github.com/snapcore/snapd/overlord/devicestate/handlers_install.go (0.0%)</option>
				
				<option value="file9">github.com/snapcore/snapd/overlord/devicestate/handlers_remodel.go (0.0%)</option>
				
				<option value="file10">github.com/snapcore/snapd/overlord/devicestate/handlers_serial.go (59.5%)</option>
				
				<option value="file11">github.com/snapcore/snapd/overlord/devicestate/handlers_systems.go (0.0%)</option>
				
				<option value="file12">github.com/snapcore/snapd/overlord/devicestate/helpers.go (0.0%)</option>
				
				<option value="file13">github.com/snapcore/snapd/overlord/devicestate/remodel.go (4.5%)</option>
				
				<option value="file14">github.com/snapcore/snapd/overlord/devicestate/systems.go (0.0%)</option>
				
				<option value="file15">github.com/snapcore/snapd/overlord/devicestate/users.go (0.0%)</option>
				
				<option value="file16">github.com/snapcore/snapd/overlord/devicestate/volumes.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2016-2017 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"

        "github.com/snapcore/snapd/osutil"
)

func generateRSAKey(keyLength int) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        // The temporary directory is created with mode
        // 0700 by os.MkdirTemp, see:
        //   https://github.com/golang/go/blob/3b29222ffdcaea70842ed167632468f54a1783ae/src/os/tempfile.go#L98
        tempDir, err := os.MkdirTemp(os.TempDir(), "snapd")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer os.RemoveAll(tempDir)

        rsaKeyFile := filepath.Join(tempDir, "rsa.key")

        cmd := exec.Command("ssh-keygen", "-t", "rsa", "-b", strconv.Itoa(keyLength), "-N", "", "-f", rsaKeyFile, "-m", "PEM")
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return nil, osutil.OutputErr(out, err)
        }</span>

        <span class="cov8" title="1">d, err := os.ReadFile(rsaKeyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">blk, _ := pem.Decode(d)
        if blk == nil </span><span class="cov0" title="0">{
                return nil, errors.New("cannot decode PEM block")
        }</span>

        <span class="cov8" title="1">key, err := x509.ParsePKCS1PrivateKey(blk.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = key.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = os.RemoveAll(tempDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return key, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2018-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "errors"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
)

// DeviceCtx picks a device context from state, optional task or an
// optionally pre-provided one. Returns ErrNoState if a model
// assertion is not yet known.
// In particular if task belongs to a remodeling change this will find
// the appropriate remodel context.
func DeviceCtx(st *state.State, task *state.Task, providedDeviceCtx snapstate.DeviceContext) (snapstate.DeviceContext, error) <span class="cov8" title="1">{
        if providedDeviceCtx != nil </span><span class="cov0" title="0">{
                return providedDeviceCtx, nil
        }</span>
        // use the remodelContext if the task is part of a remodel change
        <span class="cov8" title="1">remodCtx, err := remodelCtxFromTask(task)
        if err == nil </span><span class="cov0" title="0">{
                return remodCtx, nil
        }</span>
        <span class="cov8" title="1">if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">modelAs, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">devMgr := deviceMgr(st)
        return newModelDeviceContext(devMgr, modelAs), nil</span>
}

type groundDeviceContext struct {
        model      *asserts.Model
        systemMode string
}

func (dc *groundDeviceContext) Model() *asserts.Model <span class="cov8" title="1">{
        return dc.model
}</span>

func (dc *groundDeviceContext) GroundContext() snapstate.DeviceContext <span class="cov0" title="0">{
        return dc
}</span>

func (dc *groundDeviceContext) Store() snapstate.StoreService <span class="cov0" title="0">{
        panic("retrieved ground context is not intended to drive store operations")</span>
}

func (dc *groundDeviceContext) ForRemodeling() bool <span class="cov0" title="0">{
        return false
}</span>

func (dc *groundDeviceContext) SystemMode() string <span class="cov0" title="0">{
        return dc.systemMode
}</span>

// Classic returns true if the model is marked as a classic model.
//
// TODO: consider refactoring this, since this will return true in cases where
// we might not really consider the system to be a classic system. For example,
// this will return true when we're booting into recovery mode on a hybrid
// system. While the model is a classic model, nothing about the running system
// looks like a classic system.
func (dc groundDeviceContext) Classic() bool <span class="cov8" title="1">{
        return dc.model.Classic()
}</span>

func (dc groundDeviceContext) Kernel() string <span class="cov0" title="0">{
        return dc.model.Kernel()
}</span>

func (dc groundDeviceContext) Base() string <span class="cov0" title="0">{
        return dc.model.Base()
}</span>

func (dc groundDeviceContext) Gadget() string <span class="cov0" title="0">{
        return dc.model.Gadget()
}</span>

func (dc groundDeviceContext) RunMode() bool <span class="cov8" title="1">{
        return dc.systemMode == "run"
}</span>

// HasModeenv is true if the grade is set
func (dc groundDeviceContext) HasModeenv() bool <span class="cov8" title="1">{
        return dc.model.Grade() != asserts.ModelGradeUnset
}</span>

// IsCoreBoot is true if the model sports a kernel.
func (d *groundDeviceContext) IsCoreBoot() bool <span class="cov8" title="1">{
        return d.model.Kernel() != ""
}</span>

// IsClassicBoot is true for classic systems with classic initramfs
// (there are no system modes in this case). If true, the kernel comes
// from debian packages.
func (d *groundDeviceContext) IsClassicBoot() bool <span class="cov8" title="1">{
        return !d.IsCoreBoot()
}</span>

// expected interface is implemented
var _ snapstate.DeviceContext = &amp;groundDeviceContext{}

type modelDeviceContext struct {
        groundDeviceContext
}

func newModelDeviceContext(devMgr *DeviceManager, modelAs *asserts.Model) *modelDeviceContext <span class="cov8" title="1">{
        return &amp;modelDeviceContext{groundDeviceContext{
                model:      modelAs,
                systemMode: devMgr.SystemMode(SysAny),
        }}
}</span>

func (dc *modelDeviceContext) Store() snapstate.StoreService <span class="cov0" title="0">{
        return nil
}</span>

// expected interface is implemented
var _ snapstate.DeviceContext = &amp;modelDeviceContext{}

// SystemModeInfoFromState returns details about the system mode the device is in.
func SystemModeInfoFromState(st *state.State) (*SystemModeInfo, error) <span class="cov0" title="0">{
        return deviceMgr(st).SystemModeInfo()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/asserts/sysdb"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/client"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/gadget/device"
        "github.com/snapcore/snapd/i18n"
        "github.com/snapcore/snapd/kernel/fde"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/configstate/config"
        "github.com/snapcore/snapd/overlord/devicestate/internal"
        "github.com/snapcore/snapd/overlord/hookstate"
        "github.com/snapcore/snapd/overlord/install"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/overlord/storecontext"
        "github.com/snapcore/snapd/overlord/swfeats"
        "github.com/snapcore/snapd/progress"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/secboot"
        "github.com/snapcore/snapd/secboot/keys"
        "github.com/snapcore/snapd/seed"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/snap/snapfile"
        "github.com/snapcore/snapd/snapdenv"
        "github.com/snapcore/snapd/strutil"
        "github.com/snapcore/snapd/sysconfig"
        "github.com/snapcore/snapd/systemd"
        "github.com/snapcore/snapd/timeutil"
        "github.com/snapcore/snapd/timings"
)

var (
        cloudInitStatus   = sysconfig.CloudInitStatus
        restrictCloudInit = sysconfig.RestrictCloudInit

        secbootMarkSuccessful = secboot.MarkSuccessful
)

var (
        becomeOperationalChangeKind = swfeats.RegisterChangeKind("become-operational")
        seedChangeKind              = swfeats.RegisterChangeKind("seed")
        installSystemChangeKind     = swfeats.RegisterChangeKind("install-system")
        factoryResetChangeKind      = swfeats.RegisterChangeKind("factory-reset")
)

func init() <span class="cov8" title="1">{
        swfeats.RegisterEnsure("DeviceManager", "ensureOperational")
        swfeats.RegisterEnsure("DeviceManager", "ensureSeeded")
        swfeats.RegisterEnsure("DeviceManager", "ensureAutoImportAssertions")
        swfeats.RegisterEnsure("DeviceManager", "ensureSerialBoundSystemUserAssertionsProcessed")
        swfeats.RegisterEnsure("DeviceManager", "ensureBootOk")
        swfeats.RegisterEnsure("DeviceManager", "ensureCloudInitRestricted")
        swfeats.RegisterEnsure("DeviceManager", "ensureInstalled")
        swfeats.RegisterEnsure("DeviceManager", "ensureFactoryReset")
        swfeats.RegisterEnsure("DeviceManager", "ensureSeedInConfig")
        swfeats.RegisterEnsure("DeviceManager", "ensureSeedInConfig")
        swfeats.RegisterEnsure("DeviceManager", "ensureTriedRecoverySystem")
        swfeats.RegisterEnsure("DeviceManager", "ensurePostFactoryReset")
        swfeats.RegisterEnsure("DeviceManager", "ensureExpiredUsersRemoved")
}</span>

// EarlyConfig is a hook set by configstate that can process early configuration
// during managers' startup.
var EarlyConfig func(st *state.State, preloadGadget func() (sysconfig.Device, *gadget.Info, error)) error

// ErrNoDeviceIdentityYet is returned when the device doesn't have a serial assertion.
// It's a special case of ErrNoState.
var ErrNoDeviceIdentityYet = &amp;noDeviceIdentityYetError{}

// noDeviceIdentityYetError is returned when the device doesn't have a serial assertion.
type noDeviceIdentityYetError struct{}

func (e *noDeviceIdentityYetError) Error() string <span class="cov0" title="0">{
        return "device has no identity yet"
}</span>

func (e *noDeviceIdentityYetError) Is(err error) bool <span class="cov0" title="0">{
        _, ok := err.(*noDeviceIdentityYetError)
        return ok || errors.Is(err, state.ErrNoState)
}</span>

// DeviceManager is responsible for managing the device identity and device
// policies.
type DeviceManager struct {
        // sysMode is the system mode from modeenv or "" on pre-UC20,
        // use SystemMode instead
        sysMode string
        // saveAvailable keeps track whether /var/lib/snapd/save
        // is available, i.e. exists and is mounted from ubuntu-save
        // if the latter exists.
        saveAvailable bool

        state   *state.State
        hookMgr *hookstate.HookManager

        cachedKeypairMgr asserts.KeypairManager

        // newStore can make new stores for remodeling
        newStore func(storecontext.DeviceBackend) snapstate.StoreService

        bootOkRan            bool
        bootRevisionsUpdated bool

        seedTimings *timings.Timings
        // this is used during early phases until seeding is under way
        earlyDeviceSeed seed.Seed
        // these are details about the chosen seed we will be seeding from,
        // set and valid only before seeding has happened. Should not be
        // used by tasks that are not explicitly happening prior to system being marked seeded.
        seedLabel, seedMode string
        seedChosen          bool

        populateStateFromSeed func(timings.Measurer) ([]*state.TaskSet, error)

        ensureSeedInConfigRan bool

        ensureInstalledRan        bool
        ensureFactoryResetRan     bool
        ensurePostFactoryResetRan bool

        ensureTriedRecoverySystemRan bool

        cloudInitAlreadyRestricted           bool
        cloudInitErrorAttemptStart           *time.Time
        cloudInitEnabledInactiveAttemptStart *time.Time

        lastBecomeOperationalAttempt time.Time
        becomeOperationalBackoff     time.Duration
        registered                   bool
        reg                          chan struct{}
        noRegister                   bool

        preseed            bool
        preseedSystemLabel string

        ntpSyncedOrTimedOut bool
}

// Manager returns a new device manager.
func Manager(s *state.State, hookManager *hookstate.HookManager, runner *state.TaskRunner, newStore func(storecontext.DeviceBackend) snapstate.StoreService) (*DeviceManager, error) <span class="cov8" title="1">{
        delayedCrossMgrInit()

        m := &amp;DeviceManager{
                state:    s,
                hookMgr:  hookManager,
                newStore: newStore,
                reg:      make(chan struct{}),
                preseed:  snapdenv.Preseeding(),
        }
        m.populateStateFromSeed = m.populateStateFromSeedImpl

        if !m.preseed </span><span class="cov8" title="1">{
                mode, explicit, err := boot.SystemMode("")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if explicit </span><span class="cov0" title="0">{
                        logger.Debugf("explicitly set system mode")
                        m.sysMode = mode
                }</span>
        } else<span class="cov0" title="0"> {
                // cache system label for preseeding of core20; note, this will fail on
                // core16/core18 (they are not supported by preseeding) as core20 system
                // label is expected.
                if !release.OnClassic </span><span class="cov0" title="0">{
                        var err error
                        m.preseedSystemLabel, err = systemForPreseeding()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">m.sysMode = "run"</span>
                }
        }

        <span class="cov8" title="1">s.Lock()
        s.Cache(deviceMgrKey{}, m)
        s.Unlock()

        if err := m.confirmRegistered(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hookManager.Register(regexp.MustCompile("^prepare-device$"), newBasicHookStateHandler)
        hookManager.Register(regexp.MustCompile("^install-device$"), newBasicHookStateHandler)
        hookManager.Register(regexp.MustCompile("^prepare-serial-request$"), newBasicHookStateHandler)

        runner.AddHandler("generate-device-key", m.doGenerateDeviceKey, nil)
        runner.AddHandler("request-serial", m.doRequestSerial, nil)
        // Mark-preseeded touches and records the system-key, ensure that it does
        // not run in parallel with other tasks touching the system-key
        runner.AddHandler("mark-preseeded", m.doMarkPreseeded, nil)
        runner.AddHandler("mark-seeded", m.doMarkSeeded, nil)
        runner.AddHandler("setup-ubuntu-save", m.doSetupUbuntuSave, nil)
        runner.AddHandler("setup-run-system", m.doSetupRunSystem, nil)
        runner.AddHandler("factory-reset-run-system", m.doFactoryResetRunSystem, nil)
        runner.AddHandler("restart-system-to-run-mode", m.doRestartSystemToRunMode, nil)
        runner.AddHandler("prepare-remodeling", m.doPrepareRemodeling, nil)
        runner.AddCleanup("prepare-remodeling", m.cleanupRemodel)
        // this *must* always run last and finalizes a remodel
        runner.AddHandler("set-model", m.doSetModel, nil)
        runner.AddCleanup("set-model", m.cleanupRemodel)
        // There is no undo for successful gadget updates. The system is
        // rebooted during update, if it boots up to the point where snapd runs
        // we deem the new assets (be it bootloader or firmware) functional. The
        // deployed boot assets must be backward compatible with reverted kernel
        // or gadget snaps. There are no further changes to the boot assets,
        // unless a new gadget update is deployed.
        runner.AddHandler("update-gadget-assets", m.doUpdateGadgetAssets, nil)
        // There is no undo handler for successful boot config update. The
        // config assets are assumed to be always backwards compatible.
        runner.AddHandler("update-managed-boot-config", m.doUpdateManagedBootConfig, nil)
        // kernel command line updates from a gadget supplied file
        runner.AddHandler("update-gadget-cmdline", m.doUpdateGadgetCommandLine, m.undoUpdateGadgetCommandLine)
        // recovery systems
        runner.AddHandler("remove-recovery-system", m.doRemoveRecoverySystem, nil)
        runner.AddHandler("create-recovery-system", m.doCreateRecoverySystem, m.undoCreateRecoverySystem)
        runner.AddCleanup("create-recovery-system", m.cleanupRecoverySystem)
        runner.AddHandler("finalize-recovery-system", m.doFinalizeTriedRecoverySystem, m.undoFinalizeTriedRecoverySystem)
        runner.AddCleanup("finalize-recovery-system", m.cleanupRecoverySystem)

        // used from the install API
        // TODO: use better task names that are close to our usual pattern
        runner.AddHandler("install-finish", m.doInstallFinish, nil)
        runner.AddHandler("install-setup-storage-encryption", m.doInstallSetupStorageEncryption, nil)

        runner.AddBlocked(gadgetUpdateBlocked)

        // wire FDE kernel hook support into boot
        boot.HookKeyProtectorFactory = m.hookKeyProtectorFactory
        hookManager.Register(regexp.MustCompile("^fde-setup$"), newFdeSetupHandler)

        return m, nil</span>
}

func ensureFileDirPermissions() error <span class="cov8" title="1">{
        // Ensure the /var/lib/snapd/void dir has correct permissions, we
        // do this in the postinst for classic systems already but it's
        // needed here for Core systems.
        st, err := os.Stat(dirs.SnapVoidDir)
        if err == nil &amp;&amp; st.Mode().Perm() != 0111 </span><span class="cov0" title="0">{
                logger.Noticef("fixing permissions of %v to 0111", dirs.SnapVoidDir)
                if err := os.Chmod(dirs.SnapVoidDir, 0111); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type genericHook struct{}

func (h genericHook) Before() error                 <span class="cov8" title="1">{ return nil }</span>
func (h genericHook) Done() error                   <span class="cov8" title="1">{ return nil }</span>
func (h genericHook) Error(err error) (bool, error) <span class="cov0" title="0">{ return false, nil }</span>

func newBasicHookStateHandler(context *hookstate.Context) hookstate.Handler <span class="cov8" title="1">{
        return genericHook{}
}</span>

// ReloadModeenv is only useful for integration testing
func (m *DeviceManager) ReloadModeenv() error <span class="cov0" title="0">{
        osutil.MustBeTestBinary("ReloadModeenv can only be called from tests")

        mode, explicit, err := boot.SystemMode("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if explicit </span><span class="cov0" title="0">{
                m.sysMode = mode
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type SysExpectation int

const (
        // SysAny indicates any system is appropriate.
        SysAny SysExpectation = iota
        // SysHasModeenv indicates only systems with modeenv are appropriate.
        SysHasModeenv
)

// SystemMode returns the current mode of the system.
// An expectation about the system controls the returned mode when
// none is set explicitly, as it's the case on pre-UC20 systems. In
// which case, with SysAny, the mode defaults to implicit "run", thus
// covering pre-UC20 systems. With SysHasModeeenv, as there is always
// an explicit mode in systems that use modeenv, no implicit default
// is used and thus "" is returned for pre-UC20 systems.
func (m *DeviceManager) SystemMode(sysExpect SysExpectation) string <span class="cov8" title="1">{
        if m.sysMode == "" </span><span class="cov8" title="1">{
                if sysExpect == SysHasModeenv </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">return "run"</span>
        }
        <span class="cov0" title="0">return m.sysMode</span>
}

// StartUp implements StateStarterUp.Startup.
func (m *DeviceManager) StartUp() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        dev, err := m.earlyDeviceContext()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        // if ErrNoState then dev is nil, we assume a classic system here,
        // any error will re-surface again in the main first boot code
        <span class="cov8" title="1">if dev != nil &amp;&amp; m.shouldMountUbuntuSave(dev) </span><span class="cov0" title="0">{
                if err := m.setupUbuntuSave(dev); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot set up ubuntu-save: %v", err)
                }</span>
        }

        // ensure /var/lib/snapd/void permissions are ok
        <span class="cov8" title="1">if err := ensureFileDirPermissions(); err != nil </span><span class="cov0" title="0">{
                logger.Noticef("%v", fmt.Errorf("cannot ensure device file/dir permissions: %v", err))
        }</span>

        // TODO: setup proper timings measurements for this

        <span class="cov8" title="1">return EarlyConfig(m.state, m.earlyPreloadGadget)</span>
}

func (m *DeviceManager) shouldMountUbuntuSave(dev snap.Device) bool <span class="cov0" title="0">{
        if dev.IsClassicBoot() </span><span class="cov0" title="0">{
                return false
        }</span>
        // TODO:UC20+: ubuntu-save needs to be mounted for recover too
        <span class="cov0" title="0">return m.SystemMode(SysHasModeenv) == "run"</span>
}

func (m *DeviceManager) ensureUbuntuSaveIsMounted() error <span class="cov0" title="0">{
        saveMounted, err := osutil.IsMounted(dirs.SnapSaveDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if saveMounted </span><span class="cov0" title="0">{
                logger.Noticef("save already mounted under %v", dirs.SnapSaveDir)
                return nil
        }</span>

        <span class="cov0" title="0">runMntSaveMounted, err := osutil.IsMounted(boot.InitramfsUbuntuSaveDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !runMntSaveMounted </span><span class="cov0" title="0">{
                // we don't have ubuntu-save, save will be used directly
                logger.Noticef("no ubuntu-save mount")
                return nil
        }</span>

        <span class="cov0" title="0">sysd := systemd.New(systemd.SystemMode, progress.Null)

        // In newer core20/core22 we have a mount unit for ubuntu-save, which we
        // will try to start first. Invoking systemd-mount in this case would fail.
        err = sysd.Start([]string{"var-lib-snapd-save.mount"})
        if err == nil </span><span class="cov0" title="0">{
                logger.Noticef("mount unit for ubuntu-save was started")
                return nil
        }</span> else<span class="cov0" title="0"> {
                // We only fall through and mount directly if the failure was because of a missing
                // mount file, which possible does not exist. Any other failure we treat as an actual
                // error.
                // XXX: systemd ideally should start returning some kind UnitNotFound errors in this situation
                if !strings.Contains(err.Error(), "Unit var-lib-snapd-save.mount not found.") </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Otherwise try to directly mount the partition with systemd-mount.
        <span class="cov0" title="0">logger.Noticef("bind-mounting ubuntu-save under %v", dirs.SnapSaveDir)
        err = sysd.Mount(boot.InitramfsUbuntuSaveDir, dirs.SnapSaveDir, "-o", "bind")
        if err != nil </span><span class="cov0" title="0">{
                logger.Noticef("bind-mounting ubuntu-save failed %v", err)
                return fmt.Errorf("cannot bind mount %v under %v: %v", boot.InitramfsUbuntuSaveDir, dirs.SnapSaveDir, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ensureUbuntuSaveSnapFolders creates the necessary folder structure for
// /var/lib/snapd/save/snap/&lt;snap&gt;. This is normally done during installation
// of a snap, but there are two cases where this can be insufficient.
//
//  1. When migrating to a newer snapd, folders are not automatically created for
//     snaps that are already installed. They will only be created during a refresh of
//     the snap itself, whereas we want to cover all the cases.
//  2. During install mode for the gadget/kernel/etc, the folders are not created.
//     So this function can be invoked as a part of system-setup.
func (m *DeviceManager) ensureUbuntuSaveSnapFolders() error <span class="cov0" title="0">{
        snaps, err := snapstate.All(m.state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, s := range snaps </span><span class="cov0" title="0">{
                saveDir := snap.CommonDataSaveDir(s.InstanceName())
                if err := os.MkdirAll(saveDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// setupUbuntuSave sets up ubuntu-save partition. It makes sure
// to mount ubuntu-save (if feasible), and ensures the correct snap
// folders are present according to currently installed snaps.
func (m *DeviceManager) setupUbuntuSave(dev snap.Device) error <span class="cov0" title="0">{
        if err := m.ensureUbuntuSaveIsMounted(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // At this point ubuntu-save should be available under the
        // /var/lib/snapd/save path, so we mark the partition as such.
        <span class="cov0" title="0">m.saveAvailable = true

        // The last step is to ensure needed folder structure is present
        // for the per-snap folder storage.
        // We support this only on Core for now.
        if dev.Classic() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return m.ensureUbuntuSaveSnapFolders()</span>
}

type deviceMgrKey struct{}

func deviceMgr(st *state.State) *DeviceManager <span class="cov8" title="1">{
        mgr := st.Cached(deviceMgrKey{})
        if mgr == nil </span><span class="cov0" title="0">{
                panic("internal error: device manager is not yet associated with state")</span>
        }
        <span class="cov8" title="1">return mgr.(*DeviceManager)</span>
}

func (m *DeviceManager) CanStandby() bool <span class="cov0" title="0">{
        var seeded bool
        if err := m.state.Get("seeded", &amp;seeded); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return seeded</span>
}

func (m *DeviceManager) confirmRegistered() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        device, err := m.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if device.Serial != "" </span><span class="cov0" title="0">{
                m.markRegistered()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *DeviceManager) markRegistered() <span class="cov8" title="1">{
        if m.registered </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m.registered = true
        close(m.reg)</span>
}

func gadgetUpdateBlocked(cand *state.Task, running []*state.Task) bool <span class="cov8" title="1">{
        if cand.Kind() == "update-gadget-assets" &amp;&amp; len(running) != 0 </span><span class="cov0" title="0">{
                // update-gadget-assets must be the only task running
                return true
        }</span>
        <span class="cov8" title="1">for _, other := range running </span><span class="cov0" title="0">{
                if other.Kind() == "update-gadget-assets" </span><span class="cov0" title="0">{
                        // no other task can be started when
                        // update-gadget-assets is running
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (m *DeviceManager) changeInFlight(kind string) bool <span class="cov8" title="1">{
        for _, chg := range m.state.Changes() </span><span class="cov8" title="1">{
                if chg.Kind() == kind &amp;&amp; !chg.IsReady() </span><span class="cov8" title="1">{
                        // change already in motion
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// helpers to keep count of attempts to get a serial, useful to decide
// to give up holding off trying to auto-refresh

type ensureOperationalAttemptsKey struct{}

func incEnsureOperationalAttempts(st *state.State) <span class="cov8" title="1">{
        cur, _ := st.Cached(ensureOperationalAttemptsKey{}).(int)
        st.Cache(ensureOperationalAttemptsKey{}, cur+1)
}</span>

func ensureOperationalAttempts(st *state.State) int <span class="cov0" title="0">{
        cur, _ := st.Cached(ensureOperationalAttemptsKey{}).(int)
        return cur
}</span>

// ensureOperationalShouldBackoff returns whether we should abstain from
// further become-operational tentatives while its backoff interval is
// not expired.
func (m *DeviceManager) ensureOperationalShouldBackoff(now time.Time) bool <span class="cov8" title="1">{
        if !m.lastBecomeOperationalAttempt.IsZero() &amp;&amp; m.lastBecomeOperationalAttempt.Add(m.becomeOperationalBackoff).After(now) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if m.becomeOperationalBackoff == 0 </span><span class="cov8" title="1">{
                m.becomeOperationalBackoff = 5 * time.Minute
        }</span> else<span class="cov0" title="0"> {
                newBackoff := m.becomeOperationalBackoff * 2
                if newBackoff &gt; (12 * time.Hour) </span><span class="cov0" title="0">{
                        newBackoff = 24 * time.Hour
                }</span>
                <span class="cov0" title="0">m.becomeOperationalBackoff = newBackoff</span>
        }
        <span class="cov8" title="1">m.lastBecomeOperationalAttempt = now
        return false</span>
}

func setClassicFallbackModel(st *state.State, device *auth.DeviceState) error <span class="cov0" title="0">{
        err := assertstate.Add(st, sysdb.GenericClassicModel())
        if err != nil &amp;&amp; !asserts.IsUnaccceptedUpdate(err) </span><span class="cov0" title="0">{
                return fmt.Errorf(`cannot install "generic-classic" fallback model assertion: %v`, err)
        }</span>
        <span class="cov0" title="0">device.Brand = "generic"
        device.Model = "generic-classic"
        if err := internal.SetDevice(st, device); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DeviceManager) ensureOperational() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if m.SystemMode(SysAny) != "run" </span><span class="cov0" title="0">{
                // avoid doing registration in ephemeral mode
                // note: this also stop auto-refreshes indirectly
                return nil
        }</span>

        <span class="cov8" title="1">device, err := m.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if device.Serial != "" </span><span class="cov8" title="1">{
                // serial is set, we are all set
                return nil
        }</span>

        <span class="cov8" title="1">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureOperational")

        perfTimings := timings.New(map[string]string{"ensure": "become-operational"})

        // conditions to trigger device registration
        //
        // * have a model assertion with a gadget (core and
        //   device-like classic) in which case we need also to wait
        //   for the gadget to have been installed though
        // TODO: consider a way to support lazy registration on classic
        // even with a gadget and some preseeded snaps
        //
        // * classic with a model assertion with a non-default store specified
        // * lazy classic case (might have a model with no gadget nor store
        //   or no model): we wait to have some snaps installed or be
        //   in the process to install some

        var seeded bool
        err = m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if device.Brand == "" || device.Model == "" </span><span class="cov0" title="0">{
                if !release.OnClassic || !seeded </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // we are on classic and seeded but there is no model:
                // use a fallback model!
                <span class="cov0" title="0">err := setClassicFallbackModel(m.state, device)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if m.noRegister </span><span class="cov0" title="0">{
                return nil
        }</span>
        // noregister marker file is checked below after mostly in-memory checks

        <span class="cov8" title="1">if m.changeInFlight("become-operational") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var storeID, gadget string
        model, err := m.Model()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                gadget = model.Gadget()
                storeID = model.Store()
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("internal error: core device brand and model are set but there is no model assertion")
        }</span>

        <span class="cov8" title="1">willRequestSerial, err := shouldRequestSerial(m.state, gadget)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // if we should not fetch the device serial (either store.access or
        // device.service.access is set to offline), and we have already generated a
        // device key, we can return early. otherwise, we need to run the
        // generate-device-key task
        <span class="cov8" title="1">if !willRequestSerial &amp;&amp; device.KeyID != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if gadget == "" &amp;&amp; storeID == "" </span><span class="cov0" title="0">{
                // classic: if we have no gadget and no non-default store
                // wait to have snaps or snap installation

                n, err := snapstate.NumSnaps(m.state)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if n == 0 &amp;&amp; !snapstate.Installing(m.state) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // registration is blocked until reboot
        <span class="cov8" title="1">if osutil.FileExists(filepath.Join(dirs.SnapRunDir, "noregister")) </span><span class="cov0" title="0">{
                m.noRegister = true
                return nil
        }</span>

        <span class="cov8" title="1">var hasPrepareDeviceHook bool
        var hasPrepareSerialRequestHook bool
        // if there's a gadget specified wait for it
        if gadget != "" </span><span class="cov8" title="1">{
                // if have a gadget wait until seeded to proceed
                if !seeded </span><span class="cov8" title="1">{
                        // this will be run again, so eventually when the system is
                        // seeded the code below runs
                        return nil

                }</span>

                <span class="cov8" title="1">gadgetInfo, err := snapstate.CurrentInfo(m.state, gadget)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">hasPrepareDeviceHook = (gadgetInfo.Hooks["prepare-device"] != nil)
                hasPrepareSerialRequestHook = (gadgetInfo.Hooks["prepare-serial-request"] != nil)</span>
        }

        <span class="cov8" title="1">if device.KeyID == "" &amp;&amp; model.Grade() != "" </span><span class="cov8" title="1">{
                // UC20+ devices support factory reset
                serial, err := m.maybeRestoreAfterReset(device)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if serial != nil </span><span class="cov0" title="0">{
                        device.KeyID = serial.DeviceKey().ID()
                        device.Serial = serial.Serial()
                        if err := m.setDevice(device); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot set device for restored serial and key: %v", err)
                        }</span>
                        <span class="cov0" title="0">logger.Noticef("restored serial %v for %v/%v signed with key %v",
                                device.Serial, device.Brand, device.Model, device.KeyID)
                        return nil</span>
                }
        }

        // have some backoff between full retries
        <span class="cov8" title="1">if m.ensureOperationalShouldBackoff(time.Now()) </span><span class="cov0" title="0">{
                return nil
        }</span>
        // increment attempt count
        <span class="cov8" title="1">incEnsureOperationalAttempts(m.state)

        // XXX: some of these will need to be split and use hooks
        // retries might need to embrace more than one "task" then,
        // need to be careful

        tasks := []*state.Task{}

        var prepareDevice *state.Task
        if hasPrepareDeviceHook </span><span class="cov8" title="1">{
                summary := i18n.G("Run prepare-device hook")
                hooksup := &amp;hookstate.HookSetup{
                        Snap: gadget,
                        Hook: "prepare-device",
                }
                prepareDevice = hookstate.HookTask(m.state, summary, hooksup, nil)
                tasks = append(tasks, prepareDevice)
        }</span>

        <span class="cov8" title="1">genKey := m.state.NewTask("generate-device-key", i18n.G("Generate device key"))
        if prepareDevice != nil </span><span class="cov8" title="1">{
                genKey.WaitFor(prepareDevice)
        }</span>
        <span class="cov8" title="1">tasks = append(tasks, genKey)

        if hasPrepareSerialRequestHook </span><span class="cov8" title="1">{
                m.state.Set("has-prepare-serial-request-hook", true)
        }</span>

        <span class="cov8" title="1">if willRequestSerial </span><span class="cov8" title="1">{
                requestSerial := m.state.NewTask("request-serial", i18n.G("Request device serial"))
                requestSerial.WaitFor(genKey)
                tasks = append(tasks, requestSerial)
        }</span>

        <span class="cov8" title="1">chg := m.state.NewChange(becomeOperationalChangeKind, i18n.G("Initialize device"))
        chg.AddAll(state.NewTaskSet(tasks...))

        state.TagTimingsWithChange(perfTimings, chg)
        perfTimings.Save(m.state)

        return nil</span>
}

// maybeRestoreAfterReset attempts to restore the serial assertion with a
// matching key in a post-factory reset scenario. It is possible that it is
// called when the device was unregistered, but when doing so, the device key is
// removed.
func (m *DeviceManager) maybeRestoreAfterReset(device *auth.DeviceState) (*asserts.Serial, error) <span class="cov8" title="1">{
        // there should be a serial assertion for the current model
        serials, err := assertstate.DB(m.state).FindMany(asserts.SerialType, map[string]string{
                "brand-id": device.Brand,
                "model":    device.Model,
        })
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov8" title="1">{
                        // no serial assertion
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">for _, serial := range serials </span><span class="cov0" title="0">{
                serialAs := serial.(*asserts.Serial)
                deviceKeyID := serialAs.DeviceKey().ID()
                logger.Debugf("processing candidate serial assertion for %v/%v signed with key %v",
                        device.Brand, device.Model, deviceKeyID)
                // serial assertion is signed with the device key, its ID is in
                // the header; factory-reset would have restored the serial
                // assertion and a matching device key, OTOH when the device is
                // unregistered we explicitly remove the key, hence should this
                // code process such serial assertion, there will be no matching
                // key for it
                err = m.withKeypairMgr(func(kpmgr asserts.KeypairManager) error </span><span class="cov0" title="0">{
                        _, err := kpmgr.Get(deviceKeyID)
                        return err
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if asserts.IsKeyNotFound(err) </span><span class="cov0" title="0">{
                                // there is no key matching this serial assertion,
                                // perhaps device was unregistered at some point
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">return serialAs, nil</span>
        }
        // none of the assertions has a matching key
        <span class="cov0" title="0">return nil, nil</span>
}

var startTime time.Time

func init() <span class="cov8" title="1">{
        startTime = time.Now()
}</span>

func (m *DeviceManager) setTimeOnce(name string, t time.Time) error <span class="cov8" title="1">{
        var prev time.Time
        err := m.state.Get(name, &amp;prev)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !prev.IsZero() </span><span class="cov0" title="0">{
                // already set
                return nil
        }</span>
        <span class="cov8" title="1">m.state.Set(name, t)
        return nil</span>
}

func (m *DeviceManager) seedStart() (*timings.Timings, error) <span class="cov8" title="1">{
        if m.seedTimings != nil </span><span class="cov0" title="0">{
                // reuse the early cached one
                return m.seedTimings, nil
        }</span>
        <span class="cov8" title="1">perfTimings := timings.New(map[string]string{"ensure": "seed"})

        var recordedStart string
        var start time.Time
        if m.preseed </span><span class="cov0" title="0">{
                recordedStart = "preseed-start-time"
                start = timeNow()
        }</span> else<span class="cov8" title="1"> {
                recordedStart = "seed-start-time"
                start = startTime
        }</span>
        <span class="cov8" title="1">if err := m.setTimeOnce(recordedStart, start); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return perfTimings, nil</span>
}

func (m *DeviceManager) systemForPreseeding() string <span class="cov0" title="0">{
        if m.preseedSystemLabel == "" </span><span class="cov0" title="0">{
                panic("no system to preseed")</span>
        }
        <span class="cov0" title="0">return m.preseedSystemLabel</span>
}

func (m *DeviceManager) earlyDeviceContext() (snapstate.DeviceContext, error) <span class="cov8" title="1">{
        mod, err := findModel(m.state)
        if err == nil </span><span class="cov0" title="0">{
                return newModelDeviceContext(m, mod), nil
        }</span>
        <span class="cov8" title="1">if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dev, _, err := m.earlyLoadDeviceSeed(state.ErrNoState)
        return dev, err</span>
}

// seedLabelAndMode finds out the label and mode under which to seed the system.
// Only to use if not yet seeded.
// TODO: can it be unified with the code in Manager?
func (m *DeviceManager) seedLabelAndMode() (seedLabel, seedMode string, err error) <span class="cov8" title="1">{
        if m.seedChosen </span><span class="cov0" title="0">{
                return m.seedLabel, m.seedMode, nil
        }</span>
        <span class="cov8" title="1">if m.preseed </span><span class="cov0" title="0">{
                if !release.OnClassic </span><span class="cov0" title="0">{
                        seedMode = "run"
                        seedLabel = m.systemForPreseeding()
                }</span>
        } else<span class="cov8" title="1"> {
                modeenv, err := boot.MaybeReadModeenv()
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>
                <span class="cov8" title="1">if modeenv != nil </span><span class="cov0" title="0">{
                        logger.Debugf("modeenv read, mode %q label %q",
                                modeenv.Mode, modeenv.RecoverySystem)
                        seedMode = modeenv.Mode
                        seedLabel = modeenv.RecoverySystem
                }</span>
        }
        <span class="cov8" title="1">m.seedLabel = seedLabel
        m.seedMode = seedMode
        m.seedChosen = true
        return seedLabel, seedMode, nil</span>
}

func (m *DeviceManager) earlyLoadDeviceSeed(seedLoadErr error) (snapstate.DeviceContext, seed.Seed, error) <span class="cov8" title="1">{
        var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if seeded </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("internal error: loading device seed after being seeded already")
        }</span>

        // consider whether we were called already
        <span class="cov8" title="1">if m.earlyDeviceSeed != nil </span><span class="cov0" title="0">{
                return newModelDeviceContext(m, m.earlyDeviceSeed.Model()), m.earlyDeviceSeed, nil
        }</span>

        <span class="cov8" title="1">sysLabel, _, err := m.seedLabelAndMode()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // we time StartUp/earlyPreloadGadget + first ensureSeeded together
        // under --ensure=seed
        <span class="cov8" title="1">tm, err := m.seedStart()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        // cached for first ensureSeeded
        <span class="cov8" title="1">m.seedTimings = tm

        var deviceSeed seed.Seed
        timings.Run(tm, "import-assertions[early]", "early import assertions from seed", func(nested timings.Measurer) </span><span class="cov8" title="1">{
                deviceSeed, err = loadDeviceSeed(m.state, sysLabel)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // use seedLoadErr if specified
                if seedLoadErr != nil </span><span class="cov8" title="1">{
                        err = seedLoadErr
                }</span>
                <span class="cov8" title="1">return nil, nil, err</span>
        }

        <span class="cov0" title="0">dev := newModelDeviceContext(m, deviceSeed.Model())

        // cache
        m.earlyDeviceSeed = deviceSeed
        return dev, deviceSeed, nil</span>
}

func (m *DeviceManager) earlyPreloadGadget() (sysconfig.Device, *gadget.Info, error) <span class="cov0" title="0">{
        // Here we behave as if there was no gadget if we encounter
        // errors, under the assumption that those will be resurfaced
        // in ensureSeed. This preserves having a failing to seed
        // snapd continuing running.
        //
        // TODO: consider changing that again but we need consider the
        // effect of the different failure mode.
        //
        // We also assume that anything sensitive will not be guarded
        // just by option flags. For example automatic user creation
        // also requires the model to be known/set. Otherwise ignoring
        // errors here would be problematic.
        dev, deviceSeed, err := m.earlyLoadDeviceSeed(state.ErrNoState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">model := dev.Model()
        if model.Gadget() == "" </span><span class="cov0" title="0">{
                // no gadget
                return nil, nil, state.ErrNoState
        }</span>
        <span class="cov0" title="0">var gi *gadget.Info

        timings.Run(m.seedTimings, "preload-verified-gadget-metadata", "preload verified gadget metadata from seed", func(nested timings.Measurer) </span><span class="cov0" title="0">{
                gi, err = func() (*gadget.Info, error) </span><span class="cov0" title="0">{
                        if err := deviceSeed.LoadEssentialMeta([]snap.Type{snap.TypeGadget}, nested); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">essGadget := deviceSeed.EssentialSnaps()
                        if len(essGadget) != 1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("multiple gadgets among essential snaps are unexpected")
                        }</span>
                        <span class="cov0" title="0">snapf, err := snapfile.Open(essGadget[0].Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return gadget.ReadInfoFromSnapFile(snapf, model)</span>
                }()
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Noticef("preload verified gadget metadata from seed failed: %v", err)
                return nil, nil, state.ErrNoState
        }</span>

        <span class="cov0" title="0">return dev, gi, nil</span>
}

// ensureSeeded makes sure that the snaps from seed.yaml get installed
// with the matching assertions
func (m *DeviceManager) ensureSeeded() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if seeded </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.changeInFlight("seed") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">perfTimings, err := m.seedStart()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // we time StartUp/earlyPreloadGadget + first ensureSeeded together
        // succcessive ensureSeeded should be timed separately
        <span class="cov0" title="0">m.seedTimings = nil

        var tsAll []*state.TaskSet
        timings.Run(perfTimings, "state-from-seed", "populate state from seed", func(tm timings.Measurer) </span><span class="cov0" title="0">{
                tsAll, err = m.populateStateFromSeed(tm)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(tsAll) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureSeeded")

        chg := m.state.NewChange(seedChangeKind, "Initialize system state")
        for _, ts := range tsAll </span><span class="cov0" title="0">{
                chg.AddAll(ts)
        }</span>
        <span class="cov0" title="0">m.state.EnsureBefore(0)

        state.TagTimingsWithChange(perfTimings, chg)
        perfTimings.Save(m.state)
        return nil</span>
}

var processAutoImportAssertionsImpl = processAutoImportAssertions

// ensureAutoImportAssertions makes sure that auto import assertions
// get processed. Assertion should be processed while seeding is in progress.
func (m *DeviceManager) ensureAutoImportAssertions() error <span class="cov8" title="1">{
        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">m.state.Lock()
        defer m.state.Unlock()

        if m.earlyDeviceSeed == nil </span><span class="cov8" title="1">{
                // we have no seed cached yet, no point to check further
                return nil
        }</span>

        <span class="cov0" title="0">mode := m.SystemMode(SysAny)
        if mode == "install" || mode == "factory-reset" </span><span class="cov0" title="0">{
                // we do not auto-import assertions during install modes
                // snap auto-import also does not
                return nil
        }</span>

        <span class="cov0" title="0">var seeded bool
        if err := m.state.Get("seeded", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        // if system is seeded, stop trying
        <span class="cov0" title="0">if seeded </span><span class="cov0" title="0">{
                return nil
        }</span>

        // check if we have processed auto-import asssertions already
        <span class="cov0" title="0">var autoImported bool
        if err := m.state.Get("asserts-early-auto-imported", &amp;autoImported); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if autoImported </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureAutoImportAssertions")

        commitTo := func(batch *asserts.Batch) error </span><span class="cov0" title="0">{
                return assertstate.AddBatch(m.state, batch, nil)
        }</span>
        <span class="cov0" title="0">db := assertstate.DB(m.state)
        // Set asserts-early-auto-imported as processed, even if it fails,
        // it should not be re-run. State should not be altered once
        // processAutoImportAssertionsImpl is called.
        m.state.Set("asserts-early-auto-imported", true)
        err := processAutoImportAssertionsImpl(m.state, m.earlyDeviceSeed, db, commitTo)
        if err != nil </span><span class="cov0" title="0">{
                // best effort
                logger.Noticef("cannot process auto import assertion: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DeviceManager) ensureSerialBoundSystemUserAssertionsProcessed() error <span class="cov8" title="1">{
        // in situations where a device serial can be anticipated, it is
        // possible to create a serial-bound system-user assertion beforehand,
        // this Ensure logic takes care of creating the corresponding user even
        // if system-user gets presented to the device before the actual serial
        // assertion is acquired, see the corresponding code setting the
        // system-user-waiting-on-serial flag in createAllKnownSystemUsers
        // (users.go).
        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">m.state.Lock()
        defer m.state.Unlock()

        var waitingOnSerial bool
        err := m.state.Get("system-user-waiting-on-serial", &amp;waitingOnSerial)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !waitingOnSerial </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">var seeded bool
        if err := m.state.Get("seeded", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil
        }</span>

        // we should always have a model if we are seeded and not on classic
        <span class="cov0" title="0">model, err := m.Model()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">serial, err := m.Serial()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureSerialBoundSystemUserAssertionsProcessed")

        db := assertstate.DB(m.state)

        const sudoer = true
        _, err = createAllKnownSystemUsers(m.state, db, model, serial, sudoer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.state.Set("system-user-waiting-on-serial", false)

        return nil</span>
}

func (m *DeviceManager) ensureBootOk() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        // boot-ok/update-boot-revision is only relevant in run-mode
        if m.SystemMode(SysAny) != "run" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if !m.bootOkRan </span><span class="cov8" title="1">{
                deviceCtx, err := DeviceCtx(m.state, nil, nil)
                if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; deviceCtx.Model().KernelSnap() != nil </span><span class="cov8" title="1">{
                        if err := boot.MarkBootSuccessful(deviceCtx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := secbootMarkSuccessful(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">m.bootOkRan = true</span>
        }
        <span class="cov8" title="1">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureBootOk")

        if !m.bootRevisionsUpdated </span><span class="cov8" title="1">{
                if err := snapstate.UpdateBootRevisions(m.state); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.bootRevisionsUpdated = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *DeviceManager) ensureCloudInitRestricted() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if m.cloudInitAlreadyRestricted </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !seeded </span><span class="cov8" title="1">{
                // we need to wait until we are seeded
                return nil
        }</span>

        <span class="cov8" title="1">if release.OnClassic </span><span class="cov0" title="0">{
                // don't re-run on classic since classic devices don't get subject to
                // the cloud-init restricting that core devices do
                m.cloudInitAlreadyRestricted = true
                return nil
        }</span>

        // On Ubuntu Core devices that have been seeded, we want to restrict
        // cloud-init so that its more dangerous (for an IoT device at least)
        // features are not exploitable after a device has been seeded. This allows
        // device administrators and other tools (such as multipass) to still
        // configure an Ubuntu Core device on first boot, and also allows cloud
        // vendors to run cloud-init with only a specific data-source on subsequent
        // boots but disallows arbitrary cloud-init {user,meta,vendor}-data to be
        // attached to a device via a USB drive and inject code onto the device.

        <span class="cov8" title="1">opts := &amp;sysconfig.CloudInitRestrictOptions{}

        // check the current state of cloud-init, if it is disabled or already
        // restricted then we have nothing to do
        cloudInitStatus, err := cloudInitStatus()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureCloudInitRestricted")
        statusMsg := ""

        switch cloudInitStatus </span>{
        case sysconfig.CloudInitDisabledPermanently, sysconfig.CloudInitRestrictedBySnapd:<span class="cov8" title="1">
                // already been permanently disabled, nothing to do
                m.cloudInitAlreadyRestricted = true
                return nil</span>
        case sysconfig.CloudInitNotFound:<span class="cov0" title="0">
                // no cloud init at all
                statusMsg = "not found"</span>
        case sysconfig.CloudInitUntriggered:<span class="cov0" title="0">
                // hasn't been used
                statusMsg = "reported to be in disabled state"</span>
        case sysconfig.CloudInitDone:<span class="cov0" title="0">
                // is done being used
                statusMsg = "reported to be done"</span>
        case sysconfig.CloudInitErrored:<span class="cov0" title="0">
                // cloud-init errored, so we give the device admin / developer a few
                // minutes to reboot the machine to re-run cloud-init and try again,
                // otherwise we will disable cloud-init permanently

                // initialize the time we first saw cloud-init in error state
                if m.cloudInitErrorAttemptStart == nil </span><span class="cov0" title="0">{
                        // save the time we started the attempt to restrict
                        now := timeNow()
                        m.cloudInitErrorAttemptStart = &amp;now
                        logger.Noticef("System initialized, cloud-init reported to be in error state, will disable in 3 minutes")
                }</span>

                // check if 3 minutes have elapsed since we first saw cloud-init in
                // error state
                <span class="cov0" title="0">timeSinceFirstAttempt := timeNow().Sub(*m.cloudInitErrorAttemptStart)
                if timeSinceFirstAttempt &lt;= 3*time.Minute </span><span class="cov0" title="0">{
                        // we need to keep waiting for cloud-init, up to 3 minutes
                        nextCheck := 3*time.Minute - timeSinceFirstAttempt
                        m.state.EnsureBefore(nextCheck)
                        return nil
                }</span>
                // otherwise, we timed out waiting for cloud-init to be fixed or
                // rebooted and should restrict cloud-init
                // we will restrict cloud-init below, but we need to force the
                // disable, as by default RestrictCloudInit will error on state
                // CloudInitErrored
                <span class="cov0" title="0">opts.ForceDisable = true
                statusMsg = "reported to be in error state after 3 minutes"</span>
        default:<span class="cov0" title="0">
                // in unknown states we are conservative and let the device run for
                // a while to see if it transitions to a known state, but eventually
                // will disable anyways
                fallthrough</span>
        case sysconfig.CloudInitEnabled:<span class="cov0" title="0">
                // we will give cloud-init up to 5 minutes to try and run, if it
                // still has not transitioned to some other known state, then we
                // will give up waiting for it and disable it anyways

                // initialize the first time we saw cloud-init in enabled state
                if m.cloudInitEnabledInactiveAttemptStart == nil </span><span class="cov0" title="0">{
                        // save the time we started the attempt to restrict
                        now := timeNow()
                        m.cloudInitEnabledInactiveAttemptStart = &amp;now
                }</span>

                // keep re-scheduling again in 10 seconds until we hit 5 minutes
                <span class="cov0" title="0">timeSinceFirstAttempt := timeNow().Sub(*m.cloudInitEnabledInactiveAttemptStart)
                if timeSinceFirstAttempt &lt;= 5*time.Minute </span><span class="cov0" title="0">{
                        // TODO: should we log a message here about waiting for cloud-init
                        //       to be in a "known state"?
                        m.state.EnsureBefore(10 * time.Second)
                        return nil
                }</span>

                // otherwise, we gave cloud-init 5 minutes to run, if it's still not
                // done disable it anyways
                // note we we need to force the disable, as by default
                // RestrictCloudInit will error on state CloudInitEnabled
                <span class="cov0" title="0">opts.ForceDisable = true
                statusMsg = "failed to transition to done or error state after 5 minutes"</span>
        }

        // we should always have a model if we are seeded and are not on classic
        <span class="cov0" title="0">model, err := m.Model()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For UC20, we want to always disable cloud-init after it has run on
        // first boot unless we are in a "real cloud", i.e. not using NoCloud,
        // or if we installed cloud-init configuration from the gadget
        <span class="cov0" title="0">if model.Grade() != asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                // always disable NoCloud/local datasources after first boot on
                // uc20, this is because even if the gadget has a cloud.conf
                // configuring NoCloud, the config installed by cloud-init should
                // not work differently for later boots, so it's sufficient that
                // NoCloud runs on first-boot and never again
                opts.DisableAfterLocalDatasourcesRun = true
        }</span>

        // now restrict/disable cloud-init
        <span class="cov0" title="0">res, err := restrictCloudInit(cloudInitStatus, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // log a message about what we did
        <span class="cov0" title="0">actionMsg := ""
        switch res.Action </span>{
        case "disable":<span class="cov0" title="0">
                actionMsg = "disabled permanently"</span>
        case "restrict":<span class="cov0" title="0">
                // log different messages depending on what datasource was used
                if res.DataSource == "NoCloud" </span><span class="cov0" title="0">{
                        actionMsg = "set datasource_list to [ NoCloud ] and disabled auto-import by filesystem label"
                }</span> else<span class="cov0" title="0"> {
                        // all other datasources just log that we limited it to that datasource
                        actionMsg = fmt.Sprintf("set datasource_list to [ %s ]", res.DataSource)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("internal error: unexpected action %s taken while restricting cloud-init", res.Action)</span>
        }
        <span class="cov0" title="0">logger.Noticef("System initialized, cloud-init %s, %s", statusMsg, actionMsg)

        m.cloudInitAlreadyRestricted = true

        return nil</span>
}

// hasInstallDeviceHook returns whether the gadget has an install-device hook.
// It can return an error if the device has no gadget snap
func (m *DeviceManager) hasInstallDeviceHook(model *asserts.Model) (bool, error) <span class="cov0" title="0">{
        gadgetInfo, err := snapstate.CurrentInfo(m.state, model.Gadget())
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("device is seeded in install mode but has no gadget snap: %v", err)
        }</span>
        <span class="cov0" title="0">hasInstallDeviceHook := (gadgetInfo.Hooks["install-device"] != nil)
        return hasInstallDeviceHook, nil</span>
}

func (m *DeviceManager) installDeviceHookTask(model *asserts.Model) *state.Task <span class="cov0" title="0">{
        summary := i18n.G("Run install-device hook")
        hooksup := &amp;hookstate.HookSetup{
                // TODO: add a reasonable timeout for the install-device hook
                Snap: model.Gadget(),
                Hook: "install-device",
        }
        return hookstate.HookTask(m.state, summary, hooksup, nil)
}</span>

func (m *DeviceManager) ensureInstalled() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.ensureInstalledRan </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.SystemMode(SysHasModeenv) != "install" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">perfTimings := timings.New(map[string]string{"ensure": "install-system"})

        model, err := m.Model()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: core device brand and model are set but there is no model assertion")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // check if the gadget has an install-device hook, do this before
        // we mark ensureInstalledRan as true, as this can fail if no gadget
        // snap is present
        <span class="cov0" title="0">hasInstallDeviceHook, err := m.hasInstallDeviceHook(model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureInstalled")

        m.ensureInstalledRan = true

        // Create both setup-run-system and restart-system-to-run-mode tasks as they
        // will run unconditionally. They will be chained together with optionally the
        // install-device hook task.
        setupRunSystem := m.state.NewTask("setup-run-system", i18n.G("Setup system for run mode"))
        restartSystem := m.state.NewTask("restart-system-to-run-mode", i18n.G("Ensure next boot to run mode"))

        prev := setupRunSystem
        tasks := []*state.Task{setupRunSystem}
        addTask := func(t *state.Task) </span><span class="cov0" title="0">{
                t.WaitFor(prev)
                tasks = append(tasks, t)
                prev = t
        }</span>

        // add the install-device hook before ensure-next-boot-to-run-mode if it
        // exists in the snap
        <span class="cov0" title="0">if hasInstallDeviceHook </span><span class="cov0" title="0">{
                // add the task that ensures ubuntu-save is available after the system
                // setup to the install-device hook
                addTask(m.state.NewTask("setup-ubuntu-save", i18n.G("Setup ubuntu-save snap folders")))

                installDevice := m.installDeviceHookTask(model)

                // reference used by snapctl reboot
                installDevice.Set("restart-task", restartSystem.ID())
                addTask(installDevice)
        }</span>

        <span class="cov0" title="0">addTask(restartSystem)

        chg := m.state.NewChange(installSystemChangeKind, i18n.G("Install the system"))
        chg.AddAll(state.NewTaskSet(tasks...))

        state.TagTimingsWithChange(perfTimings, chg)
        perfTimings.Save(m.state)

        return nil</span>
}

func (m *DeviceManager) ensureFactoryReset() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.ensureFactoryResetRan </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.SystemMode(SysHasModeenv) != "factory-reset" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureFactoryReset")

        perfTimings := timings.New(map[string]string{"ensure": "factory-reset"})

        model, err := m.Model()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: core device brand and model are set but there is no model assertion")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // We perform this check before setting ensureFactoryResetRan in
        // case this should fail. This should in theory not be possible as
        // the same type of check is made during install-mode.
        <span class="cov0" title="0">hasInstallDeviceHook, err := m.hasInstallDeviceHook(model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: %v", err)
        }</span>

        <span class="cov0" title="0">m.ensureFactoryResetRan = true

        // Create both factory-reset-run-system and restart-system-to-run-mode tasks as they
        // will run unconditionally. They will be chained together with optionally the
        // install-device hook task.
        factoryReset := m.state.NewTask("factory-reset-run-system", i18n.G("Perform factory reset of the system"))
        restartSystem := m.state.NewTask("restart-system-to-run-mode", i18n.G("Ensure next boot to run mode"))

        prev := factoryReset
        tasks := []*state.Task{factoryReset}
        addTask := func(t *state.Task) </span><span class="cov0" title="0">{
                t.WaitFor(prev)
                tasks = append(tasks, t)
                prev = t
        }</span>

        <span class="cov0" title="0">if hasInstallDeviceHook </span><span class="cov0" title="0">{
                installDevice := m.installDeviceHookTask(model)

                // reference used by snapctl reboot
                installDevice.Set("restart-task", restartSystem.ID())
                addTask(installDevice)
        }</span>

        <span class="cov0" title="0">addTask(restartSystem)

        chg := m.state.NewChange(factoryResetChangeKind, i18n.G("Perform factory reset"))
        chg.AddAll(state.NewTaskSet(tasks...))

        state.TagTimingsWithChange(perfTimings, chg)
        perfTimings.Save(m.state)

        return nil</span>
}

var timeNow = time.Now

// StartOfOperationTime returns the time when snapd started operating,
// and sets it in the state when called for the first time.
// The StartOfOperationTime time is seed-time if available,
// or current time otherwise.
func (m *DeviceManager) StartOfOperationTime() (time.Time, error) <span class="cov8" title="1">{
        var opTime time.Time
        if m.preseed </span><span class="cov0" title="0">{
                return opTime, fmt.Errorf("internal error: unexpected call to StartOfOperationTime in preseed mode")
        }</span>
        <span class="cov8" title="1">err := m.state.Get("start-of-operation-time", &amp;opTime)
        if err == nil </span><span class="cov0" title="0">{
                return opTime, nil
        }</span>
        <span class="cov8" title="1">if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return opTime, err
        }</span>

        // start-of-operation-time not set yet, use seed-time if available
        <span class="cov8" title="1">var seedTime time.Time
        err = m.state.Get("seed-time", &amp;seedTime)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return opTime, err
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov0" title="0">{
                opTime = seedTime
        }</span> else<span class="cov8" title="1"> {
                opTime = timeNow()
        }</span>
        <span class="cov8" title="1">m.state.Set("start-of-operation-time", opTime)
        return opTime, nil</span>
}

func markSeededInConfig(st *state.State) error <span class="cov8" title="1">{
        var seedDone bool
        tr := config.NewTransaction(st)
        if err := tr.Get("core", "seed.loaded", &amp;seedDone); err != nil &amp;&amp; !config.IsNoOption(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !seedDone </span><span class="cov8" title="1">{
                if err := tr.Set("core", "seed.loaded", true); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tr.Commit()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *DeviceManager) ensureSeedInConfig() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if !m.ensureSeedInConfigRan </span><span class="cov8" title="1">{
                // get global seeded option
                var seeded bool
                if err := m.state.Get("seeded", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !seeded </span><span class="cov8" title="1">{
                        // wait for ensure again, this is fine because
                        // doMarkSeeded will run "EnsureBefore(0)"
                        return nil
                }</span>
                <span class="cov8" title="1">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureSeedInConfig")

                // Sync seeding with the configuration state. We need to
                // do this here to ensure that old systems which did not
                // set the configuration on seeding get the configuration
                // update too.
                if err := markSeededInConfig(m.state); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.ensureSeedInConfigRan = true</span>
        } else<span class="cov8" title="1"> {
                logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureSeedInConfig")
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (m *DeviceManager) appendTriedRecoverySystem(label string) error <span class="cov0" title="0">{
        // state is locked by the caller

        var triedSystems []string
        if err := m.state.Get("tried-systems", &amp;triedSystems); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strutil.ListContains(triedSystems, label) </span><span class="cov0" title="0">{
                // system already recorded as tried?
                return nil
        }</span>
        <span class="cov0" title="0">triedSystems = append(triedSystems, label)
        m.state.Set("tried-systems", triedSystems)
        return nil</span>
}

func (m *DeviceManager) ensureTriedRecoverySystem() error <span class="cov8" title="1">{
        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>
        // nothing to do if not UC20 and run mode
        <span class="cov8" title="1">if m.SystemMode(SysHasModeenv) != "run" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">if m.ensureTriedRecoverySystemRan </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureTriedRecoverySystem")

        m.state.Lock()
        defer m.state.Unlock()

        deviceCtx, err := DeviceCtx(m.state, nil, nil)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">outcome, label, err := boot.InspectTryRecoverySystemOutcome(deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                if !boot.IsInconsistentRecoverySystemState(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                // boot variables state was inconsistent
                <span class="cov0" title="0">logger.Noticef("tried recovery system outcome error: %v", err)</span>
        }
        <span class="cov0" title="0">switch outcome </span>{
        case boot.TryRecoverySystemOutcomeSuccess:<span class="cov0" title="0">
                logger.Noticef("tried recovery system %q was successful", label)
                if err := m.appendTriedRecoverySystem(label); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case boot.TryRecoverySystemOutcomeFailure:<span class="cov0" title="0">
                logger.Noticef("tried recovery system %q failed", label)</span>
        case boot.TryRecoverySystemOutcomeInconsistent:<span class="cov0" title="0">
                logger.Noticef("inconsistent outcome of a tried recovery system")</span>
        case boot.TryRecoverySystemOutcomeNoneTried:<span class="cov0" title="0"></span>
                // no system was tried
        }
        <span class="cov0" title="0">if outcome != boot.TryRecoverySystemOutcomeNoneTried </span><span class="cov0" title="0">{
                if err := boot.ClearTryRecoverySystem(deviceCtx, label); err != nil </span><span class="cov0" title="0">{
                        logger.Noticef("cannot clear tried recovery system status: %v", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">m.ensureTriedRecoverySystemRan = true
        return nil</span>
}

func (m *DeviceManager) ensurePostFactoryReset() error <span class="cov8" title="1">{
        m.state.Lock()
        defer m.state.Unlock()

        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if m.ensurePostFactoryResetRan </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">mode := m.SystemMode(SysHasModeenv)
        if mode != "run" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">var seeded bool
        err := m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensurePostFactoryReset")

        m.ensurePostFactoryResetRan = true

        factoryResetMarker := filepath.Join(dirs.SnapDeviceDir, "factory-reset")
        if !osutil.FileExists(factoryResetMarker) </span><span class="cov0" title="0">{
                // marker is gone already
                return nil
        }</span>

        <span class="cov0" title="0">encrypted := true
        // XXX have a helper somewhere for this?
        if !osutil.FileExists(filepath.Join(dirs.SnapFDEDir, "marker")) </span><span class="cov0" title="0">{
                encrypted = false
        }</span>

        // verify the marker
        <span class="cov0" title="0">if err := verifyFactoryResetMarkerInRun(factoryResetMarker, encrypted); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot verify factory reset marker: %v", err)
        }</span>

        <span class="cov0" title="0">if encrypted </span><span class="cov0" title="0">{
                if err := rotateSaveKeyAndDeleteOldKeys(boot.InitramfsUbuntuSaveDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot remove old encryption keys: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return os.Remove(factoryResetMarker)</span>
}

// ensureExpiredUsersRemoved is periodically called as a part of Ensure()
// to remove expired users from the system.
func (m *DeviceManager) ensureExpiredUsersRemoved() error <span class="cov8" title="1">{
        st := m.state
        st.Lock()
        defer st.Unlock()

        // So far this is only set to be done in run mode, it might not
        // make any sense to do in it any other mode.
        mode := m.SystemMode(SysAny)
        if mode != "run" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Expect the system to be seeded, otherwise we ignore this.
        <span class="cov8" title="1">var seeded bool
        if err := st.Get("seeded", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !seeded </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">users, err := auth.Users(st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logger.Trace("ensure", "manager", "DeviceManager", "func", "ensureExpiredUsersRemoved")

        for _, user := range users </span><span class="cov0" title="0">{
                if !user.HasExpired() </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Force the removal of the user as it's possible to block this expiration
                // otherwise by the user having left a process or service running.
                <span class="cov0" title="0">if _, err := RemoveUser(st, user.Username, &amp;RemoveUserOptions{Force: true}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type ensureError struct {
        errs []error
}

func (e *ensureError) Error() string <span class="cov0" title="0">{
        if len(e.errs) == 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("devicemgr: %v", e.errs[0])
        }</span>
        <span class="cov0" title="0">parts := []string{"devicemgr:"}
        for _, e := range e.errs </span><span class="cov0" title="0">{
                parts = append(parts, e.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, "\n - ")</span>
}

// no \n allowed in warnings
var seedFailureFmt = `seeding failed with: %v. This indicates an error in your distribution, please see https://forum.snapcraft.io/t/16341 for more information.`

// Ensure implements StateManager.Ensure.
func (m *DeviceManager) Ensure() error <span class="cov8" title="1">{
        var errs []error

        if err := m.ensureSeeded(); err != nil </span><span class="cov0" title="0">{
                m.state.Lock()
                m.state.Warnf(seedFailureFmt, err)
                m.state.Unlock()
                errs = append(errs, fmt.Errorf("cannot seed: %v", err))
        }</span>

        <span class="cov8" title="1">if !m.preseed </span><span class="cov8" title="1">{
                if err := m.ensureAutoImportAssertions(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                // code below should not need the early loaded device seed
                // optimistically forget the earlyDeviceSeed here
                // to free the corresponding memory usage
                <span class="cov8" title="1">m.earlyDeviceSeed = nil

                if err := m.ensureCloudInitRestricted(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureOperational(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureBootOk(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureSeedInConfig(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureInstalled(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureTriedRecoverySystem(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureFactoryReset(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensurePostFactoryReset(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureSerialBoundSystemUserAssertionsProcessed(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if err := m.ensureExpiredUsersRemoved(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;ensureError{errs}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ResetToPostBootState is only useful for integration testing.
func (m *DeviceManager) ResetToPostBootState() <span class="cov0" title="0">{
        osutil.MustBeTestBinary("ResetToPostBootState can only be called from tests")
        m.bootOkRan = false
        m.bootRevisionsUpdated = false
        m.ensureTriedRecoverySystemRan = false
}</span>

var errNoSaveSupport = errors.New("no save directory before UC20")

// withSaveDir invokes a function making sure save dir is available.
// Under UC16/18 it returns errNoSaveSupport
// For UC20 it also checks that ubuntu-save is available/mounted.
func (m *DeviceManager) withSaveDir(f func() error) error <span class="cov8" title="1">{
        // we use the model to check whether this is a UC20 device
        model, err := m.Model()
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot access save dir before a model is set")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if model.Grade() == asserts.ModelGradeUnset </span><span class="cov8" title="1">{
                return errNoSaveSupport
        }</span>
        // at this point we need save available
        <span class="cov0" title="0">if !m.saveAvailable </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: save dir is unavailable")
        }</span>

        <span class="cov0" title="0">return f()</span>
}

// withSaveAssertDB invokes a function making the save device assertion
// backup database available to it.
// Under UC16/18 it returns errNoSaveSupport
// For UC20 it also checks that ubuntu-save is available/mounted.
func (m *DeviceManager) withSaveAssertDB(f func(*asserts.Database) error) error <span class="cov8" title="1">{
        return m.withSaveDir(func() error </span><span class="cov0" title="0">{
                // open an ancillary backup assertion database in save/device
                assertDB, err := sysdb.OpenAt(dirs.SnapDeviceSaveDir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return f(assertDB)</span>
        })
}

// withKeypairMgr invokes a function making the device KeypairManager
// available to it.
// It uses the right location for the manager depending on UC16/18 vs 20,
// the latter uses ubuntu-save.
// For UC20 it also checks that ubuntu-save is available/mounted.
func (m *DeviceManager) withKeypairMgr(f func(asserts.KeypairManager) error) error <span class="cov8" title="1">{
        // we use the model to check whether this is a UC20 device
        // TODO: during a theoretical UC18-&gt;20 remodel the location of
        // keypair manager keys would move, we will need dedicated code
        // to deal with that, this code typically will return the old location
        // until a restart
        model, err := m.Model()
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot access device keypair manager before a model is set")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">underSave := false
        if model.Grade() != asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                // on UC20 the keys are kept under the save dir
                underSave = true
        }</span>
        <span class="cov8" title="1">where := dirs.SnapDeviceDir
        if underSave </span><span class="cov0" title="0">{
                // at this point we need save available
                if !m.saveAvailable </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: cannot access device keypair manager if ubuntu-save is unavailable")
                }</span>
                <span class="cov0" title="0">where = dirs.SnapDeviceSaveDir</span>
        }
        <span class="cov8" title="1">keypairMgr := m.cachedKeypairMgr
        if keypairMgr == nil </span><span class="cov8" title="1">{
                var err error
                keypairMgr, err = asserts.OpenFSKeypairManager(where)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m.cachedKeypairMgr = keypairMgr</span>
        }
        <span class="cov8" title="1">return f(keypairMgr)</span>
}

func (m *DeviceManager) keyPair() (asserts.PrivateKey, error) <span class="cov8" title="1">{
        device, err := m.device()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if device.KeyID == "" </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>

        <span class="cov8" title="1">var privKey asserts.PrivateKey
        err = m.withKeypairMgr(func(keypairMgr asserts.KeypairManager) (err error) </span><span class="cov8" title="1">{
                privKey, err = keypairMgr.Get(device.KeyID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot read device key pair: %v", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return privKey, nil</span>
}

// SignConfdbControl signs a confdb-control assertion using the device's key as it needs to be attested by the device.
func (m *DeviceManager) SignConfdbControl(groups []any, revision int) (*asserts.ConfdbControl, error) <span class="cov0" title="0">{
        serial, err := m.Serial()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign confdb-control without a serial")
        }</span>

        <span class="cov0" title="0">privKey, err := m.keyPair()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign confdb-control without device key")
        }</span>

        <span class="cov0" title="0">a, err := asserts.SignWithoutAuthority(asserts.ConfdbControlType, map[string]any{
                "brand-id": serial.BrandID(),
                "model":    serial.Model(),
                "serial":   serial.Serial(),
                "revision": strconv.Itoa(revision),
                "groups":   groups,
        }, nil, privKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a.(*asserts.ConfdbControl), nil</span>
}

// Registered returns a channel that is closed when the device is known to have been registered.
func (m *DeviceManager) Registered() &lt;-chan struct{} <span class="cov0" title="0">{
        return m.reg
}</span>

type UnregisterOptions struct {
        NoRegistrationUntilReboot bool
}

// Unregister unregisters the device forgetting its serial
// plus the additional behavior described by the UnregisterOptions
func (m *DeviceManager) Unregister(opts *UnregisterOptions) error <span class="cov0" title="0">{
        device, err := m.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !release.OnClassic || (device.Brand != "generic" &amp;&amp; device.Brand != "canonical") </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot currently unregister device if not classic or model brand is not generic or canonical")
        }</span>

        <span class="cov0" title="0">if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;UnregisterOptions{}
        }</span>
        <span class="cov0" title="0">if opts.NoRegistrationUntilReboot </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dirs.SnapRunDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := os.WriteFile(filepath.Join(dirs.SnapRunDir, "noregister"), nil, 0644); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">oldKeyID := device.KeyID
        device.Serial = ""
        device.KeyID = ""
        device.SessionMacaroon = ""
        if err := m.setDevice(device); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // commit forgetting serial and key
        <span class="cov0" title="0">m.state.Unlock()
        m.state.Lock()
        // delete the device key
        err = m.withKeypairMgr(func(keypairMgr asserts.KeypairManager) error </span><span class="cov0" title="0">{
                err := keypairMgr.Delete(oldKeyID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot delete device key pair: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">m.lastBecomeOperationalAttempt = time.Time{}
        m.becomeOperationalBackoff = 0
        return err</span>
}

// device returns current device state.
func (m *DeviceManager) device() (*auth.DeviceState, error) <span class="cov8" title="1">{
        return internal.Device(m.state)
}</span>

// setDevice sets the device details in the state.
func (m *DeviceManager) setDevice(device *auth.DeviceState) error <span class="cov8" title="1">{
        return internal.SetDevice(m.state, device)
}</span>

// Model returns the device model assertion.
func (m *DeviceManager) Model() (*asserts.Model, error) <span class="cov8" title="1">{
        return findModel(m.state)
}</span>

// Serial returns the device serial assertion.
func (m *DeviceManager) Serial() (*asserts.Serial, error) <span class="cov0" title="0">{
        return findSerial(m.state, nil)
}</span>

// ConfdbControl returns the device's confdb-control assertion.
func (m *DeviceManager) ConfdbControl() (*asserts.ConfdbControl, error) <span class="cov0" title="0">{
        serial, err := m.Serial()
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrNoDeviceIdentityYet
        }</span>

        <span class="cov0" title="0">db := assertstate.DB(m.state)
        a, err := db.Find(asserts.ConfdbControlType, map[string]string{
                "brand-id": serial.BrandID(),
                "model":    serial.Model(),
                "serial":   serial.Serial(),
        })
        if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cc := a.(*asserts.ConfdbControl)
        key := serial.DeviceKey()
        if key.ID() != cc.SignKeyID() </span><span class="cov0" title="0">{
                return nil, errors.New("confdb-control's signing key doesn't match the device key")
        }</span>

        <span class="cov0" title="0">return cc, nil</span>
}

type SystemModeInfo struct {
        Mode              string
        HasModeenv        bool
        Seeded            bool
        BootFlags         []string
        HostDataLocations []string
}

// SystemModeInfo returns details about the current system mode the device is in.
func (m *DeviceManager) SystemModeInfo() (*SystemModeInfo, error) <span class="cov0" title="0">{
        deviceCtx, err := DeviceCtx(m.state, nil, nil)
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot report system mode information before device model is acknowledged")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var seeded bool
        err = m.state.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mode := deviceCtx.SystemMode()
        smi := SystemModeInfo{
                Mode:       mode,
                HasModeenv: deviceCtx.HasModeenv(),
                Seeded:     seeded,
        }
        if smi.HasModeenv </span><span class="cov0" title="0">{
                bootFlags, err := boot.BootFlags(deviceCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">smi.BootFlags = bootFlags

                hostDataLocs, err := boot.HostUbuntuDataForMode(mode, deviceCtx.Model())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">smi.HostDataLocations = hostDataLocs</span>
        }
        <span class="cov0" title="0">return &amp;smi, nil</span>
}

type SystemAction struct {
        Title string
        Mode  string
}

type System struct {
        // Current is true when the system running now was installed from that
        // seed
        Current bool
        // Label of the seed system
        Label string
        // Model assertion of the system
        Model *asserts.Model
        // Brand information
        Brand *asserts.Account
        // Actions available for this system
        Actions []SystemAction
        // DefaultRecoverySystem is true when the system is the default recovery
        // system.
        DefaultRecoverySystem bool
        // OptionalContainers is a set of snaps and components that are optional in
        // the system's model, but are available to be installed when installing this
        // system.
        OptionalContainers OptionalContainers
}

var defaultSystemActions = []SystemAction{
        {Title: "Install", Mode: "install"},
        {Title: "Recover", Mode: "recover"},
        {Title: "Factory reset", Mode: "factory-reset"},
}
var currentSystemActions = []SystemAction{
        {Title: "Reinstall", Mode: "install"},
        {Title: "Recover", Mode: "recover"},
        {Title: "Factory reset", Mode: "factory-reset"},
        {Title: "Run normally", Mode: "run"},
}
var recoverSystemActions = []SystemAction{
        {Title: "Reinstall", Mode: "install"},
        {Title: "Factory reset", Mode: "factory-reset"},
        {Title: "Run normally", Mode: "run"},
}

var ErrNoSystems = errors.New("no systems seeds")

// Systems list the available recovery/seeding systems. Returns the list of
// systems, ErrNoSystems when no systems seeds were found or other error.
func (m *DeviceManager) Systems() ([]*System, error) <span class="cov0" title="0">{
        m.state.Lock()
        defer m.state.Unlock()

        // currently we hold the lock for the entire duration of this method. this
        // should be fine for now, since we aren't calling LoadMeta on any of the
        // seeds that m.systems operates on. if that changes, when we might need to
        // rethink the locking strategy here.
        return m.systems()
}</span>

func (m *DeviceManager) systems() ([]*System, error) <span class="cov0" title="0">{
        systemMode := m.SystemMode(SysAny)

        // it's tough luck when we cannot determine the current system seed
        currentSys, _ := currentSystemForMode(m.state, systemMode)

        systemLabels, err := filepath.Glob(filepath.Join(dirs.SnapSeedDir, "systems", "*"))
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot list available systems: %v", err)
        }</span>
        <span class="cov0" title="0">if len(systemLabels) == 0 </span><span class="cov0" title="0">{
                // maybe not a UC20 system
                return nil, ErrNoSystems
        }</span>

        <span class="cov0" title="0">defaultRecoverySystem, err := m.defaultRecoverySystem()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var systems []*System
        for _, fpLabel := range systemLabels </span><span class="cov0" title="0">{
                label := filepath.Base(fpLabel)
                system, err := systemFromSeed(label, currentSys, defaultRecoverySystem)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO:UC20 add a Broken field to the seed system like we do for
                        // snap.Info
                        logger.Noticef("cannot load system %q seed: %v", label, err)
                        continue</span>
                }
                <span class="cov0" title="0">systems = append(systems, system)</span>
        }
        <span class="cov0" title="0">return systems, nil</span>
}

// SystemAndGadgetAndEncryptionInfo resolves the target system by
// label and returns the system details (including its model assertion), the
// gadget details and encryption support information.
//
// This is a wrapper around systemAndGadgetAndEncryptionInfoWithAction that
// performs an encryption availability check without any action.
//
// Cache semantics:
//   - With encInfoFromCache set to true: returns cached EncryptionSupportInfo when
//     available, skipping the expensive availability check.
//   - Otherwise: computes fresh EncryptionSupportInfo and refreshes the cache on
//     success.
//
// Errors are returned if the system cannot be resolved, gadget info cannot be
// read/validated, or encryption support evaluation fails.
func (m *DeviceManager) SystemAndGadgetAndEncryptionInfo(
        wantedSystemLabel string,
        encInfoFromCache bool,
) (*System, *gadget.Info, *install.EncryptionSupportInfo, error) <span class="cov0" title="0">{
        var checkAction *secboot.PreinstallAction = nil
        return m.systemAndGadgetAndEncryptionInfoWithAction(wantedSystemLabel, checkAction, encInfoFromCache)
}</span>

// ApplyActionOnSystemAndGadgetAndEncryptionInfo resolves the target system by
// label and evaluates encryption support after applying the provided action. It
// returns the system details (including its model assertion), the gadget
// details and encryption support information.
//
// Action and cache semantics:
//   - Always computes fresh EncryptionSupportInfo (encInfoFromCache is false).
//   - Requires EncryptionSupportInfo containing a CheckContext to exist in
//     cache for the provided label.
//
// Errors are returned if the system cannot be resolved, gadget info cannot be
// read/validated, or encryption support evaluation fails.
func (m *DeviceManager) ApplyActionOnSystemAndGadgetAndEncryptionInfo(
        wantedSystemLabel string,
        checkAction *secboot.PreinstallAction,
) (*System, *gadget.Info, *install.EncryptionSupportInfo, error) <span class="cov0" title="0">{
        if checkAction == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, errors.New("cannot apply empty action")
        }</span>
        <span class="cov0" title="0">const encInfoFromCache = false
        return m.systemAndGadgetAndEncryptionInfoWithAction(wantedSystemLabel, checkAction, encInfoFromCache)</span>
}

// systemAndGadgetAndEncryptionInfoWithAction resolves the target system by
// label and returns the system details (including its model assertion), the
// gadget details and encryption support information.
//
// Action and cache semantics:
//   - With a checkAction: Computes fresh EncryptionSupportInfo. Requires
//     EncryptionSupportInfo containing a CheckContext to exist in cache for the
//     provided label. It is incompatible with encInfoFromCache set to true.
//   - Without a checkAction and encInfoFromCache set to true: return the cached
//     EncryptionSupportInfo when available, skipping the expensive availability
//     check.
//   - Otherwise: computes fresh EncryptionSupportInfo and refreshes the cache on
//     success.
//
// Errors are returned if the system cannot be resolved, gadget info cannot be
// read/validated, or encryption support evaluation fails. See
// encryptionSupportInfoUnlocked for the exact cache/CheckContext behavior.
func (m *DeviceManager) systemAndGadgetAndEncryptionInfoWithAction(
        wantedSystemLabel string,
        checkAction *secboot.PreinstallAction,
        encInfoFromCache bool,
) (*System, *gadget.Info, *install.EncryptionSupportInfo, error) <span class="cov0" title="0">{
        // TODO check that the system is not a classic boot one when the
        // installer is not anymore.

        // System information
        systemAndSnaps, err := m.loadSystemAndEssentialSnaps(wantedSystemLabel, []snap.Type{snap.TypeSnapd, snap.TypeKernel, snap.TypeGadget}, seed.AllModes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Gadget information
        <span class="cov0" title="0">snapf, err := snapfile.Open(systemAndSnaps.SeedSnapsByType[snap.TypeGadget].Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("cannot open gadget snap: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetInfo, err := gadget.ReadInfoFromSnapFileNoValidate(snapf, systemAndSnaps.Model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("reading gadget information: %v", err)
        }</span>

        // Encryption details
        <span class="cov0" title="0">encInfo, err := m.encryptionSupportInfoUnlocked(wantedSystemLabel, install.EncryptionConstraints{
                Model:         systemAndSnaps.Model,
                Kernel:        systemAndSnaps.InfosByType[snap.TypeKernel],
                Gadget:        gadgetInfo,
                TPMMode:       secboot.TPMProvisionFull,
                SnapdVersions: systemAndSnaps.SystemSnapdVersions,
                CheckAction:   checkAction,
        }, encInfoFromCache)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Make sure gadget is valid for model and available encryption
        <span class="cov0" title="0">opts := &amp;gadget.ValidationConstraints{
                EncryptedData: encInfo.StorageSafety == asserts.StorageSafetyEncrypted,
        }
        if err := gadget.Validate(gadgetInfo, systemAndSnaps.Model, opts); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("cannot validate gadget.yaml: %v", err)
        }</span>

        <span class="cov0" title="0">return systemAndSnaps.System, gadgetInfo, encInfo, err</span>
}

type systemAndEssentialSnaps struct {
        *System
        Seed                seed.Seed
        SystemSnapdVersions install.SystemSnapdVersions
        InfosByType         map[snap.Type]*snap.Info
        CompsByType         map[snap.Type][]install.ComponentSeedInfo
        SeedSnapsByType     map[snap.Type]*seed.Snap
}

// DefaultRecoverySystem returns the default recovery system, if there is one.
// state.ErrNoState is returned if a default recovery system has not been set.
func (m *DeviceManager) DefaultRecoverySystem() (*DefaultRecoverySystem, error) <span class="cov0" title="0">{
        m.state.Lock()
        defer m.state.Unlock()

        return m.defaultRecoverySystem()
}</span>

func (m *DeviceManager) defaultRecoverySystem() (*DefaultRecoverySystem, error) <span class="cov0" title="0">{
        var defaultSystem DefaultRecoverySystem
        if err := m.state.Get("default-recovery-system", &amp;defaultSystem); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;defaultSystem, nil</span>
}

// loadSystemAndEssentialSnaps loads information for the given label, which
// includes system, gadget information, gadget and kernel snaps info, and
// gadget and kernel seed snap info. In some cases we only want the components
// of the essential snaps for a given mode.
// TODO: make this method optionally return the system seed, since it might not
// always be needed, and it is quite large.
func (m *DeviceManager) loadSystemAndEssentialSnaps(wantedSystemLabel string, types []snap.Type, modeForComps string) (*systemAndEssentialSnaps, error) <span class="cov0" title="0">{
        // get current system as input for loadSeedAndSystem()
        systemMode := m.SystemMode(SysAny)
        var currentSys *currentSystem
        func() </span><span class="cov0" title="0">{
                m.state.Lock()
                defer m.state.Unlock()
                currentSys, _ = currentSystemForMode(m.state, systemMode)
        }</span>()

        <span class="cov0" title="0">defaultRecoverySystem, err := m.DefaultRecoverySystem()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s, sys, err := loadSeedAndSystem(wantedSystemLabel, currentSys, defaultRecoverySystem)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. get the gadget volumes for the given system-label
        <span class="cov0" title="0">perf := &amp;timings.Timings{}
        if err := s.LoadEssentialMeta(types, perf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot load essential snaps metadata: %v", err)
        }</span>
        // EssentialSnaps is always ordered, see asserts.Model.EssentialSnaps:
        // "snapd, kernel, boot base, gadget." and snaps not loaded above
        // like "snapd" will be skipped and not part of the EssentialSnaps list
        //
        <span class="cov0" title="0">snapInfos := make(map[snap.Type]*snap.Info)
        compInfos := make(map[snap.Type][]install.ComponentSeedInfo)
        seedSnaps := make(map[snap.Type]*seed.Snap)
        systemSnapdVersions := install.SystemSnapdVersions{}
        for _, seedSnap := range s.EssentialSnaps() </span><span class="cov0" title="0">{
                typ := seedSnap.EssentialType
                if seedSnap.Path == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("internal error: cannot get snap path for %s", typ)
                }</span>
                <span class="cov0" title="0">snapf, err := snapfile.Open(seedSnap.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot open snap from %q: %v", seedSnap.Path, err)
                }</span>
                <span class="cov0" title="0">snapInfo, err := snap.ReadInfoFromSnapFile(snapf, seedSnap.SideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if snapInfo.SnapType != typ </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot use snap info, expected %s but got %s", typ, snapInfo.SnapType)
                }</span>
                // Read components in the seed too, for the mode we are interested in
                <span class="cov0" title="0">snapForMode, err := s.ModeSnap(seedSnap.SnapName(), modeForComps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("internal error while retrieving %s for %s mode: %v",
                                seedSnap.SnapName(), modeForComps, err)
                }</span>
                <span class="cov0" title="0">var compInfosForType []install.ComponentSeedInfo
                if len(snapForMode.Components) &gt; 0 </span><span class="cov0" title="0">{
                        compInfosForType = make([]install.ComponentSeedInfo, 0, len(snapForMode.Components))
                        for _, sc := range snapForMode.Components </span><span class="cov0" title="0">{
                                seedComp := sc
                                compf, err := snapfile.Open(seedComp.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("cannot open snap from %q: %v", snapForMode.Path, err)
                                }</span>
                                <span class="cov0" title="0">compInfo, err := snap.ReadComponentInfoFromContainer(
                                        compf, snapInfo, &amp;seedComp.CompSideInfo)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">compInfosForType = append(compInfosForType, install.ComponentSeedInfo{
                                        Info: compInfo,
                                        Seed: &amp;seedComp,
                                })</span>
                        }
                }
                <span class="cov0" title="0">if typ == snap.TypeSnapd || typ == snap.TypeKernel </span><span class="cov0" title="0">{
                        snapdVersion, _, err := snap.SnapdInfoFromSnapFile(snapf, typ)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">switch typ </span>{
                        case snap.TypeSnapd:<span class="cov0" title="0">
                                systemSnapdVersions.SnapdVersion = snapdVersion</span>
                        case snap.TypeKernel:<span class="cov0" title="0">
                                systemSnapdVersions.SnapdInitramfsVersion = snapdVersion</span>
                        }
                }
                <span class="cov0" title="0">seedSnaps[typ] = snapForMode
                snapInfos[typ] = snapInfo
                compInfos[typ] = compInfosForType</span>
        }
        <span class="cov0" title="0">if len(snapInfos) != len(types) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: retrieved snap infos (%d) does not match number of types (%d)", len(snapInfos), len(types))
        }</span>

        <span class="cov0" title="0">return &amp;systemAndEssentialSnaps{
                System:              sys,
                Seed:                s,
                SystemSnapdVersions: systemSnapdVersions,
                InfosByType:         snapInfos,
                CompsByType:         compInfos,
                SeedSnapsByType:     seedSnaps,
        }, nil</span>
}

var ErrUnsupportedAction = errors.New("unsupported action")

// Reboot triggers a reboot into the given systemLabel and mode.
//
// When called without a systemLabel and without a mode it will just
// trigger a regular reboot.
//
// When called without a systemLabel but with a mode it will use
// the current system to enter the given mode.
//
// Note that "recover" and "run" modes are only available for the
// current system.
func (m *DeviceManager) Reboot(systemLabel, mode string) error <span class="cov0" title="0">{
        rebootCurrent := func() </span><span class="cov0" title="0">{
                logger.Noticef("rebooting system")
                restart.Request(m.state, restart.RestartSystemNow, nil)
        }</span>

        // most simple case: just reboot
        <span class="cov0" title="0">if systemLabel == "" &amp;&amp; mode == "" </span><span class="cov0" title="0">{
                m.state.Lock()
                defer m.state.Unlock()

                rebootCurrent()
                return nil
        }</span>

        // no systemLabel means we need to fall back to either the default recovery
        // system, or the current system, depending on the requested mode
        <span class="cov0" title="0">if systemLabel == "" </span><span class="cov0" title="0">{
                defaultLabel, err := defaultSystemLabel(m.state, m, mode)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">systemLabel = defaultLabel</span>
        }

        <span class="cov0" title="0">switched := func(systemLabel string, sysAction *SystemAction) </span><span class="cov0" title="0">{
                logger.Noticef("rebooting into system %q in %q mode", systemLabel, sysAction.Mode)
                restart.Request(m.state, restart.RestartSystemNow, nil)
        }</span>
        // even if we are already in the right mode we restart here by
        // passing rebootCurrent as this is what the user requested
        <span class="cov0" title="0">return m.switchToSystemAndMode(systemLabel, mode, rebootCurrent, switched)</span>
}

func defaultSystemLabel(st *state.State, manager *DeviceManager, mode string) (string, error) <span class="cov0" title="0">{
        st.Lock()
        defer st.Unlock()

        switch mode </span>{
        case "recover", "factory-reset", "install":<span class="cov0" title="0">
                defaultRecoverySystem, err := manager.defaultRecoverySystem()
                if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">if defaultRecoverySystem != nil </span><span class="cov0" title="0">{
                        return defaultRecoverySystem.System, nil
                }</span>

                // intentionally fall through here, since we fall back to using the most
                // recently seeded system if there isn't a default recovery system
                // explicitly set
                <span class="cov0" title="0">fallthrough</span>
        case "run":<span class="cov0" title="0">
                systemMode := manager.SystemMode(SysAny)
                currentSys, err := currentSystemForMode(st, systemMode)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("cannot get current system: %v", err)
                }</span>

                <span class="cov0" title="0">return currentSys.System, nil</span>
        default:<span class="cov0" title="0">
                return "", ErrUnsupportedAction</span>
        }
}

// RequestSystemAction requests the provided system to be run in a
// given mode as specified by action.
// A system reboot will be requested when the request can be
// successfully carried out.
func (m *DeviceManager) RequestSystemAction(systemLabel string, action SystemAction) error <span class="cov0" title="0">{
        if systemLabel == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: system label is unset")
        }</span>

        <span class="cov0" title="0">nop := func() </span>{<span class="cov0" title="0">}</span>
        <span class="cov0" title="0">switched := func(systemLabel string, sysAction *SystemAction) </span><span class="cov0" title="0">{
                logger.Noticef("restarting into system %q for action %q", systemLabel, sysAction.Title)
                restart.Request(m.state, restart.RestartSystemNow, nil)
        }</span>
        // we do nothing (nop) if the mode and system are the same
        <span class="cov0" title="0">return m.switchToSystemAndMode(systemLabel, action.Mode, nop, switched)</span>
}

// switchToSystemAndMode switches to given systemLabel and mode.
// If the systemLabel and mode are the same as current, it calls
// sameSystemAndMode. If successful otherwise it calls switched. Both
// are called with the state lock held.
func (m *DeviceManager) switchToSystemAndMode(systemLabel, mode string, sameSystemAndMode func(), switched func(systemLabel string, sysAction *SystemAction)) error <span class="cov0" title="0">{
        if err := checkSystemRequestConflict(m.state, systemLabel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">systemMode := m.SystemMode(SysAny)
        // ignore the error to be robust in scenarios that
        // dont' stricly require currentSys to be carried through.
        // make sure that currentSys == nil does not break
        // the code below!
        // TODO: should we log the error?
        m.state.Lock()
        currentSys, _ := currentSystemForMode(m.state, systemMode)
        m.state.Unlock()

        defaultRecoverySystem, err := m.DefaultRecoverySystem()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">systemSeedDir := filepath.Join(dirs.SnapSeedDir, "systems", systemLabel)
        if _, err := os.Stat(systemSeedDir); err != nil </span><span class="cov0" title="0">{
                // XXX: should we wrap this instead return a naked stat error?
                return err
        }</span>
        <span class="cov0" title="0">system, err := systemFromSeed(systemLabel, currentSys, defaultRecoverySystem)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot load seed system: %v", err)
        }</span>

        <span class="cov0" title="0">var sysAction *SystemAction
        for _, act := range system.Actions </span><span class="cov0" title="0">{
                if mode == act.Mode </span><span class="cov0" title="0">{
                        sysAction = &amp;act
                        break</span>
                }
        }
        <span class="cov0" title="0">if sysAction == nil </span><span class="cov0" title="0">{
                // XXX: provide more context here like what mode was requested?
                return ErrUnsupportedAction
        }</span>

        // XXX: requested mode is valid; only current system has 'run' and
        // recover 'actions'

        <span class="cov0" title="0">switch systemMode </span>{
        case "recover", "run":<span class="cov0" title="0">
                // if going from recover to recover or from run to run and the systems
                // are the same do nothing
                if systemMode == sysAction.Mode &amp;&amp; currentSys != nil &amp;&amp; systemLabel == currentSys.System </span><span class="cov0" title="0">{
                        m.state.Lock()
                        defer m.state.Unlock()
                        sameSystemAndMode()
                        return nil
                }</span>
        case "install", "factory-reset":<span class="cov0" title="0">
                // requesting system actions in install or factory-reset modes
                // does not make sense atm
                //
                // TODO:UC20: maybe factory hooks will be able to something like
                // this?
                return ErrUnsupportedAction</span>
        default:<span class="cov0" title="0">
                // probably test device manager mocking problem, or also potentially
                // missing modeenv
                return fmt.Errorf("internal error: unexpected manager system mode %q", systemMode)</span>
        }

        <span class="cov0" title="0">m.state.Lock()
        defer m.state.Unlock()

        deviceCtx, err := DeviceCtx(m.state, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := boot.SetRecoveryBootSystemAndMode(deviceCtx, systemLabel, mode); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set device to boot into system %q in mode %q: %v", systemLabel, mode, err)
        }</span>

        <span class="cov0" title="0">switched(systemLabel, sysAction)
        return nil</span>
}

// implement storecontext.Backend

type storeContextBackend struct {
        *DeviceManager
}

func (scb storeContextBackend) Device() (*auth.DeviceState, error) <span class="cov0" title="0">{
        return scb.DeviceManager.device()
}</span>

func (scb storeContextBackend) SetDevice(device *auth.DeviceState) error <span class="cov0" title="0">{
        return scb.DeviceManager.setDevice(device)
}</span>

func (scb storeContextBackend) ProxyStore() (*asserts.Store, error) <span class="cov0" title="0">{
        st := scb.DeviceManager.state
        return proxyStore(st, config.NewTransaction(st))
}</span>

func (scb storeContextBackend) StoreOffline() (bool, error) <span class="cov0" title="0">{
        tr := config.NewTransaction(scb.state)

        var access string
        if err := tr.GetMaybe("core", "store.access", &amp;access); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if access == "" </span><span class="cov0" title="0">{
                return false, state.ErrNoState
        }</span>

        <span class="cov0" title="0">return access == "offline", nil</span>
}

// SignDeviceSessionRequest produces a signed device-session-request with for given serial assertion and nonce.
func (scb storeContextBackend) SignDeviceSessionRequest(serial *asserts.Serial, nonce string) (*asserts.DeviceSessionRequest, error) <span class="cov0" title="0">{
        if serial == nil </span><span class="cov0" title="0">{
                // shouldn't happen, but be safe
                return nil, fmt.Errorf("internal error: cannot sign a session request without a serial")
        }</span>

        <span class="cov0" title="0">privKey, err := scb.DeviceManager.keyPair()
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: inconsistent state with serial but no device key")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">a, err := asserts.SignWithoutAuthority(asserts.DeviceSessionRequestType, map[string]any{
                "brand-id":  serial.BrandID(),
                "model":     serial.Model(),
                "serial":    serial.Serial(),
                "nonce":     nonce,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }, nil, privKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a.(*asserts.DeviceSessionRequest), nil</span>
}

func (m *DeviceManager) StoreContextBackend() storecontext.Backend <span class="cov0" title="0">{
        return storeContextBackend{m}
}</span>

var timeutilIsNTPSynchronized = timeutil.IsNTPSynchronized

func (m *DeviceManager) ntpSyncedOrWaitedLongerThan(maxWait time.Duration) bool <span class="cov0" title="0">{
        if m.ntpSyncedOrTimedOut </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if time.Now().After(startTime.Add(maxWait)) </span><span class="cov0" title="0">{
                logger.Noticef("no NTP sync after %v, trying auto-refresh anyway", maxWait)
                m.ntpSyncedOrTimedOut = true
                return true
        }</span>

        <span class="cov0" title="0">var err error
        m.ntpSyncedOrTimedOut, err = timeutilIsNTPSynchronized()
        if errors.As(err, &amp;timeutil.NoTimedate1Error{}) </span><span class="cov0" title="0">{
                // no timedate1 dbus service, no need to wait for it
                m.ntpSyncedOrTimedOut = true
                return true
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Debugf("cannot check if ntp is syncronized: %v", err)
        }</span>

        <span class="cov0" title="0">return m.ntpSyncedOrTimedOut</span>
}

func (m *DeviceManager) hookKeyProtectorFactory(kernelInfo *snap.Info) (secboot.KeyProtectorFactory, error) <span class="cov0" title="0">{
        // state must be locked
        st := m.state

        deviceCtx, err := DeviceCtx(st, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get device context: %v", err)
        }</span>

        <span class="cov0" title="0">if kernelInfo == nil </span><span class="cov0" title="0">{
                var err error
                kernelInfo, err = snapstate.KernelInfo(st, deviceCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot get kernel info: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := kernelInfo.Hooks["fde-setup"]; ok </span><span class="cov0" title="0">{
                return secboot.FDESetupHookKeyProtectorFactory(m.runFDESetupHook), nil
        }</span>

        <span class="cov0" title="0">if secboot.FDEOpteeTAPresent() </span><span class="cov0" title="0">{
                return secboot.OPTEEKeyProtectorFactory(), nil
        }</span>

        <span class="cov0" title="0">return nil, secboot.ErrNoKeyProtector</span>
}

func (m *DeviceManager) runFDESetupHook(req *fde.SetupRequest) ([]byte, error) <span class="cov0" title="0">{
        // TODO:UC20: when this runs on refresh we need to be very careful
        // that we never run this when the kernel is not fully configured
        // i.e. when there are no security profiles for the hook

        // state must be locked
        st := m.state

        deviceCtx, err := DeviceCtx(st, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get device context to run fde-setup hook: %v", err)
        }</span>
        <span class="cov0" title="0">kernelInfo, err := snapstate.KernelInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get kernel info to run fde-setup hook: %v", err)
        }</span>
        <span class="cov0" title="0">hooksup := &amp;hookstate.HookSetup{
                Snap:     kernelInfo.InstanceName(),
                Revision: kernelInfo.Revision,
                Hook:     "fde-setup",
                // XXX: should this be configurable somehow?
                Timeout: 5 * time.Minute,
        }
        contextData := map[string]any{
                "fde-setup-request": req,
        }
        st.Unlock()
        defer st.Lock()
        context, err := m.hookMgr.EphemeralRunHook(context.Background(), hooksup, contextData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot run hook for %q: %v", req.Op, err)
        }</span>
        // the hook is expected to call "snapctl fde-setup-result" which
        // will set the "fde-setup-result" value on the task
        <span class="cov0" title="0">var hookOutput []byte
        context.Lock()
        err = context.Get("fde-setup-result", &amp;hookOutput)
        context.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get result from fde-setup hook %q: %v", req.Op, err)
        }</span>
        <span class="cov0" title="0">return hookOutput, nil</span>
}

type fdeSetupHandler struct {
        context *hookstate.Context
}

func newFdeSetupHandler(ctx *hookstate.Context) hookstate.Handler <span class="cov0" title="0">{
        return fdeSetupHandler{context: ctx}
}</span>

func (h fdeSetupHandler) Before() error <span class="cov0" title="0">{
        return nil
}</span>

func (h fdeSetupHandler) Done() error <span class="cov0" title="0">{
        return nil
}</span>

func (h fdeSetupHandler) Error(err error) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

var (
        secbootEnsureRecoveryKey  = secboot.EnsureRecoveryKey
        secbootRemoveRecoveryKeys = secboot.RemoveRecoveryKeys
)

// EnsureRecoveryKeys makes sure appropriate recovery keys exist and
// returns them. Usually a single recovery key is created/used, but
// older systems might return both a recovery key for ubuntu-data and a
// reinstall key for ubuntu-save.
func (m *DeviceManager) EnsureRecoveryKeys() (*client.SystemRecoveryKeysResponse, error) <span class="cov0" title="0">{
        deviceCtx, err := DeviceCtx(m.state, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">model := deviceCtx.Model()

        fdeDir := dirs.SnapFDEDir
        mode := m.SystemMode(SysAny)
        if mode == "install" </span><span class="cov0" title="0">{
                fdeDir = boot.InstallHostFDEDataDir(model)
        }</span> else<span class="cov0" title="0"> if mode != "run" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot ensure recovery keys from system mode %q", mode)
        }</span>

        <span class="cov0" title="0">sysKeys := &amp;client.SystemRecoveryKeysResponse{}
        // backward compatibility
        reinstallKeyFile := filepath.Join(fdeDir, "reinstall.key")
        if osutil.FileExists(reinstallKeyFile) </span><span class="cov0" title="0">{
                rkey, err := keys.RecoveryKeyFromFile(device.RecoveryKeyUnder(fdeDir))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sysKeys.RecoveryKey = rkey.String()

                reinstallKey, err := keys.RecoveryKeyFromFile(reinstallKeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sysKeys.ReinstallKey = reinstallKey.String()
                return sysKeys, nil</span>
        }
        <span class="cov0" title="0">if !device.HasEncryptedMarkerUnder(fdeDir) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("system does not use disk encryption")
        }</span>
        <span class="cov0" title="0">dataMountPoints, err := boot.HostUbuntuDataForMode(m.SystemMode(SysHasModeenv), model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot determine ubuntu-data mount point: %v", err)
        }</span>
        <span class="cov0" title="0">if len(dataMountPoints) == 0 </span><span class="cov0" title="0">{
                // shouldn't happen as the marker file is under ubuntu-data
                return nil, fmt.Errorf("cannot ensure recovery keys without any ubuntu-data mount points")
        }</span>
        <span class="cov0" title="0">authKeyDir := dataMountPoints[0]
        if !model.Classic() </span><span class="cov0" title="0">{
                authKeyDir = filepath.Join(authKeyDir, "system-data")
        }</span>
        <span class="cov0" title="0">recoveryKeyDevices := []secboot.RecoveryKeyDevice{
                {
                        Mountpoint: dataMountPoints[0],
                        // TODO ubuntu-data key in install mode? key isn't
                        // available in the keyring nor exists on disk
                },
                {
                        Mountpoint:         boot.InitramfsUbuntuSaveDir,
                        AuthorizingKeyFile: device.SaveKeyUnder(dirs.SnapFDEDirUnder(authKeyDir)),
                },
        }
        rkey, err := secbootEnsureRecoveryKey(device.RecoveryKeyUnder(fdeDir), recoveryKeyDevices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sysKeys.RecoveryKey = rkey.String()
        return sysKeys, nil</span>
}

// RemoveRecoveryKeys removes and disables all recovery keys.
func (m *DeviceManager) RemoveRecoveryKeys() error <span class="cov0" title="0">{
        mode := m.SystemMode(SysAny)
        if mode != "run" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove recovery keys from system mode %q", mode)
        }</span>
        <span class="cov0" title="0">if !device.HasEncryptedMarkerUnder(dirs.SnapFDEDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("system does not use disk encryption")
        }</span>
        <span class="cov0" title="0">deviceCtx, err := DeviceCtx(m.state, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">model := deviceCtx.Model()

        dataMountPoints, err := boot.HostUbuntuDataForMode(m.SystemMode(SysHasModeenv), model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot determine ubuntu-data mount point: %v", err)
        }</span>
        <span class="cov0" title="0">recoveryKeyDevices := make(map[secboot.RecoveryKeyDevice]string, 2)
        rkey := device.RecoveryKeyUnder(dirs.SnapFDEDir)
        recoveryKeyDevices[secboot.RecoveryKeyDevice{
                Mountpoint: dataMountPoints[0],
                // authorization from keyring
        }] = rkey
        // reinstall.key is deprecated, there is no path helper for it
        reinstallKeyFile := filepath.Join(dirs.SnapFDEDir, "reinstall.key")
        if !osutil.FileExists(reinstallKeyFile) </span><span class="cov0" title="0">{
                reinstallKeyFile = rkey
        }</span>
        <span class="cov0" title="0">authKeyDir := dataMountPoints[0]
        if !model.Classic() </span><span class="cov0" title="0">{
                authKeyDir = filepath.Join(authKeyDir, "system-data")
        }</span>
        <span class="cov0" title="0">recoveryKeyDevices[secboot.RecoveryKeyDevice{
                Mountpoint:         boot.InitramfsUbuntuSaveDir,
                AuthorizingKeyFile: device.SaveKeyUnder(dirs.SnapFDEDirUnder(authKeyDir)),
        }] = reinstallKeyFile

        return secbootRemoveRecoveryKeys(recoveryKeyDevices)</span>
}

// checkEncryption verifies whether encryption should be used based on the model
// grade and the availability of a TPM device, fde-setup hook in the kernel, or
// the OPTEE trusted application.
func (m *DeviceManager) checkEncryption(st *state.State, deviceCtx snapstate.DeviceContext, tpmMode secboot.TPMProvisionMode) (device.EncryptionType, error) <span class="cov0" title="0">{
        model := deviceCtx.Model()

        kernelInfo, err := snapstate.KernelInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot check encryption support: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetSnapInfo, err := snapstate.GadgetInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">gadgetInfo, err := gadget.ReadInfo(gadgetSnapInfo.MountDir(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return install.CheckEncryptionSupport(install.EncryptionConstraints{
                Model:   model,
                TPMMode: tpmMode,
                Kernel:  kernelInfo,
                Gadget:  gadgetInfo,
        }, m.runFDESetupHook)</span>
}

// encryptionSupportInfoUnlocked is the encryptionSupportInfo variant to use when the state is not locked.
func (m *DeviceManager) encryptionSupportInfoUnlocked(systemLabel string, constraints install.EncryptionConstraints, encInfoFromCache bool) (*install.EncryptionSupportInfo, error) <span class="cov0" title="0">{
        return m.encryptionSupportInfo(
                systemLabel,
                constraints,
                encInfoFromCache,
                m.readCacheEncryptionSupportInfoUnlocked,
                m.refreshCacheEncryptionSupportInfoUnlocked,
        )
}</span>

// encryptionSupportInfoLocked is the encryptionSupportInfo variant to use when the state is locked.
func (m *DeviceManager) encryptionSupportInfoLocked(systemLabel string, constraints install.EncryptionConstraints, encInfoFromCache bool) (*install.EncryptionSupportInfo, error) <span class="cov0" title="0">{
        return m.encryptionSupportInfo(
                systemLabel,
                constraints, encInfoFromCache,
                m.readCacheEncryptionSupportInfoLocked,
                m.refreshCacheEncryptionSupportInfoLocked,
        )
}</span>

// encryptionSupportInfo returns encryption support information, optionally
// consulting and refreshing a cache.
//
// Cache behavior is implicit and depends on the combination of arguments:
//   - With a CheckAction: the cache must provide a valid CheckContext. In this
//     mode, only the CheckContext is used, and the rest of the cached
//     EncryptionSupportInfo is ignored. This implies that any call with
//     CheckAction must be preceded by a call without that populates the cache.
//   - Without a CheckAction and encInfoFromCache set to true: the function
//     returns the cached EncryptionSupportInfo directly, if available. This
//     provides a way to skip the expensive encryption availability check in
//     cases where it is not relevant.
//   - Otherwise: the function computes fresh information via
//     GetEncryptionSupportInfo and refreshes the cache on success.
//
// Errors are returned if inconsistent or impossible cache usage is requested
//   - CheckAction requires a cache but none is available
//   - CheckAction is combined with encInfoFromCache set to true
func (m *DeviceManager) encryptionSupportInfo(
        systemLabel string,
        constraints install.EncryptionConstraints,
        encInfoFromCache bool,
        readCache func(systemLabel string) *install.EncryptionSupportInfo,
        refreshCache func(systemLabel string, info *install.EncryptionSupportInfo),
) (*install.EncryptionSupportInfo, error) <span class="cov0" title="0">{

        if constraints.CheckAction != nil &amp;&amp; encInfoFromCache </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: cannot apply check action and use cached encryption information")
        }</span>

        <span class="cov0" title="0">cachedEncryptionSupportInfo := readCache(systemLabel)

        if constraints.CheckAction != nil </span><span class="cov0" title="0">{
                // a check action requires only the check context from the cache
                // and need to run the check
                if cachedEncryptionSupportInfo == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("cannot use check action without cached encryption information")
                }</span>
                <span class="cov0" title="0">checkContext := cachedEncryptionSupportInfo.CheckContext()
                if checkContext == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("cannot use check action without cached check context")
                }</span>
                <span class="cov0" title="0">constraints.CheckContext = checkContext</span>
        } else<span class="cov0" title="0"> if encInfoFromCache &amp;&amp; cachedEncryptionSupportInfo != nil </span><span class="cov0" title="0">{
                // in case of no check action use encryption support info from the
                // cache when requested and available
                return cachedEncryptionSupportInfo, nil
        }</span>

        // GetEncryptionSupportInfo expects and uses constraints.CheckContext when
        // constraints.CheckAction != nil, otherwise it is ignored. See
        // install.encryptionAvailabilityCheck.
        <span class="cov0" title="0">encInfo, err := install.GetEncryptionSupportInfo(constraints, m.runFDESetupHook)
        if err == nil </span><span class="cov0" title="0">{
                refreshCache(systemLabel, &amp;encInfo)
        }</span>
        <span class="cov0" title="0">return &amp;encInfo, err</span>
}

type encryptionSupportInfoKey struct{ systemLabel string }

// SetEncryptionSupportInfoInCacheUnlocked is a test only helper for populating EncryptionSupportInfo in cache.
func (m *DeviceManager) SetEncryptionSupportInfoInCacheUnlocked(systemLabel string, encryptionInfo *install.EncryptionSupportInfo) <span class="cov0" title="0">{
        osutil.MustBeTestBinary("SetEncryptionSupportInfoInCacheUnlocked can only be used tests")
        m.refreshCacheEncryptionSupportInfoUnlocked(systemLabel, encryptionInfo)
}</span>

// refreshCacheEncryptionSupportUnlocked is the refreshCacheEncryptionSupport variant to use when the state is not locked.
func (m *DeviceManager) refreshCacheEncryptionSupportInfoUnlocked(systemLabel string, encryptionInfo *install.EncryptionSupportInfo) <span class="cov0" title="0">{
        m.state.Lock()
        defer m.state.Unlock()
        m.refreshCacheEncryptionSupportInfoLocked(systemLabel, encryptionInfo)
}</span>

// refreshCacheEncryptionSupportLocked is the refreshCacheEncryptionSupport variant to use when the state is locked.
func (m *DeviceManager) refreshCacheEncryptionSupportInfoLocked(systemLabel string, encryptionInfo *install.EncryptionSupportInfo) <span class="cov0" title="0">{
        m.state.Cache(encryptionSupportInfoKey{systemLabel}, encryptionInfo)
}</span>

// readCacheEncryptionSupportInfoStateUnlocked is the readCacheEncryptionSupportInfoState variant that does not lock state.
func (m *DeviceManager) readCacheEncryptionSupportInfoUnlocked(systemLabel string) *install.EncryptionSupportInfo <span class="cov0" title="0">{
        m.state.Lock()
        defer m.state.Unlock()
        return m.readCacheEncryptionSupportInfoLocked(systemLabel)
}</span>

// readCacheEncryptionSupportInfoStateLocked is the readCacheEncryptionSupportInfoState variant that locks state.
func (m *DeviceManager) readCacheEncryptionSupportInfoLocked(systemLabel string) *install.EncryptionSupportInfo <span class="cov0" title="0">{
        cached := m.state.Cached(encryptionSupportInfoKey{systemLabel})
        if cached != nil </span><span class="cov0" title="0">{
                encryptionSupportInfo, ok := cached.(*install.EncryptionSupportInfo)
                if ok </span><span class="cov0" title="0">{
                        return encryptionSupportInfo
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

// Package devicestate implements the manager and state aspects responsible
// for the device identity and policies.
package devicestate

import (
        "context"
        "errors"
        "fmt"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/asserts/snapasserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/gadget/device"
        "github.com/snapcore/snapd/i18n"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/netutil"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/configstate/config"
        "github.com/snapcore/snapd/overlord/devicestate/internal"
        "github.com/snapcore/snapd/overlord/ifacestate/ifacerepo"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/overlord/swfeats"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/snap/channel"
        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/snap/snapfile"
        "github.com/snapcore/snapd/strutil"
)

var (
        snapstateDownloadComponents   = snapstate.DownloadComponents
        snapstateDownload             = snapstate.Download
        snapstateUpdateOne            = snapstate.UpdateOne
        snapstateInstallOne           = snapstate.InstallOne
        snapstateStoreInstallGoal     = snapstate.StoreInstallGoal
        snapstatePathInstallGoal      = snapstate.PathInstallGoal
        snapstateStoreUpdateGoal      = snapstate.StoreUpdateGoal
        snapstatePathUpdateGoal       = snapstate.PathUpdateGoal
        snapstateInstallComponents    = snapstate.InstallComponents
        snapstateInstallComponentPath = snapstate.InstallComponentPath
)

var (
        remodelChangeKind                           = swfeats.RegisterChangeKind("remodel")
        removeRecoverySystemChangeKind              = swfeats.RegisterChangeKind("remove-recovery-system")
        createRecoverySystemChangeKind              = swfeats.RegisterChangeKind("create-recovery-system")
        installStepFinishChangeKind                 = swfeats.RegisterChangeKind("install-step-finish")
        installStepSetupStorageEncryptionChangeKind = swfeats.RegisterChangeKind("install-step-setup-storage-encryption")
)

// findModel returns the device model assertion.
func findModel(st *state.State) (*asserts.Model, error) <span class="cov8" title="1">{
        device, err := internal.Device(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if device.Brand == "" || device.Model == "" </span><span class="cov8" title="1">{
                return nil, state.ErrNoState
        }</span>

        <span class="cov8" title="1">a, err := assertstate.DB(st).Find(asserts.ModelType, map[string]string{
                "series":   release.Series,
                "brand-id": device.Brand,
                "model":    device.Model,
        })
        if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return a.(*asserts.Model), nil</span>
}

// findSerial returns the device serial assertion. device is optional and used instead of the global state if provided.
func findSerial(st *state.State, device *auth.DeviceState) (*asserts.Serial, error) <span class="cov0" title="0">{
        if device == nil </span><span class="cov0" title="0">{
                var err error
                device, err = internal.Device(st)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if device.Serial == "" </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>

        <span class="cov0" title="0">a, err := assertstate.DB(st).Find(asserts.SerialType, map[string]string{
                "brand-id": device.Brand,
                "model":    device.Model,
                "serial":   device.Serial,
        })
        if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a.(*asserts.Serial), nil</span>
}

// findKnownRevisionOfModel returns the model assertion revision if any in the
// assertion database for the given model, otherwise it returns -1.
func findKnownRevisionOfModel(st *state.State, mod *asserts.Model) (modRevision int, err error) <span class="cov0" title="0">{
        a, err := assertstate.DB(st).Find(asserts.ModelType, map[string]string{
                "series":   release.Series,
                "brand-id": mod.BrandID(),
                "model":    mod.Model(),
        })
        if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return -1, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return a.Revision(), nil</span>
}

// auto-refresh
func canAutoRefresh(st *state.State) (bool, error) <span class="cov0" title="0">{
        // we need to be seeded first
        var seeded bool
        st.Get("seeded", &amp;seeded)
        if !seeded </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Try to ensure we have an accurate time before doing any
        // refreshy stuff. Note that this call will not block.
        <span class="cov0" title="0">devMgr := deviceMgr(st)
        maxWait := 10 * time.Minute
        if !devMgr.ntpSyncedOrWaitedLongerThan(maxWait) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Either we have a serial or we try anyway if we attempted
        // for a while to get a serial, this would allow us to at
        // least upgrade core if that can help.
        <span class="cov0" title="0">if ensureOperationalAttempts(st) &gt;= 3 </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Check model exists, for validity. We always have a model, either
        // seeded or a generic one that ships with snapd.
        <span class="cov0" title="0">_, err := findModel(st)
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">_, err = findSerial(st, nil)
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func checkGadgetOrKernel(st *state.State, snapInfo, curInfo *snap.Info, _ snap.Container, flags snapstate.Flags, deviceCtx snapstate.DeviceContext) error <span class="cov0" title="0">{
        kind := ""
        var snapType snap.Type
        var getName func(*asserts.Model) string
        switch snapInfo.Type() </span>{
        case snap.TypeGadget:<span class="cov0" title="0">
                kind = "gadget"
                snapType = snap.TypeGadget
                getName = (*asserts.Model).Gadget</span>
        case snap.TypeKernel:<span class="cov0" title="0">
                if deviceCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot install a kernel snap if classic boot")
                }</span>

                <span class="cov0" title="0">kind = "kernel"
                snapType = snap.TypeKernel
                getName = (*asserts.Model).Kernel</span>
        default:<span class="cov0" title="0">
                // not a relevant check
                return nil</span>
        }

        <span class="cov0" title="0">model := deviceCtx.Model()

        if snapInfo.SnapID != "" </span><span class="cov0" title="0">{
                snapDecl, err := assertstate.SnapDeclaration(st, snapInfo.SnapID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: cannot find snap declaration for %q: %v", snapInfo.InstanceName(), err)
                }</span>
                <span class="cov0" title="0">publisher := snapDecl.PublisherID()
                if publisher != "canonical" &amp;&amp; publisher != model.BrandID() </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot install %s %q published by %q for model by %q", kind, snapInfo.InstanceName(), publisher, model.BrandID())
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Noticef("installing unasserted %s %q", kind, snapInfo.InstanceName())
        }</span>

        <span class="cov0" title="0">found, err := snapstate.HasSnapOfType(st, snapType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot detect original %s snap: %v", kind, err)
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                // already installed, snapstate takes care
                return nil
        }</span>
        // first installation of a gadget/kernel

        <span class="cov0" title="0">expectedName := getName(model)
        if expectedName == "" </span><span class="cov0" title="0">{ // can happen only on classic
                return fmt.Errorf("cannot install %s snap on classic if not requested by the model", kind)
        }</span>

        <span class="cov0" title="0">if snapInfo.InstanceName() != snapInfo.SnapName() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot install %q, parallel installation of kernel or gadget snaps is not supported", snapInfo.InstanceName())
        }</span>

        <span class="cov0" title="0">if snapInfo.InstanceName() != expectedName </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot install %s %q, model assertion requests %q", kind, snapInfo.InstanceName(), expectedName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func checkGadgetValid(st *state.State, snapInfo, _ *snap.Info, snapf snap.Container, flags snapstate.Flags, deviceCtx snapstate.DeviceContext) error <span class="cov0" title="0">{
        if snapInfo.Type() != snap.TypeGadget </span><span class="cov0" title="0">{
                // not a gadget, nothing to do
                return nil
        }</span>
        <span class="cov0" title="0">if deviceCtx.ForRemodeling() </span><span class="cov0" title="0">{
                // in this case the gadget is checked by
                // checkGadgetRemodelCompatible
                return nil
        }</span>

        // do basic precondition checks on the gadget against its model constraints
        <span class="cov0" title="0">_, err := gadget.ReadInfoFromSnapFile(snapf, deviceCtx.Model())
        return err</span>
}

var once sync.Once

func delayedCrossMgrInit() <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                snapstate.AddCheckSnapCallback(checkGadgetOrKernel)
                snapstate.AddCheckSnapCallback(checkGadgetValid)
                snapstate.AddCheckSnapCallback(checkGadgetRemodelCompatible)
        }</span>)
        <span class="cov8" title="1">snapstate.CanAutoRefresh = canAutoRefresh
        snapstate.IsOnMeteredConnection = netutil.IsOnMeteredConnection
        snapstate.DeviceCtx = DeviceCtx
        snapstate.RemodelingChange = RemodelingChange</span>
}

// proxyStore returns the store assertion for the proxy store if one is set.
func proxyStore(st *state.State, tr *config.Transaction) (*asserts.Store, error) <span class="cov8" title="1">{
        var proxyStore string
        err := tr.GetMaybe("core", "proxy.store", &amp;proxyStore)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if proxyStore == "" </span><span class="cov8" title="1">{
                return nil, state.ErrNoState
        }</span>

        <span class="cov0" title="0">a, err := assertstate.DB(st).Find(asserts.StoreType, map[string]string{
                "store": proxyStore,
        })
        if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a.(*asserts.Store), nil</span>
}

// interfaceConnected returns true if the given snap/interface names
// are connected
func interfaceConnected(st *state.State, snapName, ifName string) bool <span class="cov0" title="0">{
        conns, err := ifacerepo.Get(st).Connected(snapName, ifName)
        return err == nil &amp;&amp; len(conns) &gt; 0
}</span>

// CanManageRefreshes returns true if a snap entitled to setting the
// refresh-schedule to managed is installed in the system and the relevant
// interface is currently connected.
//
// TODO:
//   - Move the CanManageRefreshes code into the ifstate
//   - Look at the connections and find the connection for snapd-control
//     with the managed attribute
func CanManageRefreshes(st *state.State) bool <span class="cov0" title="0">{
        snapStates, err := snapstate.All(st)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, snapst := range snapStates </span><span class="cov0" title="0">{
                // Always get the current info even if the snap is currently
                // being operated on or if its disabled.
                info, err := snapst.CurrentInfo()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if info.Broken != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // The snap must have a snap declaration (implies that
                // its from the store)
                <span class="cov0" title="0">if _, err := assertstate.SnapDeclaration(st, info.SideInfo.SnapID); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, plugInfo := range info.Plugs </span><span class="cov0" title="0">{
                        if plugInfo.Interface == "snapd-control" &amp;&amp; plugInfo.Attrs["refresh-schedule"] == "managed" </span><span class="cov0" title="0">{
                                snapName := info.InstanceName()
                                plugName := plugInfo.Name
                                if interfaceConnected(st, snapName, plugName) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

// ResetSession clears the device store session if any.
func ResetSession(st *state.State) error <span class="cov0" title="0">{
        device, err := internal.Device(st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if device.SessionMacaroon != "" </span><span class="cov0" title="0">{
                device.SessionMacaroon = ""
                if err := internal.SetDevice(st, device); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getAllRequiredSnapsForModel(model *asserts.Model) *naming.SnapSet <span class="cov0" title="0">{
        reqSnaps := model.RequiredWithEssentialSnaps()
        return naming.NewSnapSet(reqSnaps)
}</span>

var errNoBeforeLocalModificationsEdge = fmt.Errorf("before-local-modifications edge not found")

// extractBeforeLocalModificationsEdgesTs extracts the first, last download
// phase and install phase tasks from a TaskSet
func extractBeforeLocalModificationsEdgesTs(ts *state.TaskSet) (firstDl, lastDl, firstInst, lastInst *state.Task, err error) <span class="cov0" title="0">{
        edgeTask := ts.MaybeEdge(snapstate.LastBeforeLocalModificationsEdge)
        if edgeTask == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, errNoBeforeLocalModificationsEdge
        }</span>
        <span class="cov0" title="0">tasks := ts.Tasks()
        // we know we always start with downloads (or prepare-snap tasks, in the
        // case of an offline remodel)
        firstDl = tasks[0]
        // and always end with installs
        lastInst = tasks[len(tasks)-1]

        var edgeTaskIndex int
        for i, task := range tasks </span><span class="cov0" title="0">{
                if task == edgeTask </span><span class="cov0" title="0">{
                        edgeTaskIndex = i
                        break</span>
                }
        }
        <span class="cov0" title="0">return firstDl, tasks[edgeTaskIndex], tasks[edgeTaskIndex+1], lastInst, nil</span>
}

func modelSnapChannelFromDefaultOrPinnedTrack(new *asserts.Model, s *asserts.ModelSnap) (string, error) <span class="cov0" title="0">{
        if new.Grade() == asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                if s == nil </span><span class="cov0" title="0">{
                        // it was possible to not specify the base snap in UC16
                        return "", nil
                }</span>
                <span class="cov0" title="0">if (s.SnapType == "kernel" || s.SnapType == "gadget") &amp;&amp; s.PinnedTrack != "" </span><span class="cov0" title="0">{
                        return s.PinnedTrack, nil
                }</span>
                <span class="cov0" title="0">return "", nil</span>
        }
        <span class="cov0" title="0">return channel.Full(s.DefaultChannel)</span>
}

// pass both the snap name and the model snap, as it is possible that
// the model snap is nil for UC16 models
type modelSnapsForRemodel struct {
        new *asserts.Model

        oldSnap      string
        oldModelSnap *asserts.ModelSnap

        newSnap      string
        newModelSnap *asserts.ModelSnap
}

type remodeler struct {
        newModel        *asserts.Model
        offline         bool
        localSnaps      map[string]snapstate.PathSnap
        localComponents map[string]snapstate.PathComponent

        vsets      *snapasserts.ValidationSets
        tracker    *snap.SelfContainedSetPrereqTracker
        deviceCtx  snapstate.DeviceContext
        fromChange string
}

// remodelSnapTarget represents a snap that is part of the model that we are
// remodeling to.
type remodelSnapTarget struct {
        // name is the name of the snap.
        name string
        // channel is the channel that the snap should be installed from and track.
        channel string
        // newModelSnap is the model snap for this target. This might be nil for
        // either the snapd snap (which is implicitly in the model) or for the base
        // snap on UC16 models. Always check for nil before using.
        newModelSnap *asserts.ModelSnap
        // oldModelSnap is the corresponding model snap for the snap that this
        // target is replacing. This will be nil for non-essential snaps, and it
        // might be nil for the snapd snap (which is implicitly in the model) or for
        // the base snap on UC16 models. Always check for nil before using.
        oldModelSnap *asserts.ModelSnap
}

// canHaveUC18PinnedTrack returns whether the given model snap can have a pinned
// track. Only the kernel and gadget snaps from a UC18 model can have a pinned
// track. Note that this is different than the default-channel that is used for
// UC20+ models.
func canHaveUC18PinnedTrack(ms *asserts.ModelSnap) bool <span class="cov0" title="0">{
        return ms != nil &amp;&amp; (ms.SnapType == "kernel" || ms.SnapType == "gadget")
}</span>

// uc20Model returns true if the given model is a UC20+ model. UC20+ models can
// be identified by the presence of a grade in the model.
func uc20Model(m *asserts.Model) bool <span class="cov0" title="0">{
        return m.Grade() != asserts.ModelGradeUnset
}</span>

type remodelAction int

const (
        remodelInvalidAction remodelAction = iota
        remodelNoAction
        remodelChannelSwitch
        remodelInstallAction
        remodelUpdateAction
        remodelAddComponentsAction
)

func (r *remodeler) maybeInstallOrUpdate(ctx context.Context, st *state.State, rt remodelSnapTarget) (remodelAction, []*state.TaskSet, error) <span class="cov0" title="0">{
        var requiredComponents, optionalComponents []string
        if ms := rt.newModelSnap; ms != nil </span><span class="cov0" title="0">{
                for comp, mc := range ms.Components </span><span class="cov0" title="0">{
                        switch mc.Presence </span>{
                        case "required":<span class="cov0" title="0">
                                requiredComponents = append(requiredComponents, comp)</span>
                        case "optional":<span class="cov0" title="0">
                                optionalComponents = append(optionalComponents, comp)</span>
                        }
                }
        }

        <span class="cov0" title="0">var snapst snapstate.SnapState
        if err := snapstate.Get(st, rt.name, &amp;snapst); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                // if the snap isn't already installed and it isn't required, then we
                // can skip installing it. anything that has a nil model snap is
                // implicitly required (either snapd or a UC16 base)
                <span class="cov0" title="0">if rt.newModelSnap != nil &amp;&amp; rt.newModelSnap.Presence != "required" </span><span class="cov0" title="0">{
                        return remodelNoAction, nil, nil
                }</span>

                <span class="cov0" title="0">goal, err := r.installGoal(rt, requiredComponents)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                <span class="cov0" title="0">_, ts, err := snapstateInstallOne(ctx, st, goal, snapstate.Options{
                        DeviceCtx:     r.deviceCtx,
                        FromChange:    r.fromChange,
                        PrereqTracker: r.tracker,
                        Flags:         snapstate.Flags{NoReRefresh: true, Required: true},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                <span class="cov0" title="0">return remodelInstallAction, []*state.TaskSet{ts}, nil</span>
        }

        // in the default case, we compare the target channel against the tracked
        // channel in the state. as an exception, on UC18 systems, when we are
        // dealing with either a gadget or kernel snap,  we compare the target
        // channel to the pinned track from the model.
        <span class="cov0" title="0">currentChannelOrTrack := snapst.TrackingChannel
        if !uc20Model(r.newModel) &amp;&amp; canHaveUC18PinnedTrack(rt.oldModelSnap) </span><span class="cov0" title="0">{
                currentChannelOrTrack = rt.oldModelSnap.PinnedTrack
        }</span>
        <span class="cov0" title="0">needsChannelChange := rt.channel != "" &amp;&amp; rt.channel != currentChannelOrTrack &amp;&amp; !snapst.Current.Local()

        currentInfo, err := snapst.CurrentInfo()
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">constraints, err := r.vsets.Presence(naming.Snap(rt.name))
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">if !constraints.Revision.Unset() &amp;&amp; snapst.Current.Local() </span><span class="cov0" title="0">{
                return 0, nil, errors.New("cannot determine if unasserted snap revision matches required revision")
        }</span>

        // we need to change the revision if either the incoming model's validation
        // sets require a specific revision that we don't have installed, or if the
        // current revision doesn't support the components that we need.
        <span class="cov0" title="0">needsRevisionChange := (!constraints.Revision.Unset() &amp;&amp; constraints.Revision != snapst.Current) || !revisionSupportsComponents(currentInfo, requiredComponents)

        needsComponentChanges, requiredOptionalComponents := checkForComponentRemodelingChanges(
                rt, snapst, requiredComponents, optionalComponents, constraints, needsRevisionChange,
        )

        // if we're not going to swap snaps, then we must require that any optional
        // components that are already installed at an invalid revision are
        // updated/provided locally.
        requiredComponents = append(requiredComponents, requiredOptionalComponents...)

        // TODO: we don't properly handle snaps (and now components) that are
        // invalid in the incoming model and required by the previous model. this
        // would require removing things during a remodel, which isn't something we
        // do at the moment. afaict, it is impossible to remodel from a model that
        // requires a snap that is invalid in the incoming model.

        switch </span>{
        case needsRevisionChange || needsChannelChange:<span class="cov0" title="0">
                if r.shouldSwitchWithoutRefresh(rt, needsRevisionChange) &amp;&amp; !needsComponentChanges </span><span class="cov0" title="0">{
                        ts, err := snapstate.Switch(st, rt.name, &amp;snapstate.RevisionOptions{
                                Channel: rt.channel,
                        }, r.tracker)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, nil, err
                        }</span>

                        <span class="cov0" title="0">return remodelChannelSwitch, []*state.TaskSet{ts}, nil</span>
                }

                // right now, we don't properly handle switching a channel and
                // installing components at the same time. in the meantime, we can use
                // snapstate.UpdateOne to add additional components and switch the
                // channel for us. this method is suboptimal, since we're creating tasks
                // for essentially re-installing the snap.
                //
                // this also will not work well for offline remodeling, since it
                // prevents us from using a combination of locally provided components
                // and an already installed snap. for that case,
                // snapstate.InstallComponents would need to support switching channels
                // at the same time as installing components.
                <span class="cov0" title="0">goal, err := r.updateGoal(st, rt, requiredComponents, constraints)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                <span class="cov0" title="0">ts, err := snapstateUpdateOne(ctx, st, goal, nil, snapstate.Options{
                        DeviceCtx:     r.deviceCtx,
                        FromChange:    r.fromChange,
                        PrereqTracker: r.tracker,
                        Flags:         snapstate.Flags{NoReRefresh: true},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                // if there are any local modfifications, we know that we're doing more
                // than a channel switch
                <span class="cov0" title="0">if ts.MaybeEdge(snapstate.LastBeforeLocalModificationsEdge) != nil </span><span class="cov0" title="0">{
                        return remodelUpdateAction, []*state.TaskSet{ts}, nil
                }</span>

                <span class="cov0" title="0">return remodelChannelSwitch, []*state.TaskSet{ts}, nil</span>
        case needsComponentChanges:<span class="cov0" title="0">
                tss, err := r.installComponents(ctx, st, currentInfo, requiredComponents)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>
                <span class="cov0" title="0">return remodelAddComponentsAction, tss, nil</span>
        default:<span class="cov0" title="0">
                // nothing to do but add the snap to the prereq tracker
                r.tracker.Add(currentInfo)
                return remodelNoAction, nil, nil</span>
        }
}

// checkForComponentRemodelingChanges determines if we need to make any changes to the
// existing state of the components for the given remodel target. Additionally,
// if it is determined that we can use the current snap's revision, then any
// already-installed optional components that must have their revision changed
// to fulfill the validation set constraints are returned.
func checkForComponentRemodelingChanges(
        rt remodelSnapTarget,
        snapst snapstate.SnapState,
        requiredComponents []string,
        optionalComponents []string,
        constraints snapasserts.SnapPresenceConstraints,
        snapNeedsRevisionChange bool,
) (needsComponentChanges bool, requiredOptionalComponents []string) <span class="cov0" title="0">{
        // check if any components are either missing, or installed at the wrong
        // revision. note that we will only explicitly handle these needed changes
        // if the snap itself, and its channel, are already valid in the incoming
        // model
        for _, c := range requiredComponents </span><span class="cov0" title="0">{
                csi := snapst.CurrentComponentSideInfo(naming.NewComponentRef(rt.name, c))
                if csi == nil </span><span class="cov0" title="0">{
                        needsComponentChanges = true
                        break</span>
                }

                <span class="cov0" title="0">compConstraints := constraints.Component(c)
                if !compConstraints.Revision.Unset() &amp;&amp; compConstraints.Revision != csi.Revision </span><span class="cov0" title="0">{
                        needsComponentChanges = true
                        break</span>
                }
        }

        // if we're not changing the revision, then we have to check if any of the
        // model's optional components are installed and make sure that they are at
        // the correct revision. if they aren't then we'll either attempt to update
        // them from the store or they must come from a given file.
        <span class="cov0" title="0">if !snapNeedsRevisionChange </span><span class="cov0" title="0">{
                requiredOptionalComponents = make([]string, 0, len(optionalComponents))
                for _, c := range optionalComponents </span><span class="cov0" title="0">{
                        csi := snapst.CurrentComponentSideInfo(naming.NewComponentRef(rt.name, c))
                        if csi == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">compConstraints := constraints.Component(c)
                        if !compConstraints.Revision.Unset() &amp;&amp; compConstraints.Revision != csi.Revision </span><span class="cov0" title="0">{
                                needsComponentChanges = true
                                requiredOptionalComponents = append(requiredOptionalComponents, c)
                        }</span>
                }
        }
        <span class="cov0" title="0">return needsComponentChanges, requiredOptionalComponents</span>
}

func (r *remodeler) shouldSwitchWithoutRefresh(rt remodelSnapTarget, needsRevisionChange bool) bool <span class="cov0" title="0">{
        if !r.offline </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if needsRevisionChange </span><span class="cov0" title="0">{
                return false
        }</span>

        // if we have a local container for this snap, then we should use that in
        // addition to switching the tracked channel
        <span class="cov0" title="0">if _, ok := r.localSnaps[rt.name]; ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func revisionSupportsComponents(info *snap.Info, components []string) bool <span class="cov0" title="0">{
        for _, c := range components </span><span class="cov0" title="0">{
                if _, ok := info.Components[c]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (r *remodeler) installGoal(sn remodelSnapTarget, components []string) (snapstate.InstallGoal, error) <span class="cov0" title="0">{
        if r.offline </span><span class="cov0" title="0">{
                ls, ok := r.localSnaps[sn.name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no snap file provided for %q", sn.name)
                }</span>

                <span class="cov0" title="0">comps := make([]snapstate.PathComponent, 0, len(components))
                for _, c := range components </span><span class="cov0" title="0">{
                        cref := naming.NewComponentRef(sn.name, c)
                        lc, ok := r.localComponents[cref.String()]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot find locally provided component: %q", cref)
                        }</span>

                        <span class="cov0" title="0">comps = append(comps, lc)</span>
                }

                <span class="cov0" title="0">opts := snapstate.RevisionOptions{
                        Channel:        sn.channel,
                        ValidationSets: r.vsets,
                }

                // TODO: snapstate for by-path installs doesn't verify validation sets.
                // decide if we want to manually verify the given rules here or not.

                return snapstatePathInstallGoal(snapstate.PathSnap{
                        Path:       ls.Path,
                        SideInfo:   ls.SideInfo,
                        RevOpts:    opts,
                        Components: comps,
                }), nil</span>
        }

        <span class="cov0" title="0">return snapstateStoreInstallGoal(snapstate.StoreSnap{
                InstanceName: sn.name,
                Components:   components,
                RevOpts: snapstate.RevisionOptions{
                        Channel:        sn.channel,
                        ValidationSets: r.vsets,
                },
        }), nil</span>
}

// installedRevisionUpdateGoal returns an update goal which will install a snap
// revision that was previously installed on the system and still in the
// sequence. We use a [snapstate.PathUpdateGoal] to enable this.
func (r *remodeler) installedRevisionUpdateGoal(
        st *state.State,
        sn remodelSnapTarget,
        components []string,
        constraints snapasserts.SnapPresenceConstraints,
) (snapstate.UpdateGoal, error) <span class="cov0" title="0">{
        if constraints.Revision.Unset() </span><span class="cov0" title="0">{
                return nil, errors.New("internal error: falling back to a previous revision requires that we have a specific revision to pick")
        }</span>

        <span class="cov0" title="0">var snapst snapstate.SnapState
        if err := snapstate.Get(st, sn.name, &amp;snapst); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">index := snapst.LastIndex(constraints.Revision)
        if index == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("installed snap %q does not have the required revision in its sequence to be used for offline remodel: %s", sn.name, constraints.Revision)
        }</span>

        <span class="cov0" title="0">ss := snapst.Sequence.Revisions[index]
        comps := make([]snapstate.PathComponent, 0, len(ss.Components))
        for _, c := range components </span><span class="cov0" title="0">{
                cref := naming.NewComponentRef(snap.InstanceSnap(sn.name), c)
                cs := ss.FindComponent(cref)
                if cs == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find required component in set of already installed components: %s", cref)
                }</span>

                <span class="cov0" title="0">compConstraints := constraints.Component(cs.SideInfo.Component.ComponentName)
                if !compConstraints.Revision.Unset() &amp;&amp; compConstraints.Revision != cs.SideInfo.Revision </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot fall back to component %q with revision %s, required revision is %s", cs.SideInfo.Component, cs.SideInfo.Revision, compConstraints.Revision)
                }</span>

                <span class="cov0" title="0">cpi := snap.MinimalComponentContainerPlaceInfo(
                        cs.SideInfo.Component.ComponentName,
                        cs.SideInfo.Revision,
                        snapst.InstanceName(),
                )

                comps = append(comps, snapstate.PathComponent{
                        SideInfo: cs.SideInfo,
                        Path:     cpi.MountFile(),
                })</span>
        }

        <span class="cov0" title="0">sideInfo := *ss.Snap

        // despite swapping back to an old revision in the sequence, we still might
        // need to swap to a new channel to track.
        if sn.channel != "" </span><span class="cov0" title="0">{
                sideInfo.Channel = sn.channel
        }</span>

        <span class="cov0" title="0">return snapstatePathUpdateGoal(snapstate.PathSnap{
                InstanceName: sn.name,
                Path:         snap.MountFile(sn.name, constraints.Revision),
                SideInfo:     &amp;sideInfo,
                Components:   comps,
                RevOpts: snapstate.RevisionOptions{
                        Channel:        sn.channel,
                        ValidationSets: r.vsets,
                        Revision:       constraints.Revision,
                },
        }), nil</span>
}

func (r *remodeler) updateGoal(st *state.State, sn remodelSnapTarget, components []string, constraints snapasserts.SnapPresenceConstraints) (snapstate.UpdateGoal, error) <span class="cov0" title="0">{
        if r.offline </span><span class="cov0" title="0">{
                ls, ok := r.localSnaps[sn.name]
                if !ok </span><span class="cov0" title="0">{
                        // this attempts to create a snapstate.StoreUpdateGoal that will
                        // switch back to a previously installed snap revision that is still
                        // in the sequence
                        g, err := r.installedRevisionUpdateGoal(st, sn, components, constraints)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return g, nil</span>
                }

                // we assume that all of the component revisions are valid with the
                // given snap revision. the code in daemon that calls Remodel verifies
                // this against the assertions db, and the task handlers in snapstate
                // also double check this while installing the snap/components.
                <span class="cov0" title="0">comps := make([]snapstate.PathComponent, 0, len(components))
                for _, c := range components </span><span class="cov0" title="0">{
                        cref := naming.NewComponentRef(sn.name, c)

                        lc, ok := r.localComponents[cref.String()]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot find locally provided component: %q", cref)
                        }</span>

                        <span class="cov0" title="0">comps = append(comps, lc)</span>
                }

                <span class="cov0" title="0">opts := snapstate.RevisionOptions{
                        Channel:        sn.channel,
                        ValidationSets: r.vsets,
                }

                // TODO: snapstate for by-path installs doesn't verify validation sets.
                // decide if we want to manually verify the given rules here or not.

                return snapstatePathUpdateGoal(snapstate.PathSnap{
                        Path:       ls.Path,
                        SideInfo:   ls.SideInfo,
                        RevOpts:    opts,
                        Components: comps,
                }), nil</span>
        }

        <span class="cov0" title="0">return snapstateStoreUpdateGoal(snapstate.StoreUpdate{
                InstanceName: sn.name,
                RevOpts: snapstate.RevisionOptions{
                        Channel:        sn.channel,
                        ValidationSets: r.vsets,
                },
                // components will be the full list of components needed by the new
                // model, and it might already contain any of the components that are
                // already installed. the snapstate code handles this case correctly.
                AdditionalComponents: components,
        }), nil</span>
}

func (r *remodeler) installComponents(ctx context.Context, st *state.State, info *snap.Info, components []string) ([]*state.TaskSet, error) <span class="cov0" title="0">{
        r.tracker.Add(info)

        if r.offline </span><span class="cov0" title="0">{
                var tss []*state.TaskSet
                for _, c := range components </span><span class="cov0" title="0">{
                        ref := naming.NewComponentRef(info.SnapName(), c)

                        lc, ok := r.localComponents[ref.String()]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot find locally provided component: %q", ref)
                        }</span>

                        <span class="cov0" title="0">ts, err := snapstateInstallComponentPath(st, lc.SideInfo, info, lc.Path, snapstate.Options{
                                DeviceCtx:     r.deviceCtx,
                                FromChange:    r.fromChange,
                                PrereqTracker: r.tracker,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">tss = append(tss, ts)</span>

                        // TODO: snapstate for by-path installs doesn't verify validation sets.
                        // decide if we want to manually verify the given rules here or not.
                }
                <span class="cov0" title="0">return tss, nil</span>
        }

        <span class="cov0" title="0">return snapstateInstallComponents(ctx, st, components, info, r.vsets, snapstate.Options{
                DeviceCtx:     r.deviceCtx,
                FromChange:    r.fromChange,
                PrereqTracker: r.tracker,
        })</span>
}

func remodelEssentialSnapTasks(
        ctx context.Context,
        st *state.State,
        rm remodeler,
        ms modelSnapsForRemodel,
) ([]*state.TaskSet, error) <span class="cov0" title="0">{
        newModelSnapChannel, err := modelSnapChannelFromDefaultOrPinnedTrack(ms.new, ms.newModelSnap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rt := remodelSnapTarget{
                name:         ms.newSnap,
                channel:      newModelSnapChannel,
                newModelSnap: ms.newModelSnap,
                oldModelSnap: ms.oldModelSnap,
        }

        logger.Debugf("creating remodel tasks for essential snap %s", ms.newSnap)
        action, tss, err := rm.maybeInstallOrUpdate(ctx, st, rt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // if we're not swapping to a new essential snap, then it should already be
        // fully available during the remodel.
        <span class="cov0" title="0">if ms.newSnap == ms.oldSnap </span><span class="cov0" title="0">{
                return tss, nil
        }</span>

        // below covers some edge cases for remodeling when the current system
        // already has some of the new model's essential snaps installed.
        //
        // note that it may seem that we are unnecessarily handling some cases for
        // kernels and gadgets, which usually are exclusive on a system. however,
        // since we do not remove snaps during a remodel, a system might have
        // multiple gadget or kernel snaps installed from a previous remodel. in
        // those cases, we will need to create the tasks to make them available
        // during the remodel, since they won't have been boot participants until
        // now.

        // when we're not modifying anything to do with the snap itself, we need to
        // create some tasks to ensure that the essential snap is available during
        // the remodel. this is done in the link-snap task, which checks to see if
        // the snap is a boot participant.
        <span class="cov0" title="0">switchEssentialTasks := func(name, fromChange string) (*state.TaskSet, error) </span><span class="cov0" title="0">{
                if ms.newModelSnap != nil &amp;&amp; ms.newModelSnap.SnapType == "gadget" </span><span class="cov0" title="0">{
                        return snapstate.SwitchToNewGadget(st, name, fromChange)
                }</span>
                <span class="cov0" title="0">return snapstate.LinkNewBaseOrKernel(st, name, fromChange)</span>
        }

        // as a bit of a special case, we support adding the needed tasks that make
        // the snap available during the remodel to an existing task set. this is
        // used when we create a task set that only changes the snap's channel.
        <span class="cov0" title="0">appendSwitchEssentialTasks := func(tss []*state.TaskSet) (*state.TaskSet, error) </span><span class="cov0" title="0">{
                if len(tss) != 1 </span><span class="cov0" title="0">{
                        return nil, errors.New("internal error: a channel switch should only have one task set")
                }</span>

                <span class="cov0" title="0">if ms.newModelSnap != nil &amp;&amp; ms.newModelSnap.SnapType == "gadget" </span><span class="cov0" title="0">{
                        return snapstate.AddGadgetAssetsTasks(st, tss[0])
                }</span>
                <span class="cov0" title="0">return snapstate.AddLinkNewBaseOrKernel(st, tss[0])</span>
        }

        <span class="cov0" title="0">switch action </span>{
        case remodelUpdateAction, remodelInstallAction:<span class="cov0" title="0">
                // if we're updating or installing a new essential snap, everything will
                // already be handled
                return tss, nil</span>
        case remodelNoAction, remodelAddComponentsAction:<span class="cov0" title="0">
                ts, err := switchEssentialTasks(ms.newSnap, rm.fromChange)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return append(tss, ts), nil</span>
        case remodelChannelSwitch:<span class="cov0" title="0">
                ts, err := appendSwitchEssentialTasks(tss)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []*state.TaskSet{ts}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("internal error: unhandled remodel action: %d", action)</span>
        }
}

// tasksForEssentialSnap returns tasks for essential snaps (actually,
// except for the snapd snap).
func tasksForEssentialSnap(
        ctx context.Context,
        st *state.State,
        snapType string,
        current, new *asserts.Model,
        rm remodeler,
) ([]*state.TaskSet, error) <span class="cov0" title="0">{
        var currentSnap, newSnap string
        var currentModelSnap, newModelSnap *asserts.ModelSnap
        switch snapType </span>{
        case "kernel":<span class="cov0" title="0">
                currentSnap = current.Kernel()
                currentModelSnap = current.KernelSnap()
                newSnap = new.Kernel()
                newModelSnap = new.KernelSnap()</span>
        case "base", "core":<span class="cov0" title="0">
                currentSnap = current.Base()
                currentModelSnap = current.BaseSnap()
                newSnap = new.Base()
                newModelSnap = new.BaseSnap()</span>
        case "gadget":<span class="cov0" title="0">
                currentSnap = current.Gadget()
                currentModelSnap = current.GadgetSnap()
                newSnap = new.Gadget()
                newModelSnap = new.GadgetSnap()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("internal error: unexpected type %q", snapType)</span>
        }

        <span class="cov0" title="0">ms := modelSnapsForRemodel{
                oldSnap:      currentSnap,
                oldModelSnap: currentModelSnap,
                new:          new,
                newSnap:      newSnap,
                newModelSnap: newModelSnap,
        }
        return remodelEssentialSnapTasks(ctx, st, rm, ms)</span>
}

func remodelSnapdSnapTasks(ctx context.Context, st *state.State, rm remodeler) ([]*state.TaskSet, error) <span class="cov0" title="0">{
        // First check if snapd snap is installed at all (might be the case
        // for uc16, which happens for some tests).
        var ss snapstate.SnapState
        if err := snapstate.Get(st, "snapd", &amp;ss); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Implicit new channel if snapd is not explicitly in the model
        <span class="cov0" title="0">newSnapdChannel := "latest/stable"
        essentialSnaps := rm.newModel.EssentialSnaps()
        if essentialSnaps[0].SnapType == "snapd" </span><span class="cov0" title="0">{
                // snapd can be specified explicitly in the model (UC20+)
                newSnapdChannel = essentialSnaps[0].DefaultChannel
        }</span>

        <span class="cov0" title="0">_, tss, err := rm.maybeInstallOrUpdate(ctx, st, remodelSnapTarget{
                name:    "snapd",
                channel: newSnapdChannel,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tss, nil</span>
}

func sortNonEssentialRemodelTaskSetsBasesFirst(snaps []*asserts.ModelSnap) []*asserts.ModelSnap <span class="cov0" title="0">{
        sorted := append([]*asserts.ModelSnap(nil), snaps...)

        orderOfType := func(snapType string) int </span><span class="cov0" title="0">{
                switch snap.Type(snapType) </span>{
                case snap.TypeBase, snap.TypeOS:<span class="cov0" title="0">
                        return -1</span>
                }
                <span class="cov0" title="0">return 1</span>
        }

        <span class="cov0" title="0">sort.Slice(sorted, func(i, j int) bool </span><span class="cov0" title="0">{
                return orderOfType(sorted[i].SnapType) &lt; orderOfType(sorted[j].SnapType)
        }</span>)

        <span class="cov0" title="0">return sorted</span>
}

func remodelTasks(ctx context.Context, st *state.State, current, new *asserts.Model,
        deviceCtx snapstate.DeviceContext, fromChange string, opts RemodelOptions) ([]*state.TaskSet, error) <span class="cov0" title="0">{

        logger.Debugf("creating remodeling tasks")

        vsets, err := verifyModelValidationSets(st, new, opts.Offline, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If local snaps are provided, all needed snaps must be locally
        // provided. We check this flag whenever a snap installation/update is
        // found needed for the remodel.
        <span class="cov0" title="0">rm := remodeler{
                newModel:        new,
                offline:         opts.Offline,
                vsets:           vsets,
                tracker:         snap.NewSelfContainedSetPrereqTracker(),
                deviceCtx:       deviceCtx,
                fromChange:      fromChange,
                localSnaps:      make(map[string]snapstate.PathSnap, len(opts.LocalSnaps)),
                localComponents: make(map[string]snapstate.PathComponent, len(opts.LocalComponents)),
        }

        for _, ls := range opts.LocalSnaps </span><span class="cov0" title="0">{
                rm.localSnaps[ls.SideInfo.RealName] = snapstate.PathSnap{
                        Path:     ls.Path,
                        SideInfo: ls.SideInfo,
                }
        }</span>

        <span class="cov0" title="0">for _, lc := range opts.LocalComponents </span><span class="cov0" title="0">{
                rm.localComponents[lc.SideInfo.Component.String()] = lc
        }</span>

        // First handle snapd as a special case
        <span class="cov0" title="0">tss, err := remodelSnapdSnapTasks(ctx, st, rm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: this order is not correct, and needs to be changed to match the
        // order that is described in the comment on essentialSnapsRestartOrder in
        // overlord/snapstate/reboot.go
        //
        // In the order: kernel, boot base, gadget
        <span class="cov0" title="0">for _, modelSnap := range new.EssentialSnaps() </span><span class="cov0" title="0">{
                if modelSnap.SnapType == "snapd" </span><span class="cov0" title="0">{
                        // Already handled
                        continue</span>
                }
                <span class="cov0" title="0">sets, err := tasksForEssentialSnap(ctx, st, modelSnap.SnapType, current, new, rm)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tss = append(tss, sets...)</span>
        }

        // if base is not set, then core will not be returned in the list of snaps
        // returned by new.EssentialSnaps(). since we know that we are remodeling
        // from a core-based system to a core-based system, then the core snap must
        // be installed. thus, we can safely add it to the prereq tracker. note that
        // moving from a UC16 model to a newer model is not supported.
        <span class="cov0" title="0">if new.Base() == "" </span><span class="cov0" title="0">{
                currentBase, err := snapstate.CurrentInfo(st, "core")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rm.tracker.Add(currentBase)</span>
        }

        // sort the snaps so that we collect the task sets for base snaps first, and
        // then the rest. this prevents a later issue where we attempt to install a
        // snap, but the base is not yet installed.
        <span class="cov0" title="0">snapsWithoutEssential := sortNonEssentialRemodelTaskSetsBasesFirst(new.SnapsWithoutEssential())

        // go through all the model snaps, see if there are new required snaps
        // or a track for existing ones needs to be updated
        for _, modelSnap := range snapsWithoutEssential </span><span class="cov0" title="0">{
                logger.Debugf("adding remodel tasks for non-essential snap %s", modelSnap.Name)

                // default channel can be set only in UC20 models
                newModelSnapChannel, err := modelSnapChannelFromDefaultOrPinnedTrack(new, modelSnap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">_, sets, err := rm.maybeInstallOrUpdate(ctx, st, remodelSnapTarget{
                        name:         modelSnap.SnapName(),
                        channel:      newModelSnapChannel,
                        newModelSnap: modelSnap,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tss = append(tss, sets...)</span>
        }

        <span class="cov0" title="0">if err := checkRequiredGadgetMatchesModelBase(new, rm.tracker); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">warnings, errs := rm.tracker.Check()
        for _, w := range warnings </span><span class="cov0" title="0">{
                logger.Noticef("remodel prerequisites warning: %v", w)
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                var builder strings.Builder
                builder.WriteString("cannot remodel to model that is not self contained:")

                for _, err := range errs </span><span class="cov0" title="0">{
                        builder.WriteString("\n  - ")
                        builder.WriteString(err.Error())
                }</span>

                <span class="cov0" title="0">return nil, errors.New(builder.String())</span>
        }

        // Ensure all download/check tasks are run *before* the install
        // tasks. During a remodel the network may not be available so
        // we need to ensure we have everything local.
        <span class="cov0" title="0">var lastDownloadInChain, firstInstallInChain *state.Task
        var prevDownload, prevInstall *state.Task
        for _, ts := range tss </span><span class="cov0" title="0">{
                // make sure all things happen sequentially
                // Terminology
                // A &lt;- B means B waits for A
                // "download,verify" are part of the "Download" phase
                // "link,start" is part of "Install" phase which introduces
                // system modifications. The last task of the "Download" phase
                // is marked with LastBeforeLocalModificationsEdge.
                //
                // - all tasks inside ts{Download,Install} already wait for
                //   each other so the chains look something like this:
                //     download1 &lt;- verify1 &lt;- install1
                //     download2 &lt;- verify2 &lt;- install2
                //     download3 &lt;- verify3 &lt;- install3
                // - add wait of each first ts{Download,Install} task for
                //   the last previous ts{Download,Install} task
                //   Our chains now looks like:
                //     download1 &lt;- verify1 &lt;- install1 (as before)
                //     download2 &lt;- verify2 &lt;- install2 (as before)
                //     download3 &lt;- verify3 &lt;- install3 (as before)
                //     verify1 &lt;- download2 (added)
                //     verify2 &lt;- download3 (added)
                //     install1  &lt;- install2 (added)
                //     install2  &lt;- install3 (added)
                downloadStart, downloadLast, installFirst, installLast, err := extractBeforeLocalModificationsEdgesTs(ts)
                if err != nil </span><span class="cov0" title="0">{
                        if err == errNoBeforeLocalModificationsEdge </span><span class="cov0" title="0">{
                                // there is no task in the task set marked with
                                // as being last before system modification
                                // edge, which can happen when there is a simple
                                // channel switch if the snap which is part of
                                // remodel has the same revision in the current
                                // channel and one that will be used after
                                // remodel
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("cannot remodel: %v", err)</span>
                }
                <span class="cov0" title="0">if prevDownload != nil </span><span class="cov0" title="0">{
                        // XXX: we don't strictly need to serialize the download
                        downloadStart.WaitFor(prevDownload)
                }</span>
                <span class="cov0" title="0">if prevInstall != nil </span><span class="cov0" title="0">{
                        installFirst.WaitFor(prevInstall)
                }</span>
                <span class="cov0" title="0">prevDownload = downloadLast
                prevInstall = installLast
                // update global state
                lastDownloadInChain = downloadLast
                if firstInstallInChain == nil </span><span class="cov0" title="0">{
                        firstInstallInChain = installFirst
                }</span>
        }
        // Make sure the first install waits for the recovery system (only in
        // UC20) which waits for the last download. With this our (simplified)
        // wait chain looks like this:
        //
        // download1
        //   ^- verify1
        //        ^- download2
        //             ^- verify2
        //                  ^- download3
        //                       ^- verify3
        //                            ^- recovery (UC20)
        //                                 ^- install1
        //                                      ^- install2
        //                                           ^- install3
        <span class="cov0" title="0">if firstInstallInChain != nil &amp;&amp; lastDownloadInChain != nil </span><span class="cov0" title="0">{
                firstInstallInChain.WaitFor(lastDownloadInChain)
        }</span>

        // hybrid core/classic systems might have a system-seed-null; in that case,
        // we cannot create a recovery system
        <span class="cov0" title="0">hasSystemSeed, err := checkForSystemSeed(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find ubuntu seed role: %w", err)
        }</span>

        <span class="cov0" title="0">recoverySetupTaskID := ""
        if new.Grade() != asserts.ModelGradeUnset &amp;&amp; hasSystemSeed </span><span class="cov0" title="0">{
                // create a recovery when remodeling to a UC20 system, actual
                // policy for possible remodels has already been verified by the
                // caller
                labelBase := timeNow().Format("20060102")
                label, err := pickRecoverySystemLabel(labelBase)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot select non-conflicting label for recovery system %q: %v", labelBase, err)
                }</span>
                // we don't pass in the list of local snaps here because they are
                // already represented by snapSetupTasks

                <span class="cov0" title="0">snapsupTaskIDs, compsupTaskIDs, err := setupTaskIDsForCreatingRecoverySystem(tss)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">createRecoveryTasks, err := createRecoverySystemTasks(st, label, snapsupTaskIDs, compsupTaskIDs, CreateRecoverySystemOptions{
                        TestSystem: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if lastDownloadInChain != nil </span><span class="cov0" title="0">{
                        // wait for all snaps that need to be downloaded
                        createRecoveryTasks.WaitFor(lastDownloadInChain)
                }</span>
                <span class="cov0" title="0">if firstInstallInChain != nil </span><span class="cov0" title="0">{
                        // when any snap installations need to happen, they
                        // should also wait for recovery system to be created
                        firstInstallInChain.WaitAll(createRecoveryTasks)
                }</span>
                <span class="cov0" title="0">tss = append(tss, createRecoveryTasks)
                recoverySetupTaskID = createRecoveryTasks.Tasks()[0].ID()</span>
        }

        // Set the new model assertion - this *must* be the last thing done
        // by the change.
        <span class="cov0" title="0">setModel := st.NewTask("set-model", i18n.G("Set new model assertion"))
        for _, tsPrev := range tss </span><span class="cov0" title="0">{
                setModel.WaitAll(tsPrev)
        }</span>
        <span class="cov0" title="0">if recoverySetupTaskID != "" </span><span class="cov0" title="0">{
                // set model needs to access information about the recovery
                // system
                setModel.Set("recovery-system-setup-task", recoverySetupTaskID)
        }</span>
        <span class="cov0" title="0">tss = append(tss, state.NewTaskSet(setModel))

        // Ensure correct restart boundaries are set on the new task-set.
        if err := snapstate.SetEssentialSnapsRestartBoundaries(st, deviceCtx, tss); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tss, nil</span>
}

func checkRequiredGadgetMatchesModelBase(model *asserts.Model, tracker *snap.SelfContainedSetPrereqTracker) error <span class="cov0" title="0">{
        modelBase := model.Base()
        if modelBase == "" </span><span class="cov0" title="0">{
                modelBase = "core"
        }</span>

        <span class="cov0" title="0">for _, sn := range tracker.Snaps() </span><span class="cov0" title="0">{
                if sn.Type() != snap.TypeGadget </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gadgetBase := sn.Base
                if gadgetBase == "" </span><span class="cov0" title="0">{
                        gadgetBase = "core"
                }</span>

                <span class="cov0" title="0">if gadgetBase != modelBase </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot remodel with gadget snap that has a different base than the model: %q != %q", gadgetBase, modelBase)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func verifyModelValidationSets(st *state.State, newModel *asserts.Model, offline bool, deviceCtx snapstate.DeviceContext) (*snapasserts.ValidationSets, error) <span class="cov0" title="0">{
        vSets, err := assertstate.ValidationSetsFromModel(st, newModel, assertstate.FetchValidationSetsOptions{
                Offline: offline,
        }, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := checkForInvalidSnapsInModel(newModel, vSets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := checkForRequiredSnapsNotRequiredInModel(newModel, vSets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return vSets, nil</span>
}

func checkForRequiredSnapsNotRequiredInModel(model *asserts.Model, vSets *snapasserts.ValidationSets) error <span class="cov0" title="0">{
        snapsInModel := make(map[string]bool, len(model.RequiredWithEssentialSnaps()))
        for _, sn := range model.RequiredWithEssentialSnaps() </span><span class="cov0" title="0">{
                snapsInModel[sn.SnapName()] = true
        }</span>

        <span class="cov0" title="0">for _, sn := range vSets.RequiredSnaps() </span><span class="cov0" title="0">{
                if !snapsInModel[sn] </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required snap in model: %s", sn)
                }</span>
        }

        // TODO:COMPS: consider relationship with required components here

        <span class="cov0" title="0">return nil</span>
}

func checkForInvalidSnapsInModel(model *asserts.Model, vSets *snapasserts.ValidationSets) error <span class="cov0" title="0">{
        if len(vSets.Keys()) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, sn := range model.AllSnaps() </span><span class="cov0" title="0">{
                pres, err := vSets.Presence(sn)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if pres.Presence == asserts.PresenceInvalid </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap presence is marked invalid by validation set: %s", sn.SnapName())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func checkForSystemSeed(st *state.State, deviceCtx snapstate.DeviceContext) (bool, error) <span class="cov0" title="0">{
        // on non-classic systems, we will always have a seed partition. this check
        // isn't needed, but it makes testing classic systems simpler.
        if !deviceCtx.Classic() </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">gadgetData, err := CurrentGadgetData(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot get gadget data: %w", err)
        }</span>

        <span class="cov0" title="0">return gadgetData.Info.HasRole(gadget.SystemSeed), nil</span>
}

// RemodelOptions are options for Remodel.
type RemodelOptions struct {
        // Offline is true if the remodel should be done without reaching out to the
        // store. Any snaps needed for the remodel, that are not already installed,
        // should be provided via the parameters to Remodel. Snaps that are already
        // installed will be used if they match the revisions that are required by
        // the model.
        Offline         bool
        LocalSnaps      []snapstate.PathSnap
        LocalComponents []snapstate.PathComponent
}

// Remodel takes a new model assertion and generates a change that
// takes the device from the old to the new model or an error if the
// transition is not possible.
//
// TODO:
//   - Check estimated disk size delta
//   - Check all relevant snaps exist in new store
//     (need to check that even unchanged snaps are accessible)
//   - Make sure this works with Core 20 as well, in the Core 20 case
//     we must enforce the default-channels from the model as well
func Remodel(st *state.State, new *asserts.Model, opts RemodelOptions) (*state.Change, error) <span class="cov0" title="0">{
        var seeded bool
        err := st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel until fully seeded")
        }</span>

        <span class="cov0" title="0">if !opts.Offline &amp;&amp; (len(opts.LocalSnaps) &gt; 0 || len(opts.LocalComponents) &gt; 0) </span><span class="cov0" title="0">{
                return nil, errors.New("cannot do an online remodel with provided local snaps or components")
        }</span>

        <span class="cov0" title="0">for _, ls := range opts.LocalSnaps </span><span class="cov0" title="0">{
                if ls.Components != nil || ls.InstanceName != "" || ls.RevOpts != (snapstate.RevisionOptions{}) </span><span class="cov0" title="0">{
                        return nil, errors.New("internal error: locally provided snaps must only provide path and side info")
                }</span>
        }

        <span class="cov0" title="0">current, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">prevRev, err := findKnownRevisionOfModel(st, new)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if new.Revision() &lt; prevRev </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel to older revision %d of model %s/%s than last revision %d known to the device", new.Revision(), new.BrandID(), new.Model(), prevRev)
        }</span>

        // TODO: we need dedicated assertion language to permit for
        // model transitions before we allow cross vault
        // transitions.

        <span class="cov0" title="0">remodelKind := ClassifyRemodel(current, new)

        if _, err := findSerial(st, nil); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if opts.Offline &amp;&amp; remodelKind == UpdateRemodel </span>{<span class="cov0" title="0">
                        // it is allowed to remodel without serial for
                        // offline remodels that are update only
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("cannot remodel without a serial")
                }</span>
        }

        <span class="cov0" title="0">if current.Series() != new.Series() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel to different series yet")
        }</span>

        <span class="cov0" title="0">devCtx, err := DeviceCtx(st, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get device context: %v", err)
        }</span>

        <span class="cov0" title="0">if devCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel from classic (non-hybrid) model")
        }</span>

        <span class="cov0" title="0">if current.Classic() != new.Classic() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel across classic and non-classic models")
        }</span>

        // TODO:UC20: ensure we never remodel to a lower
        // grade

        // also disallow remodel from non-UC20 (grade unset) to UC20
        <span class="cov0" title="0">if current.Grade() != new.Grade() </span><span class="cov0" title="0">{
                if current.Grade() == asserts.ModelGradeUnset &amp;&amp; new.Grade() != asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                        // a case of pre-UC20 -&gt; UC20 remodel
                        return nil, fmt.Errorf("cannot remodel from pre-UC20 to UC20+ models")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot remodel from grade %v to grade %v", current.Grade(), new.Grade())</span>
        }

        <span class="cov0" title="0">if new.Base() == "" &amp;&amp; current.Base() != "" </span><span class="cov0" title="0">{
                return nil, errors.New("cannot remodel from UC18+ (using snapd snap) system back to UC16 system (using core snap)")
        }</span>

        // TODO: should we restrict remodel from one arch to another?
        // There are valid use-cases here though, i.e. amd64 machine that
        // remodels itself to/from i386 (if the HW can do both 32/64 bit)
        <span class="cov0" title="0">if current.Architecture() != new.Architecture() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel to different architectures yet")
        }</span>

        // calculate snap differences between the two models
        // FIXME: this needs work to switch from core-&gt;bases
        <span class="cov0" title="0">if current.Base() == "" &amp;&amp; new.Base() != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot remodel from core to bases yet")
        }</span>

        // Do we do this only for the more complicated cases (anything
        // more than adding required-snaps really)?
        <span class="cov0" title="0">if err := snapstate.CheckChangeConflictRunExclusively(st, "remodel"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">remodCtx, err := remodelCtx(st, current, new)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var tss []*state.TaskSet
        switch remodelKind </span>{
        case ReregRemodel:<span class="cov0" title="0">
                if opts.Offline </span><span class="cov0" title="0">{
                        // TODO support this in the future if a serial
                        // assertion has been provided by a file. To support
                        // this case, we will pass the snaps/paths by setting
                        // local-{snaps,paths} in the task.
                        return nil, fmt.Errorf("cannot remodel offline to different brand ID / model yet")
                }</span>
                <span class="cov0" title="0">requestSerial := st.NewTask("request-serial", i18n.G("Request new device serial"))

                prepare := st.NewTask("prepare-remodeling", i18n.G("Prepare remodeling"))
                prepare.WaitFor(requestSerial)
                ts := state.NewTaskSet(requestSerial, prepare)
                tss = []*state.TaskSet{ts}</span>
        case StoreSwitchRemodel:<span class="cov0" title="0">
                sto := remodCtx.Store()
                if sto == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("internal error: a store switch remodeling should have built a store")
                }</span>
                // ensure a new session accounting for the new brand store
                <span class="cov0" title="0">st.Unlock()
                err := sto.EnsureDeviceSession()
                st.Lock()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot get a store session based on the new model assertion: %v", err)
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case UpdateRemodel:<span class="cov0" title="0">
                // TODO: make this case follow the same pattern as ReregRemodel, where
                // we call remodelTasks from inside another task, so that the tasks for
                // the remodel are added to an existing and running change. this will
                // allow us to avoid things like calling snapstate.CheckChangeConflictRunExclusively again.
                var err error
                tss, err = remodelTasks(context.TODO(), st, current, new, remodCtx, "", opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // we potentially released the lock a couple of times here:
        // make sure the current model is essentially the same as when
        // we started
        <span class="cov0" title="0">current1, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if current.BrandID() != current1.BrandID() || current.Model() != current1.Model() || current.Revision() != current1.Revision() </span><span class="cov0" title="0">{
                return nil, &amp;snapstate.ChangeConflictError{Message: fmt.Sprintf("cannot start remodel, clashing with concurrent remodel to %v/%v (%v)", current1.BrandID(), current1.Model(), current1.Revision())}
        }</span>
        // make sure another unfinished remodel wasn't already setup either
        <span class="cov0" title="0">if chg := RemodelingChange(st); chg != nil </span><span class="cov0" title="0">{
                return nil, &amp;snapstate.ChangeConflictError{
                        Message:    "cannot start remodel, clashing with concurrent one",
                        ChangeKind: chg.Kind(),
                        ChangeID:   chg.ID(),
                }
        }</span>

        // check for exclusive changes again since we released the lock
        <span class="cov0" title="0">if err := snapstate.CheckChangeConflictRunExclusively(st, "remodel"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var msg string
        if current.BrandID() == new.BrandID() &amp;&amp; current.Model() == new.Model() </span><span class="cov0" title="0">{
                msg = fmt.Sprintf(i18n.G("Refresh model assertion from revision %v to %v"), current.Revision(), new.Revision())
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf(i18n.G("Remodel device to %v/%v (%v)"), new.BrandID(), new.Model(), new.Revision())
        }</span>

        <span class="cov0" title="0">chg := st.NewChange(remodelChangeKind, msg)
        remodCtx.Init(chg)
        for _, ts := range tss </span><span class="cov0" title="0">{
                chg.AddAll(ts)
        }</span>

        <span class="cov0" title="0">return chg, nil</span>
}

// RemodelingChange returns a remodeling change in progress, if there is one
func RemodelingChange(st *state.State) *state.Change <span class="cov0" title="0">{
        for _, chg := range st.Changes() </span><span class="cov0" title="0">{
                if !chg.IsReady() &amp;&amp; chg.Kind() == "remodel" </span><span class="cov0" title="0">{
                        return chg
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type recoverySystemSetup struct {
        // Label of the recovery system, selected when tasks are created
        Label string `json:"label"`
        // Directory inside the seed filesystem where the recovery system files
        // are kept, typically /run/mnt/ubuntu-seed/systems/&lt;label&gt;, set when
        // tasks are created
        Directory string `json:"directory"`
        // SnapSetupTasks is a list of task IDs that carry snap setup information.
        // Tasks could come from a remodel, or from downloading snaps that were
        // required by a validation set.
        SnapSetupTasks []string `json:"snap-setup-tasks,omitempty"`
        // LocalSnaps is a list of snaps that should be used to create the recovery
        // system.
        LocalSnaps []snapstate.PathSnap `json:"local-snaps,omitempty"`
        // ComponentSetupTasks is a list of task IDs that carry component setup
        // information. Tasks could come from a remodel, or from downloading
        // components that were required by a validation set.
        ComponentSetupTasks []string `json:"component-setup-tasks,omitempty"`
        // LocalComponents is a list of components that should be used to create the
        // recovery system.
        LocalComponents []snapstate.PathComponent `json:"local-components,omitempty"`
        // TestSystem is set to true if the new recovery system should
        // not be verified by rebooting into the new system. Once the system is
        // created, it will immediately be considered a valid recovery system.
        TestSystem bool `json:"test-system,omitempty"`
        // MarkDefault is set to true if the new recovery system should be marked as
        // the default recovery system.
        MarkDefault bool `json:"mark-default,omitempty"`
}

func pickRecoverySystemLabel(labelBase string) (string, error) <span class="cov0" title="0">{
        systemDirectory := filepath.Join(boot.InitramfsUbuntuSeedDir, "systems", labelBase)
        exists, _, err := osutil.DirExists(systemDirectory)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return labelBase, nil
        }</span>
        // pick alternative, which is named like &lt;label&gt;-&lt;number&gt;
        <span class="cov0" title="0">present, err := filepath.Glob(systemDirectory + "-*")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">maxExistingNumber := 0
        for _, existingDir := range present </span><span class="cov0" title="0">{
                suffix := existingDir[len(systemDirectory)+1:]
                num, err := strconv.Atoi(suffix)
                if err != nil </span><span class="cov0" title="0">{
                        // non numerical suffix?
                        continue</span>
                }
                <span class="cov0" title="0">if num &gt; maxExistingNumber </span><span class="cov0" title="0">{
                        maxExistingNumber = num
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s-%d", labelBase, maxExistingNumber+1), nil</span>
}

type removeRecoverySystemSetup struct {
        Label string `json:"label"`
}

func removeRecoverySystemTasks(st *state.State, label string) (*state.TaskSet, error) <span class="cov0" title="0">{
        remove := st.NewTask("remove-recovery-system", fmt.Sprintf("Remove recovery system with label %q", label))
        remove.Set("remove-recovery-system-setup", &amp;removeRecoverySystemSetup{
                Label: label,
        })

        return state.NewTaskSet(remove), nil
}</span>

func createRecoverySystemTasks(st *state.State, label string, snapSetupTasks, compSetupTasks []string, opts CreateRecoverySystemOptions) (*state.TaskSet, error) <span class="cov0" title="0">{
        // precondition check, the directory should not exist yet
        systemDirectory := filepath.Join(boot.InitramfsUbuntuSeedDir, "systems", label)
        exists, _, err := osutil.DirExists(systemDirectory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("recovery system %q already exists", label)
        }</span>

        <span class="cov0" title="0">create := st.NewTask("create-recovery-system", fmt.Sprintf("Create recovery system with label %q", label))
        // the label we want
        create.Set("recovery-system-setup", &amp;recoverySystemSetup{
                Label:     label,
                Directory: systemDirectory,
                // IDs of the tasks carrying snap-setup
                SnapSetupTasks:      snapSetupTasks,
                ComponentSetupTasks: compSetupTasks,
                LocalSnaps:          opts.LocalSnaps,
                LocalComponents:     opts.LocalComponents,
                TestSystem:          opts.TestSystem,
                MarkDefault:         opts.MarkDefault,
        })

        ts := state.NewTaskSet(create)

        if opts.TestSystem </span><span class="cov0" title="0">{
                // Create recovery system requires us to boot into it before finalize
                restart.MarkTaskAsRestartBoundary(create, restart.RestartBoundaryDirectionDo)

                finalize := st.NewTask("finalize-recovery-system", fmt.Sprintf("Finalize recovery system with label %q", label))
                finalize.WaitFor(create)
                // finalize needs to know the label too
                finalize.Set("recovery-system-setup-task", create.ID())

                ts.AddTask(finalize)
        }</span>

        <span class="cov0" title="0">return ts, nil</span>
}

// LocalSnap is a pair of a snap.SideInfo and a path to the snap file on disk
// that is represented by the snap.SideInfo.
type LocalSnap struct {
        // SideInfo is the snap.SideInfo struct that represents a local snap that
        // will be used to create a recovery system or remodel the system.
        SideInfo *snap.SideInfo

        // Path is the path on disk to a snap that will be used to create a recovery
        // system or remodel the system.
        Path string
}

// CreateRecoverySystemOptions is the set of options that can be used with
// CreateRecoverySystem.
type CreateRecoverySystemOptions struct {
        // ValidationSets is a list of validation sets to use when creating the new
        // recovery system. If provided, all snaps used to create recovery system
        // will follow the constraints imposed by the validation sets. If required
        // snaps are not present on the system, and LocalSnapSideInfos is not
        // provided, then the snaps will be downloaded.
        ValidationSets []*asserts.ValidationSet

        // LocalSnaps is an optional list of snaps that will be used to create
        // the new recovery system. If provided, this list must contain any snap
        // that is not already installed that will be needed by the new recovery
        // system.
        LocalSnaps []snapstate.PathSnap

        // LocalComponents is an optional list of components that will be used to
        // create the new recovery system. If provided, this list must contain any
        // component that is not already installed that will be needed by the new
        // recovery system.
        LocalComponents []snapstate.PathComponent

        // TestSystem is set to true if the new recovery system should be verified
        // by rebooting into the new system, prior to marking it as a valid recovery
        // system. If false, the system will immediately be considered a valid
        // recovery system.
        TestSystem bool

        // MarkDefault is set to true if the new recovery system should be marked as
        // the default recovery system.
        MarkDefault bool

        // Offline is true if the recovery system should be created without reaching
        // out to the store. Offline must be set to true if LocalSnaps is provided.
        Offline bool
}

var ErrNoRecoverySystem = errors.New("recovery system does not exist")

// RemoveRecoverySystem removes the recovery system with the given label. The
// current recovery system cannot be removed.
func RemoveRecoverySystem(st *state.State, label string) (*state.Change, error) <span class="cov0" title="0">{
        if err := snapstate.CheckChangeConflictRunExclusively(st, "remove-recovery-system"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recoverySystemsDir := filepath.Join(boot.InitramfsUbuntuSeedDir, "systems")
        exists, _, err := osutil.DirExists(filepath.Join(recoverySystemsDir, label))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q not found: %w", label, ErrNoRecoverySystem)
        }</span>

        <span class="cov0" title="0">chg := st.NewChange(removeRecoverySystemChangeKind, fmt.Sprintf("Remove recovery system with label %q", label))

        removeTS, err := removeRecoverySystemTasks(st, label)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">chg.AddAll(removeTS)

        return chg, nil</span>
}

func checkForRequiredSnapsNotPresentInModel(model *asserts.Model, vSets *snapasserts.ValidationSets) error <span class="cov0" title="0">{
        snapsInModel := make(map[string]bool, len(model.AllSnaps()))
        for _, sn := range model.AllSnaps() </span><span class="cov0" title="0">{
                snapsInModel[sn.SnapName()] = true
        }</span>

        <span class="cov0" title="0">for _, sn := range vSets.RequiredSnaps() </span><span class="cov0" title="0">{
                if !snapsInModel[sn] </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required snap in model: %s", sn)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateRecoverySystem creates a new recovery system with the given label. See
// CreateRecoverySystemOptions for details on the options that can be provided.
func CreateRecoverySystem(st *state.State, label string, opts CreateRecoverySystemOptions) (*state.Change, error) <span class="cov0" title="0">{
        if err := snapstate.CheckChangeConflictRunExclusively(st, "create-recovery-system"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !opts.Offline &amp;&amp; (len(opts.LocalSnaps) &gt; 0 || len(opts.LocalComponents) &gt; 0) </span><span class="cov0" title="0">{
                return nil, errors.New("local snaps/components cannot be provided when creating a recovery system online")
        }</span>

        <span class="cov0" title="0">var seeded bool
        err := st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create new recovery systems until fully seeded")
        }</span>

        <span class="cov0" title="0">model, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">valsets, err := assertstate.TrackedEnforcedValidationSetsForModel(st, model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, vs := range opts.ValidationSets </span><span class="cov0" title="0">{
                valsets.Add(vs)
        }</span>

        <span class="cov0" title="0">if err := valsets.Conflict(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: this restriction should be lifted eventually (in the case that we
        // have a dangerous model), and we should fall back to using snap names in
        // places that IDs are used
        <span class="cov0" title="0">if err := checkForSnapIDs(model, opts.LocalSnaps); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // check that all snaps from the model are valid in the validation sets
        <span class="cov0" title="0">if err := checkForInvalidSnapsInModel(model, valsets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // the task that creates the recovery system doesn't know anything about
        // validation sets, so we cannot create systems with snaps that are not in
        // the model.
        <span class="cov0" title="0">if err := checkForRequiredSnapsNotPresentInModel(model, valsets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tracker := snap.NewSelfContainedSetPrereqTracker()

        validRevision := func(current snap.Revision, constraints snapasserts.PresenceConstraint) bool </span><span class="cov0" title="0">{
                return constraints.Revision.Unset() || current == constraints.Revision
        }</span>

        <span class="cov0" title="0">usedLocalSnaps := make([]snapstate.PathSnap, 0, len(opts.LocalSnaps))
        usedLocalComps := make([]snapstate.PathComponent, 0, len(opts.LocalComponents))

        var downloadTSS []*state.TaskSet
        for _, sn := range model.AllSnaps() </span><span class="cov0" title="0">{
                constraints, err := valsets.Presence(sn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">installed, currentRevision, err := installedSnapRevision(st, sn.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // we must consider the snap as required to create this recovery system
                // in a few cases:
                // * the snap is required by the model
                // * the snap is required by the validation sets
                // * the snap is optional in the model but already installed. we
                //   consider the snap required in this case because the task handler for
                //   create-recovery-system will use any optional snaps that are
                //   installed, regardless of the snap's revision. requiring this snap
                //   ensures that we get the correct revision with respect to any given
                //   validation sets.
                //
                // TODO: consider making create-recovery-system aware of validation
                // sets, allowing us to avoid requiring optional but installed snaps
                <span class="cov0" title="0">required := constraints.Presence == asserts.PresenceRequired || sn.Presence == "required" || installed
                if !required </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">installedSnapValid := installed &amp;&amp; validRevision(currentRevision, constraints.PresenceConstraint)

                // keep track of the components that need to either be given to us or
                // downloaded
                requiredComponents := make([]string, 0, len(sn.Components))

                for name, comp := range sn.Components </span><span class="cov0" title="0">{
                        compInstalled, currentCompRevision, err := installedComponentRevision(st, sn.Name, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">compConstraints := constraints.Component(name)

                        // we must consider the component as required to create this
                        // recovery system in a few cases:
                        // * the component is required by the model
                        // * the component is required by the validation sets
                        // * the component is optional in the model but already installed.
                        //   this is for the same reasons that we must consider the same case
                        //   for snaps above.
                        //
                        // TODO: consider making create-recovery-system aware of validation
                        // sets, allowing us to avoid requiring optional but installed components
                        required := comp.Presence == "required" || compConstraints.Presence == asserts.PresenceRequired || compInstalled
                        if !required </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // we must either download or have local components for all required
                        // components that are either not installed, installed at an invalid
                        // revision, or installed alongside a different snap revision. the
                        // last condition could be eliminated by creating a task that only
                        // downloads the missing snap-resource-pair assertion.
                        <span class="cov0" title="0">if compInstalled &amp;&amp; validRevision(currentCompRevision, compConstraints) &amp;&amp; installedSnapValid </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">requiredComponents = append(requiredComponents, name)</span>
                }

                <span class="cov0" title="0">switch </span>{
                case opts.Offline:<span class="cov0" title="0">
                        // offline case, everything must either already be installed or
                        // provided via the local snaps/components.

                        // even if the installed snap revision might be valid, we still
                        // should attempt to use the one that is provided by the caller.
                        //
                        // this matches what create-recovery-system does. it first checks
                        // for provided local snaps, and then falls back to the installed
                        // one.
                        info, localSnap, err := offlineSnapInfo(sn, constraints.Revision, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                if !errors.Is(err, errMissingLocalSnap) || !installedSnapValid </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">info, err = snapstate.CurrentInfo(st, sn.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                usedLocalSnaps = append(usedLocalSnaps, localSnap)
                        }</span>
                        <span class="cov0" title="0">tracker.Add(info)

                        for comp := range sn.Components </span><span class="cov0" title="0">{
                                cref := naming.NewComponentRef(sn.Name, comp)
                                rev := constraints.Component(comp).Revision

                                localComp, err := offlineComponentInfo(cref, rev, opts.LocalComponents)
                                if err != nil </span><span class="cov0" title="0">{
                                        // we only care if the component is present if it needs to
                                        // be provided.
                                        if strutil.ListContains(requiredComponents, comp) </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        usedLocalComps = append(usedLocalComps, localComp)
                                }</span>
                        }
                case installedSnapValid:<span class="cov0" title="0">
                        // online case, but the currently installed snap revision is valid
                        // in the given validation sets.

                        info, err := snapstate.CurrentInfo(st, sn.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">tracker.Add(info)

                        if len(requiredComponents) &gt; 0 </span><span class="cov0" title="0">{
                                // TODO: download somewhere other than the default snap blob dir.
                                ts, err := snapstateDownloadComponents(context.TODO(), st, sn.Name, requiredComponents, dirs.SnapBlobDir, snapstate.RevisionOptions{
                                        Channel:        sn.DefaultChannel,
                                        ValidationSets: valsets,
                                        Revision:       info.Revision,
                                }, snapstate.Options{
                                        PrereqTracker: tracker,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">downloadTSS = append(downloadTSS, ts)</span>
                        }
                default:<span class="cov0" title="0">
                        // TODO: this respects the passed in validation sets, but does not
                        // currently respect refresh-control style of constraining snap
                        // revisions.
                        //
                        // TODO: download somewhere other than the default snap blob dir.
                        ts, _, err := snapstateDownload(context.TODO(), st, sn.Name, requiredComponents, dirs.SnapBlobDir, snapstate.RevisionOptions{
                                Channel:        sn.DefaultChannel,
                                ValidationSets: valsets,
                        }, snapstate.Options{
                                PrereqTracker: tracker,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">downloadTSS = append(downloadTSS, ts)

                        // if we go in this branch, then we'll handle downloading snaps and
                        // components at the same time.
                        continue</span>
                }
        }

        <span class="cov0" title="0">warnings, errs := tracker.Check()
        for _, w := range warnings </span><span class="cov0" title="0">{
                logger.Noticef("create recovery system prerequisites warning: %v", w)
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                var builder strings.Builder
                builder.WriteString("cannot create recovery system from model that is not self-contained:")

                for _, err := range errs </span><span class="cov0" title="0">{
                        builder.WriteString("\n  - ")
                        builder.WriteString(err.Error())
                }</span>

                <span class="cov0" title="0">return nil, errors.New(builder.String())</span>
        }

        <span class="cov0" title="0">snapsupTaskIDs, compsupTaskIDs, err := setupTaskIDsForCreatingRecoverySystem(downloadTSS)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // here we make sure that we only include the local snaps/components that
        // are actually required.
        <span class="cov0" title="0">opts.LocalComponents = usedLocalComps
        opts.LocalSnaps = usedLocalSnaps

        chg := st.NewChange(createRecoverySystemChangeKind, fmt.Sprintf("Create new recovery system with label %q", label))
        createTS, err := createRecoverySystemTasks(st, label, snapsupTaskIDs, compsupTaskIDs, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">chg.AddAll(createTS)

        for _, ts := range downloadTSS </span><span class="cov0" title="0">{
                createTS.WaitAll(ts)
                chg.AddAll(ts)
        }</span>

        <span class="cov0" title="0">return chg, nil</span>
}

func checkForSnapIDs(model *asserts.Model, localSnaps []snapstate.PathSnap) error <span class="cov0" title="0">{
        for _, sn := range model.AllSnaps() </span><span class="cov0" title="0">{
                if sn.ID() == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot create recovery system from model with snap that has no snap id: %q", sn.Name)
                }</span>
        }

        <span class="cov0" title="0">for _, sn := range localSnaps </span><span class="cov0" title="0">{
                if sn.SideInfo.SnapID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot create recovery system from provided snap that has no snap id: %q", sn.SideInfo.RealName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

var errMissingLocalSnap = errors.New("missing snap from local snaps provided for offline creation of recovery system")

func offlineSnapInfo(sn *asserts.ModelSnap, rev snap.Revision, opts CreateRecoverySystemOptions) (*snap.Info, snapstate.PathSnap, error) <span class="cov0" title="0">{
        index := -1
        for i, si := range opts.LocalSnaps </span><span class="cov0" title="0">{
                if sn.ID() == si.SideInfo.SnapID </span><span class="cov0" title="0">{
                        index = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if index == -1 </span><span class="cov0" title="0">{
                return nil, snapstate.PathSnap{}, fmt.Errorf("%w: %q, rev %v", errMissingLocalSnap, sn.Name, rev)
        }</span>

        <span class="cov0" title="0">localSnap := opts.LocalSnaps[index]

        if !rev.Unset() &amp;&amp; rev != localSnap.SideInfo.Revision </span><span class="cov0" title="0">{
                return nil, snapstate.PathSnap{}, fmt.Errorf(
                        "snap %q does not match revision required by validation sets: %v != %v", localSnap.SideInfo.RealName, localSnap.SideInfo.Revision, rev,
                )
        }</span>

        <span class="cov0" title="0">s, err := snapfile.Open(localSnap.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, snapstate.PathSnap{}, err
        }</span>

        <span class="cov0" title="0">info, err := snap.ReadInfoFromSnapFile(s, localSnap.SideInfo)
        return info, localSnap, err</span>
}

func offlineComponentInfo(cref naming.ComponentRef, rev snap.Revision, comps []snapstate.PathComponent) (snapstate.PathComponent, error) <span class="cov0" title="0">{
        index := -1
        for i, si := range comps </span><span class="cov0" title="0">{
                if si.SideInfo.Component == cref </span><span class="cov0" title="0">{
                        index = i
                        break</span>
                }
        }
        <span class="cov0" title="0">if index == -1 </span><span class="cov0" title="0">{
                return snapstate.PathComponent{}, fmt.Errorf(
                        "missing component from local components provided for offline creation of recovery system: %q, rev %v", cref, rev,
                )
        }</span>

        <span class="cov0" title="0">comp := comps[index]

        if !rev.Unset() &amp;&amp; rev != comp.SideInfo.Revision </span><span class="cov0" title="0">{
                return snapstate.PathComponent{}, fmt.Errorf(
                        "component %q does not match revision required by validation sets: %v != %v", cref, comp.SideInfo.Revision, rev,
                )
        }</span>

        <span class="cov0" title="0">return comp, nil</span>
}

func installedSnapRevision(st *state.State, name string) (bool, snap.Revision, error) <span class="cov0" title="0">{
        var snapst snapstate.SnapState
        if err := snapstate.Get(st, name, &amp;snapst); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return false, snap.Revision{}, nil
                }</span>
                <span class="cov0" title="0">return false, snap.Revision{}, err</span>
        }
        <span class="cov0" title="0">return true, snapst.Current, nil</span>
}

func installedComponentRevision(st *state.State, snapName, compName string) (bool, snap.Revision, error) <span class="cov0" title="0">{
        var snapst snapstate.SnapState
        if err := snapstate.Get(st, snapName, &amp;snapst); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return false, snap.Revision{}, nil
                }</span>
                <span class="cov0" title="0">return false, snap.Revision{}, err</span>
        }

        <span class="cov0" title="0">csi := snapst.CurrentComponentSideInfo(naming.NewComponentRef(snapName, compName))
        if csi == nil </span><span class="cov0" title="0">{
                return false, snap.Revision{}, nil
        }</span>
        <span class="cov0" title="0">return true, csi.Revision, nil</span>
}

func setupTaskIDsForCreatingRecoverySystem(tss []*state.TaskSet) (snapsupTaskIDs, compsupTaskIDs []string, err error) <span class="cov0" title="0">{
        for _, ts := range tss </span><span class="cov0" title="0">{
                t := ts.MaybeEdge(snapstate.SnapSetupEdge)
                if t == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">snapsup, err := snapstate.TaskSnapSetup(t)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                // task sets that come from non-component-exclusive operations that
                // don't introduce any local modifications don't need to be considered,
                // since they won't impact how the recovery system is created.
                //
                // TODO: should snapstate.InstallComponents put a
                // LastBeforeLocalModificationsEdge on the task set that sets up all of
                // the profiles for the components? would eliminate the second half of
                // this check.
                <span class="cov0" title="0">if ts.MaybeEdge(snapstate.LastBeforeLocalModificationsEdge) == nil &amp;&amp; !snapsup.ComponentExclusiveOperation </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if !snapsup.ComponentExclusiveOperation </span><span class="cov0" title="0">{
                        snapsupTaskIDs = append(snapsupTaskIDs, t.ID())
                }</span>

                <span class="cov0" title="0">var compsups []string
                if err := t.Get("component-setup-tasks", &amp;compsups); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">compsupTaskIDs = append(compsupTaskIDs, compsups...)</span>
        }

        <span class="cov0" title="0">return snapsupTaskIDs, compsupTaskIDs, nil</span>
}

// OptionalContainers is used to define the snaps and components that are
// optional in a system's model, but can be installed when installing a system.
type OptionalContainers struct {
        // Snaps is a list of optional snap names that can be installed.
        Snaps []string `json:"snaps,omitempty"`
        // Components is a mapping of snap names to lists of optional components
        // names that can be installed.
        Components map[string][]string `json:"components,omitempty"`
}

// InstallFinish creates a change that will finish the install for the given
// label and volumes. This includes writing missing volume content, seting
// up the bootloader and installing the kernel.
func InstallFinish(st *state.State, label string, onVolumes map[string]*gadget.Volume, optionalContainers *OptionalContainers) (*state.Change, error) <span class="cov0" title="0">{
        if label == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot finish install with an empty system label")
        }</span>
        <span class="cov0" title="0">if onVolumes == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot finish install without volumes data")
        }</span>

        <span class="cov0" title="0">chg := st.NewChange(installStepFinishChangeKind, fmt.Sprintf("Finish setup of run system for %q", label))
        finishTask := st.NewTask("install-finish", fmt.Sprintf("Finish setup of run system for %q", label))
        finishTask.Set("system-label", label)
        finishTask.Set("on-volumes", onVolumes)
        if optionalContainers != nil </span><span class="cov0" title="0">{
                finishTask.Set("optional-install", *optionalContainers)
        }</span>
        <span class="cov0" title="0">chg.AddTask(finishTask)

        return chg, nil</span>
}

// InstallSetupStorageEncryption creates a change that will setup the
// storage encryption for the install of the given label and
// volumes.
func InstallSetupStorageEncryption(st *state.State, label string, onVolumes map[string]*gadget.Volume, volumesAuth *device.VolumesAuthOptions) (*state.Change, error) <span class="cov0" title="0">{
        if label == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot setup storage encryption with an empty system label")
        }</span>
        <span class="cov0" title="0">if onVolumes == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot setup storage encryption without volumes data")
        }</span>
        <span class="cov0" title="0">if volumesAuth != nil </span><span class="cov0" title="0">{
                if err := volumesAuth.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Auth data must be in memory to avoid leaking credentials.
                <span class="cov0" title="0">st.Cache(volumesAuthOptionsKey{label}, volumesAuth)</span>
        }

        <span class="cov0" title="0">chg := st.NewChange(installStepSetupStorageEncryptionChangeKind, fmt.Sprintf("Setup storage encryption for installing system %q", label))
        setupStorageEncryptionTask := st.NewTask("install-setup-storage-encryption", fmt.Sprintf("Setup storage encryption for installing system %q", label))
        setupStorageEncryptionTask.Set("system-label", label)
        setupStorageEncryptionTask.Set("on-volumes", onVolumes)
        if volumesAuth != nil </span><span class="cov0" title="0">{
                setupStorageEncryptionTask.Set("volumes-auth-required", true)
        }</span>
        <span class="cov0" title="0">chg.AddTask(setupStorageEncryptionTask)

        return chg, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2014-2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "context"
        "errors"
        "fmt"
        "runtime"
        "sort"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/client"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/i18n"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/devicestate/internal"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/seed"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/timings"
)

var errNothingToDo = errors.New("nothing to do")

var runtimeNumCPU = runtime.NumCPU

func installSeedSnap(st *state.State, sn *seed.Snap, flags snapstate.Flags, prqt snapstate.PrereqTracker) (*state.TaskSet, *snap.Info, error) <span class="cov0" title="0">{
        if sn.Required </span><span class="cov0" title="0">{
                flags.Required = true
        }</span>
        <span class="cov0" title="0">if sn.Classic </span><span class="cov0" title="0">{
                flags.Classic = true
        }</span>
        <span class="cov0" title="0">if sn.DevMode </span><span class="cov0" title="0">{
                flags.DevMode = true
        }</span>

        <span class="cov0" title="0">components := make([]snapstate.PathComponent, 0, len(sn.Components))
        for _, comp := range sn.Components </span><span class="cov0" title="0">{
                // Prevent reusing loop variable
                comp := comp
                components = append(components, snapstate.PathComponent{
                        Path:     comp.Path,
                        SideInfo: &amp;comp.CompSideInfo,
                })
        }</span>

        <span class="cov0" title="0">goal := snapstate.PathInstallGoal(snapstate.PathSnap{
                Path:       sn.Path,
                SideInfo:   sn.SideInfo,
                Components: components,
                RevOpts:    snapstate.RevisionOptions{Channel: sn.Channel},
        })
        info, ts, err := snapstate.InstallOne(context.Background(), st, goal, snapstate.Options{
                Flags:         flags,
                PrereqTracker: prqt,
                Seed:          true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return ts, info, nil</span>
}

func criticalTaskEdges(ts *state.TaskSet) (beginEdge, beforeHooksEdge, hooksEdge *state.Task, err error) <span class="cov0" title="0">{
        // we expect all three edges, or none (the latter is the case with config tasksets).
        beginEdge, err = ts.Edge(snapstate.BeginEdge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil
        }</span>
        <span class="cov0" title="0">beforeHooksEdge, err = ts.Edge(snapstate.BeforeHooksEdge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">hooksEdge, err = ts.Edge(snapstate.HooksEdge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">return beginEdge, beforeHooksEdge, hooksEdge, nil</span>
}

// maybeEnforceValidationSetsTask returns a task for tracking validation-sets. This may
// return nil if no validation-sets are present.
func maybeEnforceValidationSetsTask(st *state.State, model *asserts.Model, mode string) (*state.Task, error) <span class="cov0" title="0">{
        // Only enforce validation-sets in run-mode after installing all required snaps
        if mode != "run" </span><span class="cov0" title="0">{
                logger.Debugf("Postponing enforcement of validation-sets in mode %s", mode)
                return nil, nil
        }</span>

        // Encode validation-sets included in the seed
        <span class="cov0" title="0">db := assertstate.DB(st)
        as, err := db.FindMany(asserts.ValidationSetType, nil)
        if err != nil </span><span class="cov0" title="0">{
                // If none are included, then skip this
                if errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">vsKeys := make(map[string][]string)
        for _, a := range as </span><span class="cov0" title="0">{
                vsa := a.(*asserts.ValidationSet)
                vsKeys[vsa.SequenceKey()] = a.Ref().PrimaryKey
        }</span>

        // Set up pins from the model
        <span class="cov0" title="0">pins := make(map[string]int)
        for _, vs := range model.ValidationSets() </span><span class="cov0" title="0">{
                if vs.Sequence &gt; 0 </span><span class="cov0" title="0">{
                        pins[vs.SequenceKey()] = vs.Sequence
                }</span>
        }

        <span class="cov0" title="0">t := st.NewTask("enforce-validation-sets", i18n.G("Track validation sets"))
        t.Set("validation-set-keys", vsKeys)
        t.Set("pinned-sequence-numbers", pins)
        return t, nil</span>
}

func markSeededTask(st *state.State) *state.Task <span class="cov0" title="0">{
        return st.NewTask("mark-seeded", i18n.G("Mark system seeded"))
}</span>

func trivialSeeding(st *state.State) []*state.TaskSet <span class="cov0" title="0">{
        // give the internal core config a chance to run (even if core is
        // not used at all we put system configuration there)
        configTs := snapstate.ConfigureSnap(st, "core", 0)
        markSeeded := markSeededTask(st)
        markSeeded.WaitAll(configTs)
        return []*state.TaskSet{configTs, state.NewTaskSet(markSeeded)}
}</span>

func (m *DeviceManager) populateStateFromSeedImpl(tm timings.Measurer) ([]*state.TaskSet, error) <span class="cov0" title="0">{
        st := m.state
        // check that the state is empty
        var seeded bool
        err := st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if seeded </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot populate state: already seeded")
        }</span>

        <span class="cov0" title="0">preseed := m.preseed
        sysLabel, mode, err := m.seedLabelAndMode()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">hasModeenv := false
        if mode != "" </span><span class="cov0" title="0">{
                hasModeenv = true
        }</span> else<span class="cov0" title="0"> {
                mode = "run"
        }</span>

        <span class="cov0" title="0">var deviceSeed seed.Seed
        // ack all initial assertions
        timings.Run(tm, "import-assertions[finish]", "finish importing assertions from seed", func(nested timings.Measurer) </span><span class="cov0" title="0">{
                isCoreBoot := hasModeenv || !release.OnClassic
                deviceSeed, err = m.importAssertionsFromSeed(mode, isCoreBoot)
        }</span>)
        <span class="cov0" title="0">if err != nil &amp;&amp; err != errNothingToDo </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err == errNothingToDo </span><span class="cov0" title="0">{
                return trivialSeeding(st), nil
        }</span>

        <span class="cov0" title="0">timings.Run(tm, "load-verified-snap-metadata", "load verified snap metadata from seed", func(nested timings.Measurer) </span><span class="cov0" title="0">{
                err = deviceSeed.LoadMeta(mode, nil, nested)
        }</span>)
        // ErrNoMeta can happen only with Core 16/18-style seeds
        <span class="cov0" title="0">if err == seed.ErrNoMeta &amp;&amp; release.OnClassic </span><span class="cov0" title="0">{
                if preseed </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no snaps to preseed")
                }</span>
                // on classic it is ok to not seed any snaps
                <span class="cov0" title="0">return trivialSeeding(st), nil</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">model := deviceSeed.Model()

        essentialSeedSnaps := deviceSeed.EssentialSnaps()
        seedSnaps, err := deviceSeed.ModeSnaps(mode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tsAll := []*state.TaskSet{}
        configTss := []*state.TaskSet{}

        var lastBeforeHooksTask *state.Task
        var chainTs func(all []*state.TaskSet, ts *state.TaskSet) []*state.TaskSet

        var preseedDoneTask *state.Task
        if preseed </span><span class="cov0" title="0">{
                preseedDoneTask = st.NewTask("mark-preseeded", i18n.G("Mark system pre-seeded"))
        }</span>

        <span class="cov0" title="0">chainTsPreseeding := func(all []*state.TaskSet, ts *state.TaskSet) []*state.TaskSet </span><span class="cov0" title="0">{
                // mark-preseeded task needs to be inserted between preliminary setup and hook tasks
                beginTask, beforeHooksTask, hooksTask, err := criticalTaskEdges(ts)
                if err != nil </span><span class="cov0" title="0">{
                        // XXX: internal error?
                        panic(err)</span>
                }
                // we either have all edges or none
                <span class="cov0" title="0">if beginTask != nil </span><span class="cov0" title="0">{
                        // hooks must wait for mark-preseeded
                        hooksTask.WaitFor(preseedDoneTask)
                        if n := len(all); n &gt; 0 </span><span class="cov0" title="0">{
                                // the first hook of the snap waits for all tasks of previous snap
                                hooksTask.WaitAll(all[n-1])
                        }</span>
                        <span class="cov0" title="0">if lastBeforeHooksTask != nil </span><span class="cov0" title="0">{
                                beginTask.WaitFor(lastBeforeHooksTask)
                        }</span>
                        <span class="cov0" title="0">preseedDoneTask.WaitFor(beforeHooksTask)
                        lastBeforeHooksTask = beforeHooksTask</span>
                } else<span class="cov0" title="0"> {
                        n := len(all)
                        // no edges: it is a configure snap taskset for core/gadget/kernel
                        if n != 0 </span><span class="cov0" title="0">{
                                ts.WaitAll(all[n-1])
                        }</span>
                }
                <span class="cov0" title="0">return append(all, ts)</span>
        }

        <span class="cov0" title="0">chainTsFullSeeding := func(all []*state.TaskSet, ts *state.TaskSet) []*state.TaskSet </span><span class="cov0" title="0">{
                n := len(all)
                if n != 0 </span><span class="cov0" title="0">{
                        ts.WaitAll(all[n-1])
                }</span>
                <span class="cov0" title="0">return append(all, ts)</span>
        }

        <span class="cov0" title="0">if preseed </span><span class="cov0" title="0">{
                chainTs = chainTsPreseeding
        }</span> else<span class="cov0" title="0"> {
                chainTs = chainTsFullSeeding
        }</span>

        <span class="cov0" title="0">chainSorted := func(infos []*snap.Info, infoToTs map[*snap.Info]*state.TaskSet) </span><span class="cov0" title="0">{
                // This is the order in which snaps will be installed in the
                // system. We want the boot base to be installed before the
                // kernel so any existing kernel hook can execute with the boot
                // base as rootfs.
                effectiveType := func(info *snap.Info) snap.Type </span><span class="cov0" title="0">{
                        typ := info.Type()
                        if info.RealName == model.Base() </span><span class="cov0" title="0">{
                                typ = snap.InternalTypeBootBase
                        }</span>
                        <span class="cov0" title="0">return typ</span>
                }
                <span class="cov0" title="0">sort.SliceStable(infos, func(i, j int) bool </span><span class="cov0" title="0">{
                        return effectiveType(infos[i]).SortsBefore(effectiveType(infos[j]))
                }</span>)

                <span class="cov0" title="0">for _, info := range infos </span><span class="cov0" title="0">{
                        ts := infoToTs[info]
                        tsAll = chainTs(tsAll, ts)
                }</span>
        }

        // collected snap infos
        <span class="cov0" title="0">infos := make([]*snap.Info, 0, len(essentialSeedSnaps)+len(seedSnaps))

        infoToTs := make(map[*snap.Info]*state.TaskSet, len(essentialSeedSnaps))

        prqt := snap.NewSelfContainedSetPrereqTracker()

        if len(essentialSeedSnaps) != 0 </span><span class="cov0" title="0">{
                // we *always* configure "core" here even if bases are used
                // for booting. "core" is where the system config lives.
                configTss = chainTs(configTss, snapstate.ConfigureSnap(st, "core", snapstate.UseConfigDefaults))
        }</span>

        <span class="cov0" title="0">modelIsDangerous := model.Grade() == asserts.ModelDangerous

        essentialLane := st.NewLane()
        for _, seedSnap := range essentialSeedSnaps </span><span class="cov0" title="0">{
                flags := snapstate.Flags{
                        SkipConfigure: true,
                        // The kernel is already there either from ubuntu-image or from "install"
                        // mode so skip extract.
                        SkipKernelExtraction: true,
                        // for dangerous models, allow all devmode snaps
                        // XXX: eventually we may need to allow specific snaps to be devmode for
                        // non-dangerous models, we can do that here since that information will
                        // probably be in the model assertion which we have here
                        ApplySnapDevMode: modelIsDangerous,
                        Lane:             essentialLane,
                        Transaction:      client.TransactionAllSnaps,
                }

                ts, info, err := installSeedSnap(st, seedSnap, flags, prqt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if info.Type() == snap.TypeKernel || info.Type() == snap.TypeGadget </span><span class="cov0" title="0">{
                        configTs := snapstate.ConfigureSnap(st, info.SnapName(), snapstate.UseConfigDefaults)
                        // wait for the previous configTss
                        configTss = chainTs(configTss, configTs)
                }</span>
                <span class="cov0" title="0">infos = append(infos, info)
                infoToTs[info] = ts</span>
        }
        // now add/chain the tasksets in the right order based on essential
        // snap types
        <span class="cov0" title="0">chainSorted(infos, infoToTs)

        // chain together configuring core, kernel, and gadget after
        // installing them so that defaults are available from gadget
        if len(configTss) &gt; 0 </span><span class="cov0" title="0">{
                if preseed </span><span class="cov0" title="0">{
                        configTss[0].WaitFor(preseedDoneTask)
                }</span>
                <span class="cov0" title="0">configTss[0].WaitAll(tsAll[len(tsAll)-1])
                tsAll = append(tsAll, configTss...)</span>
        }

        // all of the configure tasks are related to essential snaps, so they should
        // also be in the essential snap lane
        <span class="cov0" title="0">for _, ts := range configTss </span><span class="cov0" title="0">{
                ts.JoinLane(essentialLane)
        }</span>

        // ensure we install in the right order
        <span class="cov0" title="0">infoToTs = make(map[*snap.Info]*state.TaskSet, len(seedSnaps))

        // note, we use separate lanes for essential and non-essential snaps so that
        // failures installing non-essential snaps do not cause essential snap
        // installations to be undone.
        nonEssentialLane := st.NewLane()
        for _, seedSnap := range seedSnaps </span><span class="cov0" title="0">{
                flags := snapstate.Flags{
                        // for dangerous models, allow all devmode snaps
                        // XXX: eventually we may need to allow specific snaps to be devmode for
                        // non-dangerous models, we can do that here since that information will
                        // probably be in the model assertion which we have here
                        ApplySnapDevMode: modelIsDangerous,
                        // for non-dangerous models snaps need to opt-in explicitly
                        // Classic is simply ignored for non-classic snaps, so we do not need to check further
                        Classic:     release.OnClassic &amp;&amp; modelIsDangerous,
                        Lane:        nonEssentialLane,
                        Transaction: client.TransactionAllSnaps,
                }

                ts, info, err := installSeedSnap(st, seedSnap, flags, prqt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">infos = append(infos, info)
                infoToTs[info] = ts</span>
        }

        // validate that all snaps have bases and providers are fulfilled
        // using the PrereqTracker
        <span class="cov0" title="0">warns, errs := prqt.Check()
        if errs != nil </span><span class="cov0" title="0">{
                // only report the first error encountered
                return nil, errs[0]
        }</span>
        // XXX do better, use the warnings to setup checks at end of the seeding
        // and log only plug not connected or explicitly disconnected there
        <span class="cov0" title="0">for _, w := range warns </span><span class="cov0" title="0">{
                logger.Noticef("seed prerequisites: %v", w)
        }</span>

        // now add/chain the tasksets in the right order, note that we
        // only have tasksets that we did not already seeded
        <span class="cov0" title="0">chainSorted(infos[len(essentialSeedSnaps):], infoToTs)

        if len(tsAll) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot proceed, no snaps to seed")
        }</span>

        // ts is the taskset of the last snap
        <span class="cov0" title="0">ts := tsAll[len(tsAll)-1]
        endTs := state.NewTaskSet()

        // Start tracking any validation sets included in the seed after
        // installing the included snaps.
        if trackVss, err := maybeEnforceValidationSetsTask(st, model, mode); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> if trackVss != nil </span><span class="cov0" title="0">{
                trackVss.WaitAll(ts)

                // if this validation fails, we want to undo the tasks in the
                // non-essential lane.
                //
                // TODO: currently, undoing seeding the essential set of snaps does not
                // work properly. that's why we only add this to the non-essential lane.
                trackVss.JoinLane(nonEssentialLane)

                endTs.AddTask(trackVss)
        }</span>

        <span class="cov0" title="0">markSeeded := markSeededTask(st)
        if preseed </span><span class="cov0" title="0">{
                endTs.AddTask(preseedDoneTask)
        }</span>
        <span class="cov0" title="0">whatSeeds := &amp;seededSystem{
                System:    sysLabel,
                Model:     model.Model(),
                BrandID:   model.BrandID(),
                Revision:  model.Revision(),
                Timestamp: model.Timestamp(),
        }
        markSeeded.Set("seed-system", whatSeeds)

        // mark-seeded waits for the taskset of last snap, and
        // for all the tasks in the endTs as well.
        markSeeded.WaitAll(ts)
        markSeeded.WaitAll(endTs)
        endTs.AddTask(markSeeded)
        tsAll = append(tsAll, endTs)

        return tsAll, nil</span>
}

func (m *DeviceManager) importAssertionsFromSeed(mode string, isCoreBoot bool) (seed.Seed, error) <span class="cov0" title="0">{
        st := m.state

        // TODO: use some kind of context for Device/SetDevice?
        device, err := internal.Device(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // collect and
        // set device,model from the model assertion
        <span class="cov0" title="0">_, deviceSeed, err := m.earlyLoadDeviceSeed(nil)
        if err == seed.ErrNoAssertions &amp;&amp; !isCoreBoot </span><span class="cov0" title="0">{
                // if classic boot seeding is optional
                // set the fallback model
                err := setClassicFallbackModel(st, device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, errNothingToDo</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">modelAssertion := deviceSeed.Model()

        if release.OnClassic &amp;&amp; !modelAssertion.Classic() </span><span class="cov0" title="0">{
                return nil, errors.New("cannot seed a classic system with an all-snaps model")
        }</span>

        <span class="cov0" title="0">if !release.OnClassic &amp;&amp; modelAssertion.Classic() &amp;&amp; mode != "recover" </span><span class="cov0" title="0">{
                return nil, errors.New("can only seed an all-snaps system with a classic model in recovery mode")
        }</span>

        // set device,model from the model assertion
        <span class="cov0" title="0">if err := setDeviceFromModelAssertion(st, device, modelAssertion); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return deviceSeed, nil</span>
}

// processAutoImportAssertions attempts to load the auto import assertions
// and create all knows system users, if and only if the model grade is dangerous.
// Processing of the auto-import assertion is opportunistic and can fail
// for example if system-user-as is serial bound and there is no serial-as yet
func processAutoImportAssertions(st *state.State, deviceSeed seed.Seed, db asserts.RODatabase, commitTo func(batch *asserts.Batch) error) error <span class="cov0" title="0">{
        // only proceed for dangerous model
        if deviceSeed.Model().Grade() != asserts.ModelDangerous </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">seed20AssertionsLoader, ok := deviceSeed.(seed.AutoImportAssertionsLoaderSeed)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to auto-import assertions, invalid loader")
        }</span>
        <span class="cov0" title="0">err := seed20AssertionsLoader.LoadAutoImportAssertions(commitTo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // automatic user creation is meant to imply sudoers
        <span class="cov0" title="0">const sudoer = true
        _, err = createAllKnownSystemUsers(st, db, deviceSeed.Model(), nil, sudoer)
        return err</span>
}

// loadDeviceSeed loads the seed based on sysLabel,
// It is meant to be called by DeviceManager.earlyLoadDeviceSeed.
var loadDeviceSeed = func(st *state.State, sysLabel string) (deviceSeed seed.Seed, err error) <span class="cov8" title="1">{
        deviceSeed, err = seed.Open(dirs.SnapSeedDir, sysLabel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if runtimeNumCPU() &gt; 1 </span><span class="cov8" title="1">{
                // XXX set parallelism experimentally to 2 as I/O
                // itself becomes a bottleneck ultimately
                deviceSeed.SetParallelism(2)
        }</span>

        // collect and
        // set device,model from the model assertion
        <span class="cov8" title="1">commitTo := func(batch *asserts.Batch) error </span><span class="cov0" title="0">{
                return assertstate.AddBatch(st, batch, nil)
        }</span>

        <span class="cov8" title="1">if err := deviceSeed.LoadAssertions(assertstate.DB(st), commitTo); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return deviceSeed, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2016-2020 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "errors"
        "fmt"
        "time"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/interfaces"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
)

func (m *DeviceManager) doMarkPreseeded(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        systemKey, err := interfaces.RecordedSystemKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get recorded system key: %v", err)
        }</span>

        <span class="cov0" title="0">if m.preseed </span><span class="cov0" title="0">{
                var preseeded bool
                // the "preseeded" flag on this task is set to allow skipping the logic
                // below in case this handler is retried in preseeding mode due to an
                // EnsureBefore(0) done somewhere else.
                // XXX: we should probably drop the flag from the task now that we have
                // one on the state.
                if err := t.Get("preseeded", &amp;preseeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !preseeded </span><span class="cov0" title="0">{
                        preseeded = true
                        t.Set("preseeded", preseeded)

                        if err := snapstate.UnmountAllSnaps(st); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">st.Set("preseeded", preseeded)
                        st.Set("preseed-system-key", systemKey)
                        st.Set("preseed-time", timeNow())

                        // do not mark this task done as this makes it racy against taskrunner tear down (the next task
                        // could start). Let this task finish after snapd restart when preseed mode is off.
                        restart.Request(st, restart.StopDaemon, nil)</span>
                }

                <span class="cov0" title="0">return &amp;state.Retry{Reason: "mark-preseeded will be marked done when snapd is executed in normal mode"}</span>
        }

        // normal snapd run after snapd restart (not in preseed mode anymore)

        <span class="cov0" title="0">st.Set("seed-restart-system-key", systemKey)
        if err := m.setTimeOnce("seed-restart-time", startTime); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type seededSystem struct {
        // System carries the recovery system label that was used to seed the
        // current system
        System string `json:"system"`
        Model  string `json:"model"`
        // BrandID is the brand account ID
        BrandID string `json:"brand-id"`
        // Revision of the model assertion
        Revision int `json:"revision"`
        // Timestamp of model assertion
        Timestamp time.Time `json:"timestamp"`
        // SeedTime holds the timestamp when the system was seeded
        SeedTime time.Time `json:"seed-time"`
}

func (s *seededSystem) sameAs(other *seededSystem) bool <span class="cov0" title="0">{
        // in theory the system labels are unique, however be extra paranoid and
        // check all model related fields too
        return s.System == other.System &amp;&amp;
                s.Model == other.Model &amp;&amp;
                s.BrandID == other.BrandID &amp;&amp;
                s.Revision == other.Revision
}</span>

func (m *DeviceManager) recordSeededSystem(st *state.State, whatSeeded *seededSystem) error <span class="cov0" title="0">{
        var seeded []seededSystem
        if err := st.Get("seeded-systems", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, sys := range seeded </span><span class="cov0" title="0">{
                if sys.sameAs(whatSeeded) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        // contrary to the usual approach of appending new entries to the list
        // like we do with modeenv, the recently seeded system is added at the
        // front, as it is not considered candidate like for the other entries,
        // but rather it describes the currently existing
        <span class="cov0" title="0">seeded = append([]seededSystem{*whatSeeded}, seeded...)
        st.Set("seeded-systems", seeded)
        return nil</span>
}

func (m *DeviceManager) doMarkSeeded(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        if m.preseed </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: mark-seeded task not expected in pre-seeding mode")
        }</span>

        <span class="cov0" title="0">deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %v", err)
        }</span>

        <span class="cov0" title="0">if deviceCtx.HasModeenv() &amp;&amp; deviceCtx.RunMode() </span><span class="cov0" title="0">{
                modeEnv, err := boot.MaybeReadModeenv()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing modeenv, cannot proceed")
                }</span>
                // unset recovery_system because that is only needed during install mode
                <span class="cov0" title="0">modeEnv.RecoverySystem = ""
                err = modeEnv.Write()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        var whatSeeded *seededSystem
        if err := t.Get("seed-system", &amp;whatSeeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if whatSeeded != nil &amp;&amp; deviceCtx.RunMode() </span><span class="cov0" title="0">{
                // record what seeded in the state only when in run mode
                whatSeeded.SeedTime = now
                if err := m.recordSeededSystem(st, whatSeeded); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot record the seeded system: %v", err)
                }</span>

                // since this is the most recently seeded system, it should also be the
                // default recovery system. this is important when coming back from a
                // factory-reset.
                <span class="cov0" title="0">st.Set("default-recovery-system", DefaultRecoverySystem{
                        System:          whatSeeded.System,
                        Model:           whatSeeded.Model,
                        BrandID:         whatSeeded.BrandID,
                        Revision:        whatSeeded.Revision,
                        Timestamp:       whatSeeded.Timestamp,
                        TimeMadeDefault: now,
                })</span>
        }
        <span class="cov0" title="0">st.Set("seed-time", now)
        st.Set("seeded", true)
        // avoid possibly recording the same system multiple times etc.
        t.SetStatus(state.DoneStatus)
        // make sure we setup a fallback model/consider the next phase
        // (registration) timely
        st.EnsureBefore(0)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2021 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "errors"
        "fmt"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
)

func (m *DeviceManager) doUpdateManagedBootConfig(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        devCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if devCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot run update boot config task on a classic system")
        }</span>

        <span class="cov0" title="0">var seeded bool
        err = st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                // do nothing during first boot &amp; seeding
                return nil
        }</span>

        <span class="cov0" title="0">if devCtx.Model().Grade() == asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                // pre UC20 system, do nothing
                return nil
        }</span>
        <span class="cov0" title="0">if devCtx.ForRemodeling() </span><span class="cov0" title="0">{
                // TODO:UC20: we may need to update the boot config when snapd
                // channel is changed during remodel
                return nil
        }</span>

        <span class="cov0" title="0">currentData, err := CurrentGadgetData(st, devCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot obtain current gadget data: %v", err)
        }</span>
        <span class="cov0" title="0">if currentData == nil </span><span class="cov0" title="0">{
                // we should be past seeding
                return fmt.Errorf("internal error: no current gadget")
        }</span>

        <span class="cov0" title="0">cmdlineAppend, err := buildAppendedKernelCommandLine(t, currentData, devCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot build appended kernel command line: %v", err)
        }</span>

        // TODO:UC20 update recovery boot config
        <span class="cov0" title="0">updated, err := boot.UpdateManagedBootConfigs(devCtx, currentData.RootDir, cmdlineAppend)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot update boot config assets: %v", err)
        }</span>

        // set this status already before returning to minimize wasteful redos
        <span class="cov0" title="0">finalStatus := state.DoneStatus
        if updated </span><span class="cov0" title="0">{
                t.Logf("updated boot config assets")
                // boot assets were updated, request a restart now so that the
                // situation does not end up more complicated if more updates of
                // boot assets were to be applied
                return snapstate.FinishTaskWithRestart(t, finalStatus, restart.RestartSystem, nil)
        }</span> else<span class="cov0" title="0"> {
                t.SetStatus(finalStatus)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2016-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/overlord/configstate/config"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/strutil"
)

func makeRollbackDir(name string) (string, error) <span class="cov0" title="0">{
        rollbackDir := filepath.Join(dirs.SnapRollbackDir, name)

        if err := os.MkdirAll(rollbackDir, 0750); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return rollbackDir, nil</span>
}

// CurrentGadgetData returns the GadgetData for the currently active gadget.
func CurrentGadgetData(st *state.State, curDeviceCtx snapstate.DeviceContext) (*gadget.GadgetData, error) <span class="cov0" title="0">{
        currentInfo, err := snapstate.GadgetInfo(st, curDeviceCtx)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if currentInfo == nil </span><span class="cov0" title="0">{
                // no current yet
                return nil, nil
        }</span>

        <span class="cov0" title="0">ci, err := gadgetDataFromInfo(currentInfo, curDeviceCtx.Model())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read current gadget snap details: %v", err)
        }</span>
        <span class="cov0" title="0">return ci, nil</span>
}

func pendingGadgetData(snapsup *snapstate.SnapSetup, pendingDeviceCtx snapstate.DeviceContext) (*gadget.GadgetData, error) <span class="cov0" title="0">{
        info, err := snap.ReadInfo(snapsup.InstanceName(), snapsup.SideInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read candidate gadget snap details: %v", err)
        }</span>

        <span class="cov0" title="0">gi, err := gadgetDataFromInfo(info, pendingDeviceCtx.Model())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read candidate snap gadget metadata: %v", err)
        }</span>
        <span class="cov0" title="0">return gi, nil</span>
}

var (
        gadgetUpdate = gadget.Update
)

func setGadgetRestartRequired(t *state.Task) <span class="cov0" title="0">{
        chg := t.Change()
        chg.Set("gadget-restart-required", true)
}</span>

func (m *DeviceManager) doUpdateGadgetAssets(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        snapsup, err := snapstate.TaskSnapSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">remodelCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if remodelCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot run update gadget assets task on a classic system")
        }</span>
        <span class="cov0" title="0">isRemodel := remodelCtx.ForRemodeling()
        groundDeviceCtx := remodelCtx.GroundContext()

        model := groundDeviceCtx.Model()
        if isRemodel </span><span class="cov0" title="0">{
                model = remodelCtx.Model()
        }</span>
        // be extra paranoid when checking we are installing the right gadget
        <span class="cov0" title="0">var updateData *gadget.GadgetData
        switch snapsup.Type </span>{
        case snap.TypeGadget:<span class="cov0" title="0">
                expectedGadgetSnap := model.Gadget()
                if snapsup.InstanceName() != expectedGadgetSnap </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot apply gadget assets update from non-model gadget snap %q, expected %q snap",
                                snapsup.InstanceName(), expectedGadgetSnap)
                }</span>

                <span class="cov0" title="0">updateData, err = pendingGadgetData(snapsup, remodelCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case snap.TypeKernel:<span class="cov0" title="0">
                expectedKernelSnap := model.Kernel()
                if snapsup.InstanceName() != expectedKernelSnap </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot apply kernel assets update from non-model kernel snap %q, expected %q snap",
                                snapsup.InstanceName(), expectedKernelSnap)
                }</span>

                // now calculate the "update" data, it's the same gadget but
                // argumented from a different kernel
                <span class="cov0" title="0">updateData, err = CurrentGadgetData(t.State(), groundDeviceCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("internal errror: doUpdateGadgetAssets called with snap type %v", snapsup.Type)</span>
        }

        <span class="cov0" title="0">currentData, err := CurrentGadgetData(t.State(), groundDeviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if currentData == nil </span><span class="cov0" title="0">{
                // no updates during first boot &amp; seeding
                return nil
        }</span>

        // Inject fault during the refresh of the gadget assets
        <span class="cov0" title="0">osutil.MaybeInjectFault("refresh-gadget-assets")

        // add kernel directories
        currentKernelInfo, err := snapstate.CurrentInfo(st, groundDeviceCtx.Model().Kernel())
        // XXX: switch to the normal `if err != nil { return err }` pattern
        // here once all tests are updated and have a kernel
        if err == nil </span><span class="cov0" title="0">{
                currentData.KernelRootDir = currentKernelInfo.MountDir()
                updateData.KernelRootDir = currentKernelInfo.MountDir()
        }</span>
        // if this is a gadget update triggered by an updated kernel we
        // need to ensure "updateData.KernelRootDir" points to the new kernel
        <span class="cov0" title="0">if snapsup.Type == snap.TypeKernel </span><span class="cov0" title="0">{
                updateKernelInfo, err := snap.ReadInfo(snapsup.InstanceName(), snapsup.SideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot read candidate kernel snap details: %v", err)
                }</span>
                <span class="cov0" title="0">updateData.KernelRootDir = updateKernelInfo.MountDir()</span>
        }

        <span class="cov0" title="0">snapRollbackDir, err := makeRollbackDir(fmt.Sprintf("%v_%v", snapsup.InstanceName(), snapsup.SideInfo.Revision))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot prepare update rollback directory: %v", err)
        }</span>

        <span class="cov0" title="0">var updatePolicy gadget.UpdatePolicyFunc = nil

        // Even with a remodel a kernel refresh only updates the kernel assets
        if snapsup.Type == snap.TypeKernel </span><span class="cov0" title="0">{
                updatePolicy = gadget.KernelUpdatePolicy
        }</span> else<span class="cov0" title="0"> if isRemodel </span><span class="cov0" title="0">{
                // use the remodel policy which triggers an update of all
                // structures
                updatePolicy = gadget.RemodelUpdatePolicy
        }</span>

        <span class="cov0" title="0">err = func() error </span><span class="cov0" title="0">{
                var updateObserver gadget.ContentUpdateObserver
                observeTrustedBootAssets, err := boot.TrustedAssetsUpdateObserverForModel(model, updateData.RootDir)
                if err != nil &amp;&amp; err != boot.ErrObserverNotApplicable </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot setup asset update observer: %v", err)
                }</span>
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        updateObserver = observeTrustedBootAssets
                        defer observeTrustedBootAssets.Done()
                }</span>
                // do not release the state lock, the update observer may
                // attempt to modify modeenv inside, which implicitly is
                // guarded by the state lock; on top of that we do not expect
                // the update to be moving large amounts of data
                <span class="cov0" title="0">if err := gadgetUpdate(model, *currentData, *updateData, snapRollbackDir, updatePolicy, updateObserver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if updateObserver == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return observeTrustedBootAssets.UpdateBootEntry()</span>
        }()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == gadget.ErrNoUpdate </span><span class="cov0" title="0">{
                        // no update needed
                        t.Logf("No gadget assets update needed")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := os.RemoveAll(snapRollbackDir); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Noticef("failed to remove gadget update rollback directory %q: %v", snapRollbackDir, err)
        }</span>

        // TODO: consider having the option to do this early via recovery in
        // core20, have fallback code as well there
        <span class="cov0" title="0">setGadgetRestartRequired(t)
        return snapstate.FinishTaskWithRestart(t, state.DoneStatus, restart.RestartSystem, nil)</span>
}

// fromSystemOption tells us if t was created when setting a system
// option for the kernel command line.
func fromSystemOption(t *state.Task) bool <span class="cov0" title="0">{
        for _, param := range []string{"cmdline-append", "dangerous-cmdline-append"} </span><span class="cov0" title="0">{
                if t.Has(param) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// kernelCommandLineAppendArgs returns extra arguments that we want to
// append to the kernel command line, searching first by looking at
// the task, and if not found, looking at the current configuration
// options. One thing or the other could happen depending on whether
// this is a task created when setting a kernel option or by gadget
// installation.
func kernelCommandLineAppendArgs(tsk *state.Task, tr *config.Transaction,
        taskParam string) (string, error) <span class="cov0" title="0">{

        var value string
        err := tsk.Get(taskParam, &amp;value)
        if err == nil </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var option string
        switch taskParam </span>{
        case "cmdline-append":<span class="cov0" title="0">
                option = "system.kernel.cmdline-append"</span>
        case "dangerous-cmdline-append":<span class="cov0" title="0">
                option = "system.kernel.dangerous-cmdline-append"</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("internal error, unexpected task parameter %q", taskParam)</span>
        }
        <span class="cov0" title="0">if err := tr.Get("core", option, &amp;value); err != nil &amp;&amp; !config.IsNoOption(err) </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

func buildAppendedKernelCommandLine(t *state.Task, gd *gadget.GadgetData, deviceCtx snapstate.DeviceContext) (string, error) <span class="cov0" title="0">{
        tr := config.NewTransaction(t.State())
        rawCmdlineAppend, err := kernelCommandLineAppendArgs(t, tr, "cmdline-append")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // Validation against allow list has already happened in
        // configcore, but the gadget might have changed, so we check
        // again and filter any unallowed argument.
        <span class="cov0" title="0">cmdlineAppend, forbidden := gadget.FilterKernelCmdline(rawCmdlineAppend, gd.Info.KernelCmdline.Allow)
        if forbidden != "" </span><span class="cov0" title="0">{
                warnMsg := fmt.Sprintf("%q is not allowed by the gadget and has been filtered out from the kernel command line", forbidden)
                logger.Notice(warnMsg)
                t.Logf(warnMsg)
        }</span>

        // Dangerous extra cmdline only considered for dangerous models
        <span class="cov0" title="0">if deviceCtx.Model().Grade() == asserts.ModelDangerous </span><span class="cov0" title="0">{
                cmdlineAppendDanger, err := kernelCommandLineAppendArgs(t, tr,
                        "dangerous-cmdline-append")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">cmdlineAppend = strutil.JoinNonEmpty(
                        []string{cmdlineAppend, cmdlineAppendDanger}, " ")</span>
        }

        <span class="cov0" title="0">logger.Debugf("appended kernel command line part is %q", cmdlineAppend)

        return cmdlineAppend, nil</span>
}

func (m *DeviceManager) updateGadgetCommandLine(t *state.Task, st *state.State, useCurrentGadget bool) (updated bool, err error) <span class="cov0" title="0">{
        logger.Debugf("updating kernel command line")
        devCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if devCtx.Model().Grade() == asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                // pre UC20 system, do nothing
                return false, nil
        }</span>
        <span class="cov0" title="0">var gadgetData *gadget.GadgetData
        if !useCurrentGadget </span><span class="cov0" title="0">{
                // command line comes from the new gadget when updating
                snapsup, err := snapstate.TaskSnapSetup(t)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">gadgetData, err = pendingGadgetData(snapsup, devCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        } else<span class="cov0" title="0"> {
                // but when undoing or when the change comes from a
                // system option (no setup task), we use the current
                // gadget (should have been restored in the undo case)
                currentGadgetData, err := CurrentGadgetData(st, devCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">gadgetData = currentGadgetData</span>
        }

        <span class="cov0" title="0">cmdlineAppend, err := buildAppendedKernelCommandLine(t, gadgetData, devCtx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">updated, err = boot.UpdateCommandLineForGadgetComponent(devCtx, gadgetData.RootDir, cmdlineAppend)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot update kernel command line from gadget: %v", err)
        }</span>
        <span class="cov0" title="0">if updated </span><span class="cov0" title="0">{
                setGadgetRestartRequired(t)
        }</span>
        <span class="cov0" title="0">return updated, nil</span>
}

func (m *DeviceManager) doUpdateGadgetCommandLine(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        devCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if devCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot run update gadget kernel command line task on a classic system")
        }</span>

        <span class="cov0" title="0">var seeded bool
        err = st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                // do nothing during first boot &amp; seeding
                return nil
        }</span>

        // Find out if the update has been triggered by setting a system
        // option that modifies the kernel command line.
        <span class="cov0" title="0">isSysOption := fromSystemOption(t)

        // We use the current gadget kernel command line if the change comes
        // from setting a system option.
        useCurrentGadget := isSysOption
        updated, err := m.updateGadgetCommandLine(t, st, useCurrentGadget)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                logger.Debugf("no kernel command line update from gadget")
                return nil
        }</span>
        <span class="cov0" title="0">t.Logf("Updated kernel command line")

        // TODO: consider optimization to avoid double reboot when the gadget
        // snap carries an update to the gadget assets and a change in the
        // kernel command line

        if isSysOption </span><span class="cov0" title="0">{
                logger.Debugf("change comes from system option, we do not reboot")
                t.SetStatus(state.DoneStatus)
                return nil
        }</span>

        // kernel command line was updated, request a reboot to make it effective
        <span class="cov0" title="0">return snapstate.FinishTaskWithRestart(t, state.DoneStatus, restart.RestartSystem, nil)</span>
}

func (m *DeviceManager) undoUpdateGadgetCommandLine(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        devCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if devCtx.IsClassicBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot run undo update gadget kernel command line task on a classic system")
        }</span>

        <span class="cov0" title="0">var seeded bool
        err = st.Get("seeded", &amp;seeded)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !seeded </span><span class="cov0" title="0">{
                // do nothing during first boot &amp; seeding
                return nil
        }</span>

        <span class="cov0" title="0">const isUndo = true
        updated, err := m.updateGadgetCommandLine(t, st, isUndo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                logger.Debugf("no kernel command line update to undo")
                return nil
        }</span>
        <span class="cov0" title="0">t.Logf("Reverted kernel command line change")

        // kernel command line was updated, request a reboot to make it effective
        return snapstate.FinishTaskWithRestart(t, state.UndoneStatus, restart.RestartSystem, nil)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2021-2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "bytes"
        "compress/gzip"
        "crypto"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"

        _ "golang.org/x/crypto/sha3"
        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/asserts/sysdb"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/bootloader"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/gadget/device"
        "github.com/snapcore/snapd/gadget/install"
        "github.com/snapcore/snapd/kernel"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/osutil/disks"
        "github.com/snapcore/snapd/overlord/fdestate"
        installLogic "github.com/snapcore/snapd/overlord/install"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/progress"
        "github.com/snapcore/snapd/secboot"
        "github.com/snapcore/snapd/secboot/keys"
        "github.com/snapcore/snapd/seed"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/snap/snapfile"
        "github.com/snapcore/snapd/systemd"
        "github.com/snapcore/snapd/timings"
)

var (
        bootMakeBootablePartition            = boot.MakeBootablePartition
        bootMakeRunnable                     = boot.MakeRunnableSystem
        bootMakeRunnableStandalone           = boot.MakeRunnableStandaloneSystem
        bootMakeRunnableAfterDataReset       = boot.MakeRunnableSystemAfterDataReset
        bootEnsureNextBootToRunMode          = boot.EnsureNextBootToRunMode
        bootMakeRecoverySystemBootable       = boot.MakeRecoverySystemBootable
        disksDMCryptUUIDFromMountPoint       = disks.DMCryptUUIDFromMountPoint
        installRun                           = install.Run
        installFactoryReset                  = install.FactoryReset
        installMountVolumes                  = install.MountVolumes
        installWriteContent                  = install.WriteContent
        installEncryptPartitions             = install.EncryptPartitions
        installSaveStorageTraits             = install.SaveStorageTraits
        installMatchDisksToGadgetVolumes     = install.MatchDisksToGadgetVolumes
        secbootStageEncryptionKeyChange      = secboot.StageEncryptionKeyChange
        secbootTransitionEncryptionKeyChange = secboot.TransitionEncryptionKeyChange
        secbootRemoveOldCounterHandles       = secboot.RemoveOldCounterHandles
        secbootTemporaryNameOldKeys          = secboot.TemporaryNameOldKeys
        fdestateGetRecoveryKey               = fdestate.GetRecoveryKey
        fdestateGenerateRecoveryKey          = fdestate.GenerateRecoveryKey

        installLogicPrepareRunSystemData = installLogic.PrepareRunSystemData
)

func writeLogs(rootdir string, fromMode string) error <span class="cov0" title="0">{
        // XXX: would be great to use native journal format but it's tied
        //      to machine-id, we could journal -o export but there
        //      is no systemd-journal-remote on core{,18,20}
        //
        // XXX: or only log if persistent journal is enabled?
        logPath := filepath.Join(rootdir, "var/log/install-mode.log.gz")
        if fromMode == "factory-reset" </span><span class="cov0" title="0">{
                logPath = filepath.Join(rootdir, "var/log/factory-reset-mode.log.gz")
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(logPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f, err := os.Create(logPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        gz := gzip.NewWriter(f)
        defer gz.Close()

        cmd := exec.Command("journalctl", "-b", "0", "--all")
        cmd.Stdout = gz
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot collect journal output: %v", err)
        }</span>
        <span class="cov0" title="0">if err := gz.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot flush compressed log output: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func writeTimings(st *state.State, rootdir, fromMode string) error <span class="cov0" title="0">{
        changeKind := "install-system"
        logPath := filepath.Join(rootdir, "var/log/install-timings.txt.gz")
        if fromMode == "factory-reset" </span><span class="cov0" title="0">{
                changeKind = "factory-reset"
                logPath = filepath.Join(rootdir, "var/log/factory-reset-timings.txt.gz")
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(logPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f, err := os.Create(logPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        gz := gzip.NewWriter(f)
        defer gz.Close()

        var chgIDs []string
        for _, chg := range st.Changes() </span><span class="cov0" title="0">{
                if chg.Kind() == "seed" || chg.Kind() == changeKind </span><span class="cov0" title="0">{
                        // this is captured via "--ensure=seed" and
                        // "--ensure=install-system" below
                        continue</span>
                }
                <span class="cov0" title="0">chgIDs = append(chgIDs, chg.ID())</span>
        }

        // state must be unlocked for "snap changes/debug timings" to work
        <span class="cov0" title="0">st.Unlock()
        defer st.Lock()

        // XXX: ugly, ugly, but using the internal timings requires
        //      some refactor as a lot of the required bits are not
        //      exported right now
        // first all changes
        fmt.Fprintf(gz, "---- Output of: snap changes\n")
        cmd := exec.Command("snap", "changes")
        cmd.Stdout = gz
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot collect timings output: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(gz, "\n")
        // then the seeding
        fmt.Fprintf(gz, "---- Output of snap debug timings --ensure=seed\n")
        cmd = exec.Command("snap", "debug", "timings", "--ensure=seed")
        cmd.Stdout = gz
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot collect timings output: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(gz, "\n")
        // then the install
        fmt.Fprintf(gz, "---- Output of snap debug timings --ensure=%v\n", changeKind)
        cmd = exec.Command("snap", "debug", "timings", fmt.Sprintf("--ensure=%v", changeKind))
        cmd.Stdout = gz
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot collect timings output: %v", err)
        }</span>
        // then the other changes (if there are any)
        <span class="cov0" title="0">for _, chgID := range chgIDs </span><span class="cov0" title="0">{
                fmt.Fprintf(gz, "---- Output of snap debug timings %s\n", chgID)
                cmd = exec.Command("snap", "debug", "timings", chgID)
                cmd.Stdout = gz
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot collect timings output: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(gz, "\n")</span>
        }

        <span class="cov0" title="0">if err := gz.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot flush timings output: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *DeviceManager) doSetupUbuntuSave(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %v", err)
        }</span>

        <span class="cov0" title="0">return m.setupUbuntuSave(deviceCtx)</span>
}

func (m *DeviceManager) doSetupRunSystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        // get gadget dir
        deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetInfo, err := snapstate.GadgetInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get gadget info: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetDir := gadgetInfo.MountDir()

        kernelInfo, err := snapstate.KernelInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get kernel info: %v", err)
        }</span>
        <span class="cov0" title="0">kernelDir := kernelInfo.MountDir()

        modeEnv, err := boot.MaybeReadModeenv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing modeenv, cannot proceed")
        }</span>

        // bootstrap
        <span class="cov0" title="0">bopts := install.Options{
                Mount: true,
        }
        encryptionType, err := m.checkEncryption(st, deviceCtx, secboot.TPMProvisionFull)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bopts.EncryptionType = encryptionType
        useEncryption := (encryptionType != device.EncryptionTypeNone)

        model := deviceCtx.Model()

        // make sure that gadget is usable for the set up we want to use it in
        validationConstraints := gadget.ValidationConstraints{
                EncryptedData: useEncryption,
        }
        var ginfo *gadget.Info
        timings.Run(perfTimings, "read-info-and-validate", "Read and validate gagdet info", func(timings.Measurer) </span><span class="cov0" title="0">{
                ginfo, err = gadget.ReadInfoAndValidate(gadgetDir, model, &amp;validationConstraints)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use gadget: %v", err)
        }</span>
        <span class="cov0" title="0">if err := gadget.ValidateContent(ginfo, gadgetDir, kernelDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use gadget: %v", err)
        }</span>

        <span class="cov0" title="0">installObserver, trustedInstallObserver, err := installLogic.BuildInstallObserver(model, gadgetDir, useEncryption)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var installedSystem *install.InstalledSystemSideData
        // run the create partition code
        logger.Noticef("create and deploy partitions")

        // Load seed to find out kernel-modules components in run mode
        systemAndSnaps, mntPtForType, mntPtForComps, unmount,
                err := m.loadAndMountSystemLabelSnapsUnlock(st, modeEnv.RecoverySystem, []snap.Type{snap.TypeKernel})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer unmount()

        kernMntPoint := mntPtForType[snap.TypeKernel]
        isCore := !deviceCtx.Classic()
        kBootInfo := kBootInfo(systemAndSnaps, kernMntPoint, mntPtForComps, isCore)

        timings.Run(perfTimings, "install-run", "Install the run system", func(tm timings.Measurer) </span><span class="cov0" title="0">{
                st.Unlock()
                defer st.Lock()
                installedSystem, err = installRun(model, gadgetDir, kBootInfo.KSnapInfo, "",
                        bopts, installObserver, tm)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot install system: %v", err)
        }</span>

        <span class="cov0" title="0">if trustedInstallObserver != nil </span><span class="cov0" title="0">{
                // We are required to call ObserveExistingTrustedRecoveryAssets on trusted observers
                if err := trustedInstallObserver.ObserveExistingTrustedRecoveryAssets(boot.InitramfsUbuntuSeedDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot observe existing trusted recovery assets: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if useEncryption </span><span class="cov0" title="0">{
                if err := installLogic.PrepareEncryptedSystemData(model, installedSystem.BootstrappedContainerForRole, nil, nil, trustedInstallObserver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := installLogicPrepareRunSystemData(model, gadgetDir, perfTimings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // make it bootable, which should be the final step in the process, as
        // it effectively makes it possible to boot into run mode
        <span class="cov0" title="0">logger.Noticef("make system runnable")
        bootBaseInfo, err := snapstate.BootBaseInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get boot base info: %v", err)
        }</span>
        <span class="cov0" title="0">bootWith := &amp;boot.BootableSet{
                Base:              bootBaseInfo,
                BasePath:          bootBaseInfo.MountFile(),
                Gadget:            gadgetInfo,
                GadgetPath:        gadgetInfo.MountFile(),
                Kernel:            kernelInfo,
                KernelPath:        kernelInfo.MountFile(),
                UnpackedGadgetDir: gadgetDir,

                RecoverySystemLabel: modeEnv.RecoverySystem,
                KernelMods:          kBootInfo.BootableKMods,
        }
        timings.Run(perfTimings, "boot-make-runnable", "Make target system runnable", func(timings.Measurer) </span><span class="cov0" title="0">{
                err = bootMakeRunnable(deviceCtx.Model(), bootWith, trustedInstallObserver)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot make system runnable: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RebootOptions can be attached to restart-system-to-run-mode tasks to control
// their restart behavior.
type RebootOptions struct {
        Op string `json:"op,omitempty"`
}

const (
        RebootHaltOp     = "halt"
        RebootPoweroffOp = "poweroff"
)

func (m *DeviceManager) doRestartSystemToRunMode(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        modeEnv, err := boot.MaybeReadModeenv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing modeenv, cannot proceed")
        }</span>

        <span class="cov0" title="0">deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %v", err)
        }</span>
        <span class="cov0" title="0">model := deviceCtx.Model()

        preseeded, err := maybeApplyPreseededData(model, boot.InitramfsUbuntuSeedDir, modeEnv.RecoverySystem, boot.InstallHostWritableDir(model))
        if err != nil </span><span class="cov0" title="0">{
                logger.Noticef("failed to apply preseed data: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">if preseeded </span><span class="cov0" title="0">{
                logger.Noticef("successfully preseeded the system")
        }</span> else<span class="cov0" title="0"> {
                logger.Noticef("preseed data not present, will do normal seeding")
        }</span>

        // if the model has a gadget snap, and said gadget snap has an install-device hook
        // call systemctl daemon-reload to account for any potential side-effects of that
        // install-device hook
        <span class="cov0" title="0">hasHook, err := m.hasInstallDeviceHook(model)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if hasHook </span><span class="cov0" title="0">{
                sd := systemd.New(systemd.SystemMode, progress.Null)
                if err := sd.DaemonReload(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // ensure the next boot goes into run mode
        <span class="cov0" title="0">if err := bootEnsureNextBootToRunMode(modeEnv.RecoverySystem); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var rebootOpts RebootOptions
        err = t.Get("reboot", &amp;rebootOpts)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        // write timing information
        <span class="cov0" title="0">if err := writeTimings(st, boot.InstallHostWritableDir(model), modeEnv.Mode); err != nil </span><span class="cov0" title="0">{
                logger.Noticef("cannot write timings: %v", err)
        }</span>
        // store install-mode log into ubuntu-data partition
        <span class="cov0" title="0">if err := writeLogs(boot.InstallHostWritableDir(model), modeEnv.Mode); err != nil </span><span class="cov0" title="0">{
                logger.Noticef("cannot write installation log: %v", err)
        }</span>

        // request by default a restart as the last action after a
        // successful install or what install-device requested via
        // snapctl reboot
        <span class="cov0" title="0">rst := restart.RestartSystemNow
        what := "restart"
        switch rebootOpts.Op </span>{
        case RebootHaltOp:<span class="cov0" title="0">
                what = "halt"
                rst = restart.RestartSystemHaltNow</span>
        case RebootPoweroffOp:<span class="cov0" title="0">
                what = "poweroff"
                rst = restart.RestartSystemPoweroffNow</span>
        }
        <span class="cov0" title="0">logger.Noticef("request immediate system %s", what)
        restart.Request(st, rst, nil)

        return nil</span>
}

var seedOpen = seed.Open

func maybeApplyPreseededData(model *asserts.Model, ubuntuSeedDir, sysLabel, writableDir string) (preseeded bool, err error) <span class="cov0" title="0">{
        sysSeed, err := seedOpen(ubuntuSeedDir, sysLabel)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // this function is for UC20+ only so sysSeed ia always PreseedCapable
        <span class="cov0" title="0">preseedSeed := sysSeed.(seed.PreseedCapable)

        if !preseedSeed.HasArtifact("preseed.tgz") </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if err := preseedSeed.LoadAssertions(nil, nil); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">_, sig := model.Signature()
        _, seedModelSig := preseedSeed.Model().Signature()
        if !bytes.Equal(sig, seedModelSig) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("system seed %q model does not match model in use", sysLabel)
        }</span>

        <span class="cov0" title="0">if err := applyPreseededData(preseedSeed, writableDir); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

var applyPreseededData = installLogic.ApplyPreseededData

func (m *DeviceManager) doFactoryResetRunSystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)
        // get gadget dir
        deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetInfo, err := snapstate.GadgetInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get gadget info: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetDir := gadgetInfo.MountDir()

        kernelInfo, err := snapstate.KernelInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get kernel info: %v", err)
        }</span>
        <span class="cov0" title="0">kernelDir := kernelInfo.MountDir()

        modeEnv, err := boot.MaybeReadModeenv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing modeenv, cannot proceed")
        }</span>

        // bootstrap
        <span class="cov0" title="0">bopts := install.Options{
                Mount: true,
        }
        encryptionType, err := m.checkEncryption(st, deviceCtx, secboot.TPMPartialReprovision)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bopts.EncryptionType = encryptionType
        useEncryption := (encryptionType != device.EncryptionTypeNone)
        hasMarker := device.HasEncryptedMarkerUnder(boot.InstallHostFDESaveDir)
        // TODO verify that the same encryption mechanism is used
        if hasMarker != useEncryption </span><span class="cov0" title="0">{
                prevStatus := "encrypted"
                if !hasMarker </span><span class="cov0" title="0">{
                        prevStatus = "unencrypted"
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot perform factory reset using different encryption, the original system was %v", prevStatus)</span>
        }

        <span class="cov0" title="0">model := deviceCtx.Model()

        // make sure that gadget is usable for the set up we want to use it in
        validationConstraints := gadget.ValidationConstraints{
                EncryptedData: useEncryption,
        }
        var ginfo *gadget.Info
        timings.Run(perfTimings, "read-info-and-validate", "Read and validate gagdet info", func(timings.Measurer) </span><span class="cov0" title="0">{
                ginfo, err = gadget.ReadInfoAndValidate(gadgetDir, model, &amp;validationConstraints)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use gadget: %v", err)
        }</span>
        <span class="cov0" title="0">if err := gadget.ValidateContent(ginfo, gadgetDir, kernelDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use gadget: %v", err)
        }</span>

        <span class="cov0" title="0">var trustedInstallObserver boot.TrustedAssetsInstallObserver
        // get a nice nil interface by default
        var installObserver gadget.ContentObserver
        trustedInstallObserver, err = boot.TrustedAssetsInstallObserverForModel(model, gadgetDir, useEncryption)
        if err != nil &amp;&amp; err != boot.ErrObserverNotApplicable </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot setup asset install observer: %v", err)
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                installObserver = trustedInstallObserver
                if !useEncryption </span><span class="cov0" title="0">{
                        // there will be no key sealing, so past the
                        // installation pass no other methods need to be called
                        trustedInstallObserver = nil
                }</span>
        }

        // Load seed to find out kernel-modules components in run mode
        <span class="cov0" title="0">systemAndSnaps, mntPtForType, mntPtForComps, unmount,
                err := m.loadAndMountSystemLabelSnapsUnlock(st, modeEnv.RecoverySystem, []snap.Type{snap.TypeKernel})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer unmount()

        kernMntPoint := mntPtForType[snap.TypeKernel]
        isCore := !deviceCtx.Classic()
        kBootInfo := kBootInfo(systemAndSnaps, kernMntPoint, mntPtForComps, isCore)

        // run the create partition code
        logger.Noticef("create and deploy partitions")
        var installedSystem *install.InstalledSystemSideData
        timings.Run(perfTimings, "factory-reset", "Factory reset", func(tm timings.Measurer) </span><span class="cov0" title="0">{
                st.Unlock()
                defer st.Lock()
                installedSystem, err = installFactoryReset(model, gadgetDir, kBootInfo.KSnapInfo,
                        "", bopts, installObserver, tm)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot perform factory reset: %v", err)
        }</span>
        <span class="cov0" title="0">logger.Noticef("devs: %+v", installedSystem.DeviceForRole)

        if trustedInstallObserver != nil </span><span class="cov0" title="0">{
                // We are required to call ObserveExistingTrustedRecoveryAssets on trusted observers
                if err := trustedInstallObserver.ObserveExistingTrustedRecoveryAssets(boot.InitramfsUbuntuSeedDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot observe existing trusted recovery assets: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if useEncryption </span><span class="cov0" title="0">{
                // at this point we removed boot and data. sealed fallback key
                // for ubuntu-data is becoming useless
                err := os.Remove(device.FallbackDataSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir))
                if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot cleanup obsolete key file: %v", err)
                }</span>

                // it is possible that we reached this place again where a
                // previously running factory reset was interrupted by a reboot
                <span class="cov0" title="0">err = os.Remove(device.FactoryResetFallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir))
                if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot cleanup obsolete key file: %v", err)
                }</span>

                // it is ok if the recovery key file on disk does not exist;
                // ubuntu-save was opened during boot, so the removal operation
                // can be authorized with a key from the keyring
                <span class="cov0" title="0">err = secbootRemoveRecoveryKeys(map[secboot.RecoveryKeyDevice]string{
                        {Mountpoint: boot.InitramfsUbuntuSaveDir}: device.RecoveryKeyUnder(boot.InstallHostFDEDataDir(model)),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot remove recovery key: %v", err)
                }</span>

                <span class="cov0" title="0">saveNode := installedSystem.DeviceForRole[gadget.SystemSave]
                if saveNode == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: no system-save device")
                }</span>

                <span class="cov0" title="0">uuid, err := disks.FilesystemUUID(saveNode)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot find uuid for partition %s: %v", saveNode, err)
                }</span>
                <span class="cov0" title="0">saveNode = fmt.Sprintf("/dev/disk/by-uuid/%s", uuid)

                saveBoostrapContainer, err := createSaveBootstrappedContainer(saveNode)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">installedSystem.BootstrappedContainerForRole[gadget.SystemSave] = saveBoostrapContainer

                if err := installLogic.PrepareEncryptedSystemData(model, installedSystem.BootstrappedContainerForRole, nil, nil, trustedInstallObserver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := installLogicPrepareRunSystemData(model, gadgetDir, perfTimings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := restoreDeviceFromSave(model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot restore data from save: %v", err)
        }</span>

        // make it bootable
        <span class="cov0" title="0">logger.Noticef("make system runnable")
        bootBaseInfo, err := snapstate.BootBaseInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get boot base info: %v", err)
        }</span>
        <span class="cov0" title="0">bootWith := &amp;boot.BootableSet{
                Base:              bootBaseInfo,
                BasePath:          bootBaseInfo.MountFile(),
                Gadget:            gadgetInfo,
                GadgetPath:        gadgetInfo.MountFile(),
                Kernel:            kernelInfo,
                KernelPath:        kernelInfo.MountFile(),
                UnpackedGadgetDir: gadgetDir,

                RecoverySystemLabel: modeEnv.RecoverySystem,
                KernelMods:          kBootInfo.BootableKMods,
        }
        timings.Run(perfTimings, "boot-make-runnable", "Make target system runnable", func(timings.Measurer) </span><span class="cov0" title="0">{
                err = bootMakeRunnableAfterDataReset(deviceCtx.Model(), bootWith, trustedInstallObserver)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot make system runnable: %v", err)
        }</span>

        // leave a marker that factory reset was performed
        <span class="cov0" title="0">factoryResetMarker := filepath.Join(dirs.SnapDeviceDirUnder(boot.InstallHostWritableDir(model)), "factory-reset")
        if err := writeFactoryResetMarker(factoryResetMarker, useEncryption); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write the marker file: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func restoreDeviceFromSave(model *asserts.Model) error <span class="cov0" title="0">{
        // we could also look at factory-reset-bootstrap.json left by
        // snap-bootstrap, but the mount was already verified during boot
        mounted, err := osutil.IsMounted(boot.InitramfsUbuntuSaveDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot determine ubuntu-save mount state: %v", err)
        }</span>
        <span class="cov0" title="0">if !mounted </span><span class="cov0" title="0">{
                logger.Noticef("not restoring from save, ubuntu-save not mounted")
                return nil
        }</span>
        // TODO anything else we want to restore?
        <span class="cov0" title="0">return restoreDeviceSerialFromSave(model)</span>
}

func restoreDeviceSerialFromSave(model *asserts.Model) error <span class="cov0" title="0">{
        fromDevice := filepath.Join(boot.InstallHostDeviceSaveDir)
        logger.Debugf("looking for serial assertion and device key under %v", fromDevice)
        fromDB, err := sysdb.OpenAt(fromDevice)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // key pair manager always uses ubuntu-save whenever it's available
        <span class="cov0" title="0">kp, err := asserts.OpenFSKeypairManager(fromDevice)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // there should be a serial assertion for the current model
        <span class="cov0" title="0">serials, err := fromDB.FindMany(asserts.SerialType, map[string]string{
                "brand-id": model.BrandID(),
                "model":    model.Model(),
        })
        if (err != nil &amp;&amp; errors.Is(err, &amp;asserts.NotFoundError{})) || len(serials) == 0 </span><span class="cov0" title="0">{
                // there is no serial assertion in the old system that matches
                // our model, it is still possible that the old system could
                // have generated device keys and sent out a serial request, but
                // for simplicity we ignore this scenario and a new set of keys
                // will be generated after booting into the run system
                logger.Debugf("no serial assertion for %v/%v", model.BrandID(), model.Model())
                return nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Noticef("found %v serial assertions for %v/%v", len(serials), model.BrandID(), model.Model())

        var serialAs *asserts.Serial
        for _, serial := range serials </span><span class="cov0" title="0">{
                maybeCurrentSerialAs := serial.(*asserts.Serial)
                // serial assertion is signed with the device key, its ID is in the
                // header
                deviceKeyID := maybeCurrentSerialAs.DeviceKey().ID()
                logger.Debugf("serial assertion device key ID: %v", deviceKeyID)

                // there can be multiple serial assertions, as the device could
                // have exercised the registration a number of times, but each
                // time it unregisters, the old key is removed and a new one is
                // generated
                _, err = kp.Get(deviceKeyID)
                if err != nil </span><span class="cov0" title="0">{
                        if asserts.IsKeyNotFound(err) </span><span class="cov0" title="0">{
                                logger.Debugf("no key with ID %v", deviceKeyID)
                                continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("cannot obtain device key: %v", err)</span>
                } else<span class="cov0" title="0"> {
                        serialAs = maybeCurrentSerialAs
                        break</span>
                }
        }

        <span class="cov0" title="0">if serialAs == nil </span><span class="cov0" title="0">{
                // no serial assertion that matches the model, brand and is
                // signed with a device key that is present in the filesystem
                logger.Debugf("no valid serial assertions")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debugf("found a serial assertion for %v/%v, with serial %v",
                model.BrandID(), model.Model(), serialAs.Serial())

        toDB, err := sysdb.OpenAt(filepath.Join(boot.InstallHostWritableDir(model), "var/lib/snapd/assertions"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Debugf("importing serial and model assertions")
        b := asserts.NewBatch(nil)
        err = b.Fetch(toDB,
                func(ref *asserts.Ref) (asserts.Assertion, error) </span><span class="cov0" title="0">{ return ref.Resolve(fromDB.Find) }</span>,
                func(f asserts.Fetcher) error <span class="cov0" title="0">{
                        if err := f.Save(model); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return f.Save(serialAs)</span>
                })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot fetch assertions: %v", err)
        }</span>
        <span class="cov0" title="0">if err := b.CommitTo(toDB, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot commit assertions: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type factoryResetMarker struct {
        FallbackSaveKeyHash string `json:"fallback-save-key-sha3-384,omitempty"`
}

func fileDigest(p string) (string, error) <span class="cov0" title="0">{
        digest, _, err := osutil.FileDigest(p, crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(digest), nil</span>
}

func writeFactoryResetMarker(marker string, hasEncryption bool) error <span class="cov0" title="0">{
        keyDigest := ""
        if hasEncryption </span><span class="cov0" title="0">{
                d, err := fileDigest(device.FactoryResetFallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">keyDigest = d</span>
        }
        <span class="cov0" title="0">var buf bytes.Buffer
        err := json.NewEncoder(&amp;buf).Encode(factoryResetMarker{
                FallbackSaveKeyHash: keyDigest,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if hasEncryption </span><span class="cov0" title="0">{
                logger.Noticef("writing factory-reset marker at %v with key digest %q", marker, keyDigest)
        }</span> else<span class="cov0" title="0"> {
                logger.Noticef("writing factory-reset marker at %v", marker)
        }</span>
        <span class="cov0" title="0">return osutil.AtomicWriteFile(marker, buf.Bytes(), 0644, 0)</span>
}

func verifyFactoryResetMarkerInRun(marker string, hasEncryption bool) error <span class="cov0" title="0">{
        f, err := os.Open(marker)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        var frm factoryResetMarker
        if err := json.NewDecoder(f).Decode(&amp;frm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if hasEncryption </span><span class="cov0" title="0">{
                saveFallbackKeyFactory := device.FactoryResetFallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir)
                d, err := fileDigest(saveFallbackKeyFactory)
                if err != nil </span><span class="cov0" title="0">{
                        // possible that there was unexpected reboot
                        // before, after the key was moved, but before
                        // the marker was removed, in which case the
                        // actual fallback key should have the right
                        // digest
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                // unless it's a different error
                                return err
                        }</span>
                        <span class="cov0" title="0">saveFallbackKeyFactory := device.FallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir)
                        d, err = fileDigest(saveFallbackKeyFactory)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if d != frm.FallbackSaveKeyHash </span><span class="cov0" title="0">{
                        return fmt.Errorf("fallback sealed key digest mismatch, got %v expected %v", d, frm.FallbackSaveKeyHash)
                }</span>
        } else<span class="cov0" title="0"> {
                if frm.FallbackSaveKeyHash != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected non-empty fallback key digest")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type encryptionSetupDataKey struct {
        systemLabel string
}

func mountSeedContainer(filePath, subdir string) (mountpoint string, unmount func() error, err error) <span class="cov0" title="0">{
        mountpoint = filepath.Join(dirs.SnapRunDir, "snap-content", subdir)
        if err := os.MkdirAll(mountpoint, 0755); err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        // temporarily mount the filesystem
        <span class="cov0" title="0">logger.Debugf("mounting %q in %q", filePath, mountpoint)
        sd := systemd.New(systemd.SystemMode, progress.Null)
        if err := sd.Mount(filePath, mountpoint); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("cannot mount %q at %q: %v", filePath, mountpoint, err)
        }</span>
        <span class="cov0" title="0">return mountpoint,
                func() error </span><span class="cov0" title="0">{
                        logger.Debugf("unmounting %q", mountpoint)
                        return sd.Umount(mountpoint)
                }</span>,
                nil
}

func (m *DeviceManager) loadAndMountSystemLabelSnapsUnlock(st *state.State, systemLabel string, essentialTypes []snap.Type) (*systemAndEssentialSnaps, map[snap.Type]string, map[string]string, func(), error) <span class="cov0" title="0">{
        st.Unlock()
        defer st.Lock()
        return m.loadAndMountSystemLabelSnaps(systemLabel, essentialTypes)
}</span>

func (m *DeviceManager) loadAndMountSystemLabelSnaps(systemLabel string, essentialTypes []snap.Type) (*systemAndEssentialSnaps, map[snap.Type]string, map[string]string, func(), error) <span class="cov0" title="0">{
        systemAndSnaps, err := m.loadSystemAndEssentialSnaps(systemLabel, essentialTypes, "run")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>

        // Mount gadget, kernel and kernel-modules components
        <span class="cov0" title="0">var unmountFuncs []func() error
        mntPtForType := make(map[snap.Type]string)
        unmount := func() </span><span class="cov0" title="0">{
                for _, unmountF := range unmountFuncs </span><span class="cov0" title="0">{
                        if errUnmount := unmountF(); errUnmount != nil </span><span class="cov0" title="0">{
                                logger.Noticef("error unmounting: %v", errUnmount)
                        }</span>
                }
        }

        <span class="cov0" title="0">seedSnaps := systemAndSnaps.SeedSnapsByType

        // We might need mount for kernel and gadget only
        for _, typ := range essentialTypes </span><span class="cov0" title="0">{
                if typ != snap.TypeGadget &amp;&amp; typ != snap.TypeKernel </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">seedSn := seedSnaps[typ]
                mntPt, unmountSnap, err := mountSeedContainer(seedSn.Path, string(seedSn.EssentialType))
                if err != nil </span><span class="cov0" title="0">{
                        unmount()
                        return nil, nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">unmountFuncs = append(unmountFuncs, unmountSnap)
                mntPtForType[seedSn.EssentialType] = mntPt</span>
        }

        <span class="cov0" title="0">mntPtForComp := make(map[string]string)
        for _, seedComp := range systemAndSnaps.CompsByType[snap.TypeKernel] </span><span class="cov0" title="0">{
                if seedComp.Info.Type != snap.KernelModulesComponent </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mntPt, unmountComp, err := mountSeedContainer(seedComp.Seed.Path,
                        seedComp.Info.FullName())
                if err != nil </span><span class="cov0" title="0">{
                        unmount()
                        return nil, nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">unmountFuncs = append(unmountFuncs, unmountComp)
                mntPtForComp[seedComp.Info.FullName()] = mntPt</span>
        }

        <span class="cov0" title="0">return systemAndSnaps, mntPtForType, mntPtForComp, unmount, nil</span>
}

func kBootInfo(systemAndSnaps *systemAndEssentialSnaps, kernMntPoint string, mntPtForComps map[string]string, isCore bool) installLogic.KernelBootInfo <span class="cov0" title="0">{
        kernInfo := systemAndSnaps.InfosByType[snap.TypeKernel]
        compSeedInfos := systemAndSnaps.CompsByType[snap.TypeKernel]
        return installLogic.BuildKernelBootInfo(kernInfo, compSeedInfos, kernMntPoint,
                mntPtForComps, installLogic.BuildKernelBootInfoOpts{
                        IsCore: isCore, NeedsDriversTree: kernel.NeedsKernelDriversTree(systemAndSnaps.Model)})
}</span>

func addPreInstallRecoveryKey(dataBootstrappedContainer, saveBootstrappedContainer secboot.BootstrappedContainer, rkey keys.RecoveryKey) error <span class="cov0" title="0">{
        if dataBootstrappedContainer == nil || saveBootstrappedContainer == nil </span><span class="cov0" title="0">{
                return errors.New("internal error: system encryption keys are unset")
        }</span>

        <span class="cov0" title="0">if err := dataBootstrappedContainer.AddRecoveryKey("default-recovery", rkey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return saveBootstrappedContainer.AddRecoveryKey("default-recovery", rkey)</span>
}

// doInstallFinish performs the finish step of the install. It will
// - install missing volumes structure content
// - copy seed (only for UC)
// - install gadget assets
// - install kernel.efi
// - make system bootable (including writing modeenv)
func (m *DeviceManager) doInstallFinish(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        var err error
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        var systemLabel string
        if err := t.Get("system-label", &amp;systemLabel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var onVolumes map[string]*gadget.Volume
        if err := t.Get("on-volumes", &amp;onVolumes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // cache is used to transport encryptionSetupData between install steps
        // "install-setup-storage-encryption" and "install-finish"
        <span class="cov0" title="0">var encryptSetupData *install.EncryptionSetupData
        cached := st.Cached(encryptionSetupDataKey{systemLabel})
        if cached != nil </span><span class="cov0" title="0">{
                var ok bool
                // TODO check that encryptSetupData is not out of sync with the onVolumes we get
                encryptSetupData, ok = cached.(*install.EncryptionSetupData)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: wrong data type under encryptionSetupDataKey")
                }</span>
        }

        <span class="cov0" title="0">systemAndSnaps, mntPtForType, mntPtForComps, unmount, err := m.loadAndMountSystemLabelSnapsUnlock(
                st, systemLabel, []snap.Type{snap.TypeKernel, snap.TypeBase, snap.TypeGadget})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer unmount()

        // Check if encryption is mandatory
        if systemAndSnaps.Model.StorageSafety() == asserts.StorageSafetyEncrypted &amp;&amp; encryptSetupData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("storage encryption required by model but has not been set up")
        }</span>
        <span class="cov0" title="0">useEncryption := encryptSetupData != nil

        logger.Debugf("starting install-finish for %q (using encryption: %t) on %v", systemLabel, useEncryption, onVolumes)

        // TODO we probably want to pass a different location for the assets cache
        installObserver, trustedInstallObserver, err := installLogic.BuildInstallObserver(systemAndSnaps.Model, mntPtForType[snap.TypeGadget], useEncryption)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gi, err := gadget.ReadInfoAndValidate(mntPtForType[snap.TypeGadget], systemAndSnaps.Model, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Import new information from the installer to the gadget data,
        // including the target devices and information marked as partial in
        // the gadget, so the gadget is not partially defined anymore if it
        // was.
        // TODO validation of onVolumes versus gadget.yaml, needs to happen here.
        <span class="cov0" title="0">mergedVols, err := gadget.ApplyInstallerVolumesToGadget(onVolumes, gi.Volumes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Match gadget against the disk, so we make sure that the information
        // reported by the installer is correct and that all partitions have
        // been created.
        <span class="cov0" title="0">volCompatOpts := &amp;gadget.VolumeCompatibilityOptions{
                // at this point all partitions should be created
                AssumeCreatablePartitionsCreated: true,
        }
        if useEncryption </span><span class="cov0" title="0">{
                volCompatOpts.ExpectedStructureEncryption = map[string]gadget.StructureEncryptionParameters{
                        "ubuntu-data": {Method: gadget.EncryptionLUKS},
                        "ubuntu-save": {Method: gadget.EncryptionLUKS},
                }
        }</span>
        <span class="cov0" title="0">volToGadgetToDiskStruct, err := installMatchDisksToGadgetVolumes(mergedVols, volCompatOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encType := device.EncryptionTypeNone
        // TODO:ICE: support device.EncryptionTypeLUKSWithICE in the API
        if useEncryption </span><span class="cov0" title="0">{
                encType = device.EncryptionTypeLUKS
        }</span>
        <span class="cov0" title="0">kernMntPoint := mntPtForType[snap.TypeKernel]
        allLaidOutVols, err := gadget.LaidOutVolumesFromGadget(mergedVols,
                mntPtForType[snap.TypeGadget], kernMntPoint,
                encType, volToGadgetToDiskStruct)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("on finish install: cannot layout volumes: %v", err)
        }</span>

        <span class="cov0" title="0">snapInfos := systemAndSnaps.InfosByType
        snapSeeds := systemAndSnaps.SeedSnapsByType

        // Find out kernel-modules components in the seed
        isCore := !systemAndSnaps.Model.Classic()
        kBootInfo := kBootInfo(systemAndSnaps, kernMntPoint, mntPtForComps, isCore)

        logger.Debugf("writing content to partitions")
        timings.Run(perfTimings, "install-content", "Writing content to partitions", func(tm timings.Measurer) </span><span class="cov0" title="0">{
                st.Unlock()
                defer st.Lock()
                _, err = installWriteContent(mergedVols, allLaidOutVols, encryptSetupData,
                        kBootInfo.KSnapInfo, installObserver, perfTimings)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write content: %v", err)
        }</span>

        // Mount the partitions and find the system-seed{,-null} partition
        <span class="cov0" title="0">seedMntDir, unmountParts, err := installMountVolumes(mergedVols, encryptSetupData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot mount partitions for installation: %v", err)
        }</span>
        <span class="cov0" title="0">defer unmountParts()

        hasSystemSeed := gadget.VolumesHaveRole(mergedVols, gadget.SystemSeed)
        if hasSystemSeed </span><span class="cov0" title="0">{
                copier, ok := systemAndSnaps.Seed.(seed.Copier)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: seed does not support copying: %s", systemAndSnaps.Label)
                }</span>

                <span class="cov0" title="0">var optional *seed.OptionalContainers
                if t.Has("optional-install") </span><span class="cov0" title="0">{
                        var oc OptionalContainers
                        if err := t.Get("optional-install", &amp;oc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">optional = &amp;seed.OptionalContainers{
                                Snaps:      oc.Snaps,
                                Components: oc.Components,
                        }</span>
                }

                <span class="cov0" title="0">logger.Debugf("copying label %q to seed partition", systemAndSnaps.Label)
                if err := copier.Copy(seedMntDir, seed.CopyOptions{
                        Label:              systemAndSnaps.Label,
                        OptionalContainers: optional,
                }, perfTimings); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot copy seed: %w", err)
                }</span>

                <span class="cov0" title="0">if systemAndSnaps.Model.HybridClassic() </span><span class="cov0" title="0">{
                        // boot.InitramfsUbuntuSeedDir (/run/mnt/ubuntu-data, usually) is a
                        // mountpoint on hybrid system that is set up in the initramfs.
                        // setting up this bind mount ensures that the system can be seeded
                        // on boot.
                        unitName, _, err := systemd.EnsureMountUnitFileContent(&amp;systemd.MountUnitOptions{
                                Lifetime:                 systemd.Persistent,
                                Description:              "Bind mount seed partition",
                                What:                     boot.InitramfsUbuntuSeedDir,
                                PreventRestartIfModified: true,
                                Where:                    dirs.SnapSeedDir,
                                Fstype:                   "none",
                                Options:                  []string{"bind", "ro"},
                                RootDir:                  boot.InstallUbuntuDataDir,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create mount unit for seed: %w", err)
                        }</span>

                        <span class="cov0" title="0">enabledUnitDir := filepath.Join(boot.InstallUbuntuDataDir, "etc/systemd/system/snapd.mounts.target.wants")
                        if err := os.MkdirAll(enabledUnitDir, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create directory for systemd unit: %w", err)
                        }</span>

                        <span class="cov0" title="0">err = os.Symlink(
                                filepath.Join(dirs.GlobalRootDir, "etc/systemd/system", unitName),
                                filepath.Join(enabledUnitDir, unitName),
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create symlink to enable systemd unit: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := installSaveStorageTraits(systemAndSnaps.Model, mergedVols, encryptSetupData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if trustedInstallObserver != nil </span><span class="cov0" title="0">{
                // We are required to call ObserveExistingTrustedRecoveryAssets on trusted observers
                if err := trustedInstallObserver.ObserveExistingTrustedRecoveryAssets(boot.InitramfsUbuntuSeedDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot observe existing trusted recovery assets: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if useEncryption </span><span class="cov0" title="0">{
                bootstrappedContainersForRole := install.BootstrappedContainersForRole(encryptSetupData)
                if trustedInstallObserver != nil </span><span class="cov0" title="0">{
                        if err := installLogic.PrepareEncryptedSystemData(
                                systemAndSnaps.Model,
                                bootstrappedContainersForRole,
                                encryptSetupData.VolumesAuth(),
                                encryptSetupData.PreinstallCheckContext(),
                                trustedInstallObserver,
                        ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">recoveryKeyID := encryptSetupData.RecoveryKeyID()
                if recoveryKeyID != "" </span><span class="cov0" title="0">{
                        rkey, err := fdestateGetRecoveryKey(st, recoveryKeyID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := addPreInstallRecoveryKey(bootstrappedContainersForRole[gadget.SystemData], bootstrappedContainersForRole[gadget.SystemSave], rkey); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">bootWith := &amp;boot.BootableSet{
                Base:              snapInfos[snap.TypeBase],
                BasePath:          snapSeeds[snap.TypeBase].Path,
                Kernel:            snapInfos[snap.TypeKernel],
                KernelPath:        snapSeeds[snap.TypeKernel].Path,
                Gadget:            snapInfos[snap.TypeGadget],
                GadgetPath:        snapSeeds[snap.TypeGadget].Path,
                UnpackedGadgetDir: mntPtForType[snap.TypeGadget],

                RecoverySystemLabel: systemLabel,
                KernelMods:          kBootInfo.BootableKMods,
        }

        // installs in system-seed{,-null} partition: grub.cfg, grubenv
        logger.Debugf("making the system-seed{,-null} partition bootable, mount dir is %q", seedMntDir)
        opts := &amp;bootloader.Options{
                PrepareImageTime: false,
                // We need the same configuration that a recovery partition,
                // as we will chainload to grub in the boot partition.
                Role: bootloader.RoleRecovery,
        }
        if err := bootMakeBootablePartition(seedMntDir, opts, bootWith, boot.ModeRun, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if hasSystemSeed </span><span class="cov0" title="0">{
                // get the path of the kernel snap relative to the original seed's
                // directory. since we're not renaming the seed, this will be the same
                // relative path as if we're working under the new seed's directory
                kernelRelPath, err := filepath.Rel(dirs.SnapSeedDir, snapSeeds[snap.TypeKernel].Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // this will make the newly copied seed bootable as a recovery system by
                // writing a grubenv file to the seed.
                <span class="cov0" title="0">err = bootMakeRecoverySystemBootable(systemAndSnaps.Model, seedMntDir, filepath.Join("systems", systemLabel), &amp;boot.RecoverySystemBootableSet{
                        Kernel:          snapInfos[snap.TypeKernel],
                        KernelPath:      filepath.Join(seedMntDir, kernelRelPath),
                        GadgetSnapOrDir: snapSeeds[snap.TypeGadget].Path,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // writes the model etc
        <span class="cov0" title="0">if err := installLogicPrepareRunSystemData(systemAndSnaps.Model, bootWith.UnpackedGadgetDir, perfTimings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Debugf("making the installed system runnable for system label %s", systemLabel)
        if err := bootMakeRunnableStandalone(systemAndSnaps.Model, bootWith, trustedInstallObserver, st.Unlocker()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func checkVolumesAuth(volumesAuth *device.VolumesAuthOptions, encryptInfo *installLogic.EncryptionSupportInfo) error <span class="cov0" title="0">{
        if volumesAuth == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">switch volumesAuth.Mode </span>{
        case device.AuthModePassphrase:<span class="cov0" title="0">
                if !encryptInfo.PassphraseAuthAvailable </span><span class="cov0" title="0">{
                        return fmt.Errorf("%q authentication mode is not supported by target system", device.AuthModePassphrase)
                }</span>
        case device.AuthModePIN:<span class="cov0" title="0">
                return fmt.Errorf("%q authentication mode is not implemented", device.AuthModePIN)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid authentication mode %q, only %q and %q modes are supported", volumesAuth.Mode, device.AuthModePassphrase, device.AuthModePIN)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type volumesAuthOptionsKey struct {
        systemLabel string
}

func (m *DeviceManager) doInstallSetupStorageEncryption(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        var systemLabel string
        if err := t.Get("system-label", &amp;systemLabel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var onVolumes map[string]*gadget.Volume
        if err := t.Get("on-volumes", &amp;onVolumes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Debugf("install-setup-storage-encryption for %q on %v", systemLabel, onVolumes)
        var volumesAuthRequired bool
        if err := t.Get("volumes-auth-required", &amp;volumesAuthRequired); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var volumesAuth *device.VolumesAuthOptions
        if volumesAuthRequired </span><span class="cov0" title="0">{
                cached := st.Cached(volumesAuthOptionsKey{systemLabel})
                if cached == nil </span><span class="cov0" title="0">{
                        return errors.New("volumes authentication is required but cannot find corresponding cached options")
                }</span>
                <span class="cov0" title="0">st.Cache(volumesAuthOptionsKey{systemLabel}, nil)
                var ok bool
                volumesAuth, ok = cached.(*device.VolumesAuthOptions)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: wrong data type under volumesAuthOptionsKey")
                }</span>
        }

        <span class="cov0" title="0">systemAndSeeds, mntPtForType, _, unmount, err := m.loadAndMountSystemLabelSnapsUnlock(
                st, systemLabel, []snap.Type{snap.TypeSnapd, snap.TypeKernel, snap.TypeBase, snap.TypeGadget})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer unmount()

        // Gadget information
        snapf, err := snapfile.Open(systemAndSeeds.SeedSnapsByType[snap.TypeGadget].Path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot open gadget snap: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetInfo, err := gadget.ReadInfoFromSnapFileNoValidate(snapf, systemAndSeeds.Model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading gadget information: %v", err)
        }</span>

        <span class="cov0" title="0">constraints := installLogic.EncryptionConstraints{
                Model:         systemAndSeeds.Model,
                Kernel:        systemAndSeeds.InfosByType[snap.TypeKernel],
                Gadget:        gadgetInfo,
                TPMMode:       secboot.TPMProvisionFull,
                SnapdVersions: systemAndSeeds.SystemSnapdVersions,
        }

        // do not use cached encryption information; perform a fresh encryption
        // availability check
        const encInfoFromCache = false
        encryptInfo, err := m.encryptionSupportInfoLocked(systemLabel, constraints, encInfoFromCache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !encryptInfo.Available </span><span class="cov0" title="0">{
                var whyStr string
                if encryptInfo.UnavailableErr != nil </span><span class="cov0" title="0">{
                        whyStr = encryptInfo.UnavailableErr.Error()
                }</span> else<span class="cov0" title="0"> {
                        whyStr = encryptInfo.UnavailableWarning
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("encryption unavailable on this device: %v", whyStr)</span>
        }
        <span class="cov0" title="0">if err := checkVolumesAuth(volumesAuth, encryptInfo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO:ICE: support device.EncryptionTypeLUKSWithICE in the API
        <span class="cov0" title="0">encType := device.EncryptionTypeLUKS
        encryptionSetupData, err := installEncryptPartitions(
                onVolumes,
                volumesAuth,
                encType,
                encryptInfo.CheckContext(),
                systemAndSeeds.Model,
                mntPtForType[snap.TypeGadget],
                mntPtForType[snap.TypeKernel],
                perfTimings,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store created devices in the change so they can be accessed from the installer
        <span class="cov0" title="0">apiData := map[string]any{
                "encrypted-devices": encryptionSetupData.EncryptedDevices(),
        }
        chg := t.Change()
        chg.Set("api-data", apiData)

        // cache is used to transport encryptionSetupData between install steps
        // "install-setup-storage-encryption" and "install-finish"
        st.Cache(encryptionSetupDataKey{systemLabel}, encryptionSetupData)

        return nil</span>
}

var (
        secbootAddBootstrapKeyOnExistingDisk = secboot.AddBootstrapKeyOnExistingDisk
        secbootRenameKeysForFactoryReset     = secboot.RenameKeysForFactoryReset
        secbootCreateBootstrappedContainer   = secboot.CreateBootstrappedContainer
        secbootDeleteKeys                    = secboot.DeleteKeys
        secbootDeleteOldKeys                 = secboot.DeleteOldKeys
)

func createSaveBootstrappedContainer(saveNode string) (secboot.BootstrappedContainer, error) <span class="cov0" title="0">{
        // new encryption key for save
        saveEncryptionKey, err := keys.NewEncryptionKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create encryption key: %v", err)
        }</span>

        // In order to manipulate the LUKS2 container, we need a
        // bootstrap key. This key will be removed with
        // secboot.BootstrappedContainer.RemoveBootstrapKey at the end
        // of secboot.SealKeyToModeenv
        <span class="cov0" title="0">if err := secbootAddBootstrapKeyOnExistingDisk(saveNode, saveEncryptionKey); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We cannot remove keys until we have completed the factory
        // reset. Otherwise if we lose power during the reset, we
        // might not be able to unlock the save partitions anymore.
        // However, we cannot have multiple keys with the same
        // name. So we need to rename the existing keys that we are
        // going to create.
        //
        // TODO:FDEM:FIX: If we crash and reboot, and re-run factory reset,
        // there will be already some old key saved. In that case, we
        // need to keep those old keys and remove the new ones.  But
        // we should also verify what keys we used from the
        //
        // TODO:FDEM:FIX: Do we maybe need to only save the default-fallback
        // key and delete the default key? The default key will not be
        // able to be used since we re created the data disk.
        //
        // TODO:FDEM:FIX: The keys should be renamed to reprovision-XX and keep
        // track of the mapping XX to original key name.
        <span class="cov0" title="0">renames := map[string]string{
                "default":          "reprovision-default",
                "default-fallback": "reprovision-default-fallback",
        }
        // Temporarily rename keyslots across the factory reset to
        // allow to create the new ones.
        if err := secbootRenameKeysForFactoryReset(saveNode, renames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot rename existing keys: %w", err)
        }</span>

        // Deal as needed instead with naming unamed keyslots, they
        // will be removed at the end of factory reset.
        <span class="cov0" title="0">if err := secbootTemporaryNameOldKeys(saveNode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot convert old keys: %w", err)
        }</span>

        <span class="cov0" title="0">return secbootCreateBootstrappedContainer(secboot.DiskUnlockKey(saveEncryptionKey), saveNode), nil</span>
}

// rotateSaveKeyAndDeleteOldKeys removes old keys that were used in previous installation after successful factory reset.
//   - Rotate ubuntu-save recovery key files: replace
//     ubuntu-save.recovery.sealed-key with
//     ubuntu-save.recovery.sealed-key.factory-reset which we have
//     successfully used during factory reset.
//   - Remove factory-reset-* keyslots.
//   - Release TPM handles used by the removed keys.
func rotateSaveKeyAndDeleteOldKeys(saveMntPnt string) error <span class="cov0" title="0">{
        protector, err := boot.HookKeyProtectorFactory(nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Noticef("WARNING: cannot determine whether FDE hooks are in use: %v", err)
        }</span>

        <span class="cov0" title="0">uuid, err := disksDMCryptUUIDFromMountPoint(saveMntPnt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot find save partition: %v", err)
        }</span>

        <span class="cov0" title="0">diskPath := filepath.Join("/dev/disk/by-uuid", uuid)

        oldPossiblyTPMKeySlots := map[string]bool{
                "reprovision-default-fallback": true,
        }

        defaultSaveKey := device.FallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir)
        saveFallbackKeyFactory := device.FactoryResetFallbackSaveSealedKeyUnder(boot.InitramfsSeedEncryptionKeyDir)

        var oldKeys []string
        renameKey := false
        // If the fallback save key exists, then it is the new
        // key. That means the default save key is the old save key
        // that needs to be removed.
        if osutil.FileExists(saveFallbackKeyFactory) </span><span class="cov0" title="0">{
                oldKeys = append(oldKeys, defaultSaveKey)
                renameKey = true
        }</span>

        <span class="cov0" title="0">hintExpectHook := protector != nil
        err = secbootRemoveOldCounterHandles(
                diskPath,
                oldPossiblyTPMKeySlots,
                oldKeys,
                hintExpectHook,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not clean up old counter handles: %v", err)
        }</span>

        <span class="cov0" title="0">if renameKey </span><span class="cov0" title="0">{
                if err := os.Rename(saveFallbackKeyFactory, defaultSaveKey); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot rotate fallback key: %v", err)
                }</span>
        }

        <span class="cov0" title="0">oldKeySlots := map[string]bool{
                "reprovision-default":          true,
                "reprovision-default-fallback": true,
        }

        // DeleteKeys will remove the keys that were renamed from the
        // previous installation
        if err := secbootDeleteKeys(diskPath, oldKeySlots); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete previous keys: %w", err)
        }</span>
        // DeleteOldKeys will remove the keys that were named by
        // TemporaryNameOldKeys from an old disk that did not have names on
        // keys.
        <span class="cov0" title="0">if err := secbootDeleteOldKeys(diskPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove old disk keys: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GeneratePreInstallRecoveryKey generates a recovery key and embeds
// its corresponding id in the storage encryption setup data.
//
// Note: InstallSetupStorageEncryption must be called before calling
// this helper.
func GeneratePreInstallRecoveryKey(st *state.State, label string) (rkey keys.RecoveryKey, err error) <span class="cov0" title="0">{
        var encryptSetupData *install.EncryptionSetupData
        cached := st.Cached(encryptionSetupDataKey{label})
        if cached == nil </span><span class="cov0" title="0">{
                return keys.RecoveryKey{}, fmt.Errorf("storage encryption setup step was not called")
        }</span>

        // XXX: just let it panic?
        <span class="cov0" title="0">encryptSetupData, ok := cached.(*install.EncryptionSetupData)
        if !ok </span><span class="cov0" title="0">{
                return keys.RecoveryKey{}, fmt.Errorf("internal error: wrong data type under encryptionSetupDataKey")
        }</span>

        <span class="cov0" title="0">rkey, keyID, err := fdestateGenerateRecoveryKey(st)
        if err != nil </span><span class="cov0" title="0">{
                return keys.RecoveryKey{}, err
        }</span>

        // attach key-id to encryption setup data so it can be used
        // in the install finish step.
        <span class="cov0" title="0">encryptSetupData.SetRecoveryKeyID(keyID)
        st.Cache(encryptionSetupDataKey{label}, encryptSetupData)

        return rkey, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2016-2017 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "fmt"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/snap/naming"
)

func isSameAssertsRevision(err error) bool <span class="cov0" title="0">{
        if e, ok := err.(*asserts.RevisionError); ok </span><span class="cov0" title="0">{
                if e.Used == e.Current </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var injectedSetModelError error

// InjectSetModelError will trigger the selected error in the doSetModel
// handler. This is only useful for testing.
func InjectSetModelError(err error) <span class="cov0" title="0">{
        injectedSetModelError = err
}</span>

func (m *DeviceManager) doSetModel(t *state.Task, _ *tomb.Tomb) (err error) <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        remodCtx, err := remodelCtxFromTask(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">new := remodCtx.Model()

        // unmark no-longer required snaps
        var cleanedRequiredSnaps []string
        requiredSnaps := getAllRequiredSnapsForModel(new)
        // TODO|XXX: have AllByRef
        snapStates, err := snapstate.All(st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for snapName, snapst := range snapStates </span><span class="cov0" title="0">{
                // TODO: remove this type restriction once we remodel
                //       gadgets and add tests that ensure
                //       that the required flag is properly set/unset
                typ, err := snapst.Type()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if typ != snap.TypeApp &amp;&amp; typ != snap.TypeBase &amp;&amp; typ != snap.TypeKernel </span><span class="cov0" title="0">{
                        continue</span>
                }
                // clean required flag if no-longer needed
                <span class="cov0" title="0">if snapst.Flags.Required &amp;&amp; !requiredSnaps.Contains(naming.Snap(snapName)) </span><span class="cov0" title="0">{
                        snapst.Flags.Required = false
                        snapstate.Set(st, snapName, snapst)
                        cleanedRequiredSnaps = append(cleanedRequiredSnaps, snapName)
                }</span>
                // TODO: clean "required" flag of "core" if a remodel
                //       moves from the "core" snap to a different
                //       bootable base snap.
        }
        // ensure  we undo the cleanedRequiredSnaps if e.g. remodCtx
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">var snapst snapstate.SnapState
                for _, snapName := range cleanedRequiredSnaps </span><span class="cov0" title="0">{
                        if err := snapstate.Get(st, snapName, &amp;snapst); err == nil </span><span class="cov0" title="0">{
                                snapst.Flags.Required = true
                                snapstate.Set(st, snapName, &amp;snapst)
                        }</span>
                }
        }()

        <span class="cov0" title="0">currentSets, err := trackedValidationSetsFromModel(st, remodCtx.GroundContext().Model())

        for _, old := range currentSets </span><span class="cov0" title="0">{
                if err := assertstate.ForgetValidationSet(st, old.AccountID(), old.Name(), assertstate.ForgetValidationSetOpts{
                        ForceForget: true,
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">newSets := new.ValidationSets()

        defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // restore the old validation sets if something went wrong
                <span class="cov0" title="0">if err := rollBackValidationSets(st, currentSets, newSets, remodCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Debugf("cannot rollback validation sets: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if err := enforceValidationSetsForRemodel(st, newSets); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // only useful for testing
        <span class="cov0" title="0">if injectedSetModelError != nil </span><span class="cov0" title="0">{
                return injectedSetModelError
        }</span>

        // add the assertion only after everything else was successful
        <span class="cov0" title="0">err = assertstate.Add(st, new)
        if err != nil &amp;&amp; !isSameAssertsRevision(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        // hybrid core/classic systems might have a system-seed-null; in that case,
        // we cannot create a recovery system
        <span class="cov0" title="0">hasSystemSeed, err := checkForSystemSeed(st, remodCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot find ubuntu seed role: %w", err)
        }</span>

        <span class="cov0" title="0">var recoverySetup *recoverySystemSetup
        if new.Grade() != asserts.ModelGradeUnset &amp;&amp; hasSystemSeed </span><span class="cov0" title="0">{
                var triedSystems []string
                if err := st.Get("tried-systems", &amp;triedSystems); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot obtain tried recovery systems: %v", err)
                }</span>
                <span class="cov0" title="0">recoverySetup, err = taskRecoverySystemSetup(t)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // should promoting or any of the later steps fails, the cleanup
                // will be done in finalize-recovery-system undo
                <span class="cov0" title="0">if err := boot.PromoteTriedRecoverySystem(remodCtx, recoverySetup.Label, triedSystems); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">remodCtx.setRecoverySystemLabel(recoverySetup.Label)</span>
        }

        <span class="cov0" title="0">logEverywhere := func(format string, args ...any) </span><span class="cov0" title="0">{
                t.Logf(format, args)
                logger.Noticef(format, args)
        }</span>

        // and finish (this will set the new model), note that changes done in
        // here are not recoverable even if an error occurs
        <span class="cov0" title="0">if err := remodCtx.Finish(); err != nil </span><span class="cov0" title="0">{
                logEverywhere("cannot complete remodel: %v", err)
        }</span>

        <span class="cov0" title="0">t.SetStatus(state.DoneStatus)

        return nil</span>
}

func trackedValidationSetsFromModel(st *state.State, model *asserts.Model) ([]*asserts.ValidationSet, error) <span class="cov0" title="0">{
        currentSets, err := assertstate.TrackedEnforcedValidationSets(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var fromModel []*asserts.ValidationSet
        for _, mvs := range model.ValidationSets() </span><span class="cov0" title="0">{
                for _, cvs := range currentSets.Sets() </span><span class="cov0" title="0">{
                        if mvs.SequenceKey() == cvs.SequenceKey() </span><span class="cov0" title="0">{
                                fromModel = append(fromModel, cvs)
                        }</span>
                }
        }
        <span class="cov0" title="0">return fromModel, nil</span>
}

func rollBackValidationSets(st *state.State, oldSets []*asserts.ValidationSet, newSets []*asserts.ModelValidationSet, deviceCtx snapstate.DeviceContext) error <span class="cov0" title="0">{
        for _, set := range newSets </span><span class="cov0" title="0">{
                if err := assertstate.ForgetValidationSet(st, set.AccountID, set.Name, assertstate.ForgetValidationSetOpts{
                        ForceForget: true,
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">vSetKeys := make(map[string][]string, len(oldSets))
        for _, vs := range oldSets </span><span class="cov0" title="0">{
                sequenceName := vs.SequenceKey()
                vSetKeys[sequenceName] = vs.At().PrimaryKey
        }</span>

        <span class="cov0" title="0">snaps, ignore, err := snapstate.InstalledSnaps(st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // we must ignore all snaps that are currently installed, since those snaps
        // were installed in accordance to the new model and validation sets.
        //
        // alternatively, a more complex (but potentially more robust) approach
        // would be to split logic for undoing the validation sets and applying the
        // validation sets into different tasks. then, we can put the undo task
        // early in the change. this would allow us to undo the validation sets
        // after the snap installations/refreshes have been undone.
        <span class="cov0" title="0">for _, sn := range snaps </span><span class="cov0" title="0">{
                ignore[sn.SnapName()] = true
        }</span>

        <span class="cov0" title="0">if err := assertstate.ApplyLocalEnforcedValidationSets(st, vSetKeys, nil, snaps, ignore); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func resolveValidationSetAssertion(seq *asserts.AtSequence, db asserts.RODatabase) (asserts.Assertion, error) <span class="cov0" title="0">{
        if seq.Sequence &lt;= 0 </span><span class="cov0" title="0">{
                hdrs, err := asserts.HeadersFromSequenceKey(seq.Type, seq.SequenceKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return db.FindSequence(seq.Type, hdrs, -1, seq.Type.MaxSupportedFormat())</span>
        }
        <span class="cov0" title="0">return seq.Resolve(db.Find)</span>
}

func enforceValidationSetsForRemodel(st *state.State, sets []*asserts.ModelValidationSet) error <span class="cov0" title="0">{
        vsPrimaryKeys := make(map[string][]string, len(sets))
        db := assertstate.DB(st)
        for _, vs := range sets </span><span class="cov0" title="0">{
                a, err := resolveValidationSetAssertion(vs.AtSequence(), db)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">vsPrimaryKeys[vs.SequenceKey()] = a.At().PrimaryKey</span>
        }

        <span class="cov0" title="0">pinnedValidationSeqs := make(map[string]int, len(sets))
        for _, vs := range sets </span><span class="cov0" title="0">{
                if vs.Sequence &gt; 0 </span><span class="cov0" title="0">{
                        pinnedValidationSeqs[vs.SequenceKey()] = vs.Sequence
                }</span>
        }

        <span class="cov0" title="0">snaps, ignoreValidation, err := snapstate.InstalledSnaps(st)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot list installed snaps for validation: %w", err)
        }</span>

        // validation sets should already be downloaded, so we can use the local
        // version of this function
        <span class="cov0" title="0">if err := assertstate.ApplyLocalEnforcedValidationSets(st, vsPrimaryKeys, pinnedValidationSeqs, snaps, ignoreValidation); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot enforce validation sets: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DeviceManager) cleanupRemodel(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()
        // cleanup the cached remodel context
        cleanupRemodelCtx(t.Change())
        return nil
}</span>

func (m *DeviceManager) doPrepareRemodeling(t *state.Task, tmb *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        remodCtx, err := remodelCtxFromTask(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">current, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sto := remodCtx.Store()
        if sto == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: re-registration remodeling should have built a store")
        }</span>
        // ensure a new session accounting for the new brand/model
        <span class="cov0" title="0">st.Unlock()
        err = sto.EnsureDeviceSession()
        st.Lock()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get a store session based on the new model assertion: %v", err)
        }</span>

        <span class="cov0" title="0">chgID := t.Change().ID()

        tss, err := remodelTasks(tmb.Context(nil), st, current, remodCtx.Model(), remodCtx, chgID, RemodelOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allTs := state.NewTaskSet()
        for _, ts := range tss </span><span class="cov0" title="0">{
                allTs.AddAll(ts)
        }</span>
        <span class="cov0" title="0">snapstate.InjectTasks(t, allTs)

        st.EnsureBefore(0)
        t.SetStatus(state.DoneStatus)

        return nil</span>
}

var (
        gadgetIsCompatible = gadget.IsCompatible
)

func checkGadgetRemodelCompatible(st *state.State, snapInfo, curInfo *snap.Info, snapf snap.Container, flags snapstate.Flags, deviceCtx snapstate.DeviceContext) error <span class="cov0" title="0">{
        if release.OnClassic </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if snapInfo.Type() != snap.TypeGadget </span><span class="cov0" title="0">{
                // We are only interested in gadget snaps.
                return nil
        }</span>
        <span class="cov0" title="0">if deviceCtx == nil || !deviceCtx.ForRemodeling() </span><span class="cov0" title="0">{
                // We are only interesting in a remodeling scenario.
                return nil
        }</span>

        <span class="cov0" title="0">if curInfo == nil </span><span class="cov0" title="0">{
                // snap isn't installed yet, we are likely remodeling to a new
                // gadget, identify the old gadget
                curInfo, _ = snapstate.GadgetInfo(st, deviceCtx.GroundContext())
        }</span>
        <span class="cov0" title="0">if curInfo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot identify the current gadget snap")
        }</span>

        <span class="cov0" title="0">pendingInfo, err := gadget.ReadInfoFromSnapFile(snapf, deviceCtx.Model())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read new gadget metadata: %v", err)
        }</span>

        <span class="cov0" title="0">currentData, err := gadgetDataFromInfo(curInfo, deviceCtx.GroundContext().Model())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read current gadget metadata: %v", err)
        }</span>

        <span class="cov0" title="0">if err := gadgetIsCompatible(currentData.Info, pendingInfo); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remodel to an incompatible gadget: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2016-2020 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "bytes"
        "context"
        "crypto/rsa"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/httputil"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/configstate/config"
        "github.com/snapcore/snapd/overlord/configstate/proxyconf"
        "github.com/snapcore/snapd/overlord/hookstate"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/snapdenv"
        "github.com/snapcore/snapd/strutil"
        "github.com/snapcore/snapd/timings"
)

func baseURL() *url.URL <span class="cov8" title="1">{
        if snapdenv.UseStagingStore() </span><span class="cov0" title="0">{
                return mustParse("https://api.staging.snapcraft.io/")
        }</span>
        <span class="cov8" title="1">return mustParse("https://api.snapcraft.io/")</span>
}

func mustParse(s string) *url.URL <span class="cov8" title="1">{
        u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return u</span>
}

var (
        keyLength     = 4096
        retryInterval = 60 * time.Second
        maxTentatives = 15
        baseStoreURL  = baseURL().ResolveReference(authRef)

        authRef    = mustParse("api/v1/snaps/auth/") // authRef must end in / for the following refs to work
        reqIdRef   = mustParse("request-id")
        serialRef  = mustParse("serial")
        devicesRef = mustParse("devices")

        // we accept a stream with the serial assertion as well
        registrationCapabilities = []string{"serial-stream"}
)

func (m *DeviceManager) doGenerateDeviceKey(t *state.Task, _ *tomb.Tomb) error <span class="cov8" title="1">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        device, err := m.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if device.KeyID != "" </span><span class="cov0" title="0">{
                // nothing to do
                return nil
        }</span>

        <span class="cov8" title="1">st.Unlock()
        var keyPair *rsa.PrivateKey
        timings.Run(perfTimings, "generate-rsa-key", "generating device key pair", func(tm timings.Measurer) </span><span class="cov8" title="1">{
                keyPair, err = generateRSAKey(keyLength)
        }</span>)
        <span class="cov8" title="1">st.Lock()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot generate device key pair: %v", err)
        }</span>

        <span class="cov8" title="1">privKey := asserts.RSAPrivateKey(keyPair)
        err = m.withKeypairMgr(func(keypairMgr asserts.KeypairManager) error </span><span class="cov8" title="1">{
                return keypairMgr.Put(privKey)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot store device key pair: %v", err)
        }</span>

        <span class="cov8" title="1">device.KeyID = privKey.PublicKey().ID()
        err = m.setDevice(device)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">t.SetStatus(state.DoneStatus)
        return nil</span>
}

func newEnoughProxy(st *state.State, proxyURL *url.URL, client *http.Client) (bool, error) <span class="cov0" title="0">{
        st.Unlock()
        defer st.Lock()

        const prefix = "cannot check whether proxy store supports a custom serial vault"

        req, err := http.NewRequest("HEAD", proxyURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf(prefix+": %v", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("User-Agent", snapdenv.UserAgent())
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // some sort of network or protocol error
                return false, fmt.Errorf(prefix+": %v", err)
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return false, fmt.Errorf(prefix+": Head request returned %s.", resp.Status)
        }</span>
        <span class="cov0" title="0">verstr := resp.Header.Get("Snap-Store-Version")
        ver, err := strconv.Atoi(verstr)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf(prefix+": Bogus Snap-Store-Version header %q.", verstr)
        }</span>
        <span class="cov0" title="0">return ver &gt;= 6, nil</span>
}

func (cfg *serialRequestConfig) setURLs(proxyURL, svcURL *url.URL) <span class="cov8" title="1">{
        base := baseStoreURL
        if proxyURL != nil </span><span class="cov0" title="0">{
                if svcURL != nil </span><span class="cov0" title="0">{
                        if cfg.headers == nil </span><span class="cov0" title="0">{
                                cfg.headers = make(map[string]string, 1)
                        }</span>
                        <span class="cov0" title="0">cfg.headers["X-Snap-Device-Service-URL"] = svcURL.String()</span>
                }
                <span class="cov0" title="0">base = proxyURL.ResolveReference(authRef)</span>
        } else<span class="cov8" title="1"> if svcURL != nil </span><span class="cov8" title="1">{
                base = svcURL
        }</span>

        <span class="cov8" title="1">cfg.requestIDURL = base.ResolveReference(reqIdRef).String()
        if svcURL != nil &amp;&amp; proxyURL == nil </span><span class="cov8" title="1">{
                // talking directly to the custom device service
                cfg.serialRequestURL = base.ResolveReference(serialRef).String()
        }</span> else<span class="cov0" title="0"> {
                cfg.serialRequestURL = base.ResolveReference(devicesRef).String()
        }</span>
}

// A registrationContext handles the contextual information needed
// for the initial registration or a re-registration.
type registrationContext interface {
        Device() (*auth.DeviceState, error)

        Model() *asserts.Model

        GadgetForSerialRequestConfig() string
        SerialRequestExtraHeaders() map[string]any
        SerialRequestAncillaryAssertions() []asserts.Assertion

        FinishRegistration(serial *asserts.Serial) error

        ForRemodeling() bool
}

// initialRegistrationContext is a thin wrapper around DeviceManager
// implementing registrationContext for initial regitration
type initialRegistrationContext struct {
        deviceMgr *DeviceManager

        model *asserts.Model
}

func (rc *initialRegistrationContext) ForRemodeling() bool <span class="cov0" title="0">{
        return false
}</span>

func (rc *initialRegistrationContext) Device() (*auth.DeviceState, error) <span class="cov8" title="1">{
        return rc.deviceMgr.device()
}</span>

func (rc *initialRegistrationContext) Model() *asserts.Model <span class="cov0" title="0">{
        return rc.model
}</span>

func (rc *initialRegistrationContext) GadgetForSerialRequestConfig() string <span class="cov8" title="1">{
        return rc.model.Gadget()
}</span>

func (rc *initialRegistrationContext) SerialRequestExtraHeaders() map[string]any <span class="cov8" title="1">{
        return nil
}</span>

func (rc *initialRegistrationContext) SerialRequestAncillaryAssertions() []asserts.Assertion <span class="cov8" title="1">{
        return []asserts.Assertion{rc.model}
}</span>

func (rc *initialRegistrationContext) FinishRegistration(serial *asserts.Serial) error <span class="cov8" title="1">{
        device, err := rc.deviceMgr.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">device.Serial = serial.Serial()
        if err := rc.deviceMgr.setDevice(device); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rc.deviceMgr.markRegistered()

        // make sure we timely consider anything that was blocked on
        // registration
        rc.deviceMgr.state.EnsureBefore(0)

        return nil</span>
}

// registrationCtx returns a registrationContext appropriate for the task and its change.
func (m *DeviceManager) registrationCtx(t *state.Task) (registrationContext, error) <span class="cov8" title="1">{
        remodCtx, err := remodelCtxFromTask(t)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if regCtx, ok := remodCtx.(registrationContext); ok </span><span class="cov0" title="0">{
                return regCtx, nil
        }</span>
        <span class="cov8" title="1">model, err := m.Model()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;initialRegistrationContext{
                deviceMgr: m,
                model:     model,
        }, nil</span>
}

type serialSetup struct {
        SerialRequest string `json:"serial-request"`
        Serial        string `json:"serial"`
}

type requestIDResp struct {
        RequestID string `json:"request-id"`
}

func retryErr(t *state.Task, nTentatives int, reason string, a ...any) error <span class="cov0" title="0">{
        t.State().Lock()
        defer t.State().Unlock()
        if nTentatives &gt;= maxTentatives </span><span class="cov0" title="0">{
                return fmt.Errorf(reason, a...)
        }</span>
        <span class="cov0" title="0">t.Errorf(reason, a...)
        return &amp;state.Retry{After: retryInterval}</span>
}

type serverError struct {
        Message string         `json:"message"`
        Errors  []*serverError `json:"error_list"`
}

func retryBadStatus(t *state.Task, nTentatives int, reason string, resp *http.Response) error <span class="cov0" title="0">{
        if resp.StatusCode &gt; 500 </span><span class="cov0" title="0">{
                // likely temporary
                return retryErr(t, nTentatives, "%s: unexpected status %d", reason, resp.StatusCode)
        }</span>
        <span class="cov0" title="0">if resp.Header.Get("Content-Type") == "application/json" </span><span class="cov0" title="0">{
                var srvErr serverError
                dec := json.NewDecoder(resp.Body)
                err := dec.Decode(&amp;srvErr)
                if err == nil </span><span class="cov0" title="0">{
                        msg := srvErr.Message
                        if msg == "" &amp;&amp; len(srvErr.Errors) &gt; 0 </span><span class="cov0" title="0">{
                                msg = srvErr.Errors[0].Message
                        }</span>
                        <span class="cov0" title="0">if msg != "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: %s", reason, msg)
                        }</span>
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("%s: unexpected status %d", reason, resp.StatusCode)</span>
}

func prepareSerialRequest(t *state.Task, regCtx registrationContext, privKey asserts.PrivateKey, device *auth.DeviceState, client *http.Client, cfg *serialRequestConfig, hookMgr *hookstate.HookManager) (string, error) <span class="cov8" title="1">{
        // limit tentatives starting from scratch before going to
        // slower full retries
        var nTentatives int
        err := t.Get("pre-poll-tentatives", &amp;nTentatives)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">nTentatives++
        t.Set("pre-poll-tentatives", nTentatives)

        st := t.State()
        st.Unlock()
        defer st.Lock()

        req, err := http.NewRequest("POST", cfg.requestIDURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("internal error: cannot create request-id request %q", cfg.requestIDURL)
        }</span>
        <span class="cov8" title="1">req.Header.Set("User-Agent", snapdenv.UserAgent())
        cfg.applyHeaders(req)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if httputil.NoNetwork(err) </span><span class="cov0" title="0">{
                        // If there is no network there is no need to count
                        // this as a tentatives attempt. If we do it this
                        // way the risk is that we tried a bunch of times
                        // with no network and if we hit the server for real
                        // and it replies with something we need to retry
                        // we will not because nTentatives is way over the
                        // limit.
                        st.Lock()
                        t.Set("pre-poll-tentatives", 0)
                        st.Unlock()
                        // Retry quickly if there is no network
                        // (yet). This ensures that we try to get a serial
                        // as soon as the user configured the network of the
                        // device
                        noNetworkRetryInterval := retryInterval / 2
                        return "", &amp;state.Retry{After: noNetworkRetryInterval}
                }</span>
                <span class="cov0" title="0">if httputil.IsCertExpiredOrNotValidYetError(err) </span><span class="cov0" title="0">{
                        // If the cert is expired/not-valid yet that
                        // most likely means that the devices has no
                        // ntp-synced time yet. We will retry for up
                        // to 2048s (timesyncd.conf(5) says the
                        // maximum poll time is 2048s which is
                        // 34min8s). With retry of 60s the below adds
                        // up to 37.5m.
                        switch </span>{
                        case nTentatives &lt;= 5:<span class="cov0" title="0">
                                return "", &amp;state.Retry{After: retryInterval / 2}</span>
                        case nTentatives &lt;= 10:<span class="cov0" title="0">
                                return "", &amp;state.Retry{After: retryInterval}</span>
                        case nTentatives &lt;= 15:<span class="cov0" title="0">
                                return "", &amp;state.Retry{After: retryInterval * 2}</span>
                        case nTentatives &lt;= 20:<span class="cov0" title="0">
                                return "", &amp;state.Retry{After: retryInterval * 4}</span>
                        }
                }
                <span class="cov0" title="0">if !httputil.ShouldRetryError(err) </span><span class="cov0" title="0">{
                        // a non temporary net error fully errors out and triggers a retry
                        // retries
                        return "", fmt.Errorf("cannot retrieve request-id for making a request for a serial: %v", err)
                }</span>

                <span class="cov0" title="0">return "", retryErr(t, nTentatives, "cannot retrieve request-id for making a request for a serial: %v", err)</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return "", retryBadStatus(t, nTentatives, "cannot retrieve request-id for making a request for a serial", resp)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(resp.Body)
        var requestID requestIDResp
        err = dec.Decode(&amp;requestID)
        if err != nil </span><span class="cov0" title="0">{ // assume broken i/o
                return "", retryErr(t, nTentatives, "cannot read response with request-id for making a request for a serial: %v", err)
        }</span>

        <span class="cov8" title="1">st.Lock()
        var hasPrepareSerialRequestHook bool
        err = st.Get("has-prepare-serial-request-hook", &amp;hasPrepareSerialRequestHook)
        st.Unlock()
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if hasPrepareSerialRequestHook </span><span class="cov8" title="1">{
                hooksup := &amp;hookstate.HookSetup{
                        //we can be confident this value is non-nil because we checked if the hook exists in the first place
                        Snap: regCtx.GadgetForSerialRequestConfig(),
                        Hook: "prepare-serial-request",
                }

                contextData := map[string]any{
                        "request-id": requestID.RequestID,
                }

                st.Lock()
                tr1 := config.NewTransaction(st)
                err = tr1.Set(regCtx.GadgetForSerialRequestConfig(), "registration.request-id", requestID.RequestID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("cannot set request id: %v", err)
                }</span>
                <span class="cov8" title="1">tr1.Commit()
                st.Unlock()

                _, err := hookMgr.EphemeralRunHook(context.Background(), hooksup, contextData)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("cannot run prepare serial request hook: %v", err)
                }</span>

                // update registration body again after hook has been run
                <span class="cov8" title="1">st.Lock()
                tr2 := config.NewTransaction(st)

                var bodyStr string
                err = tr2.GetMaybe(regCtx.GadgetForSerialRequestConfig(), "registration.body", &amp;bodyStr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to update registration body: %v", err)
                }</span>

                <span class="cov8" title="1">cfg.body = []byte(bodyStr)
                st.Unlock()</span>
        }

        <span class="cov8" title="1">encodedPubKey, err := asserts.EncodePublicKey(privKey.PublicKey())
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("internal error: cannot encode device public key: %v", err)

        }</span>

        <span class="cov8" title="1">headers := map[string]any{
                "brand-id":   device.Brand,
                "model":      device.Model,
                "request-id": requestID.RequestID,
                "device-key": string(encodedPubKey),
        }
        if cfg.proposedSerial != "" </span><span class="cov8" title="1">{
                headers["serial"] = cfg.proposedSerial
        }</span>

        <span class="cov8" title="1">for k, v := range regCtx.SerialRequestExtraHeaders() </span><span class="cov0" title="0">{
                headers[k] = v
        }</span>

        <span class="cov8" title="1">serialReq, err := asserts.SignWithoutAuthority(asserts.SerialRequestType, headers, cfg.body, privKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        encoder := asserts.NewEncoder(buf)
        if err := encoder.Encode(serialReq); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot encode serial-request: %v", err)
        }</span>

        <span class="cov8" title="1">for _, ancillaryAs := range regCtx.SerialRequestAncillaryAssertions() </span><span class="cov8" title="1">{
                if err := encoder.Encode(ancillaryAs); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("cannot encode ancillary assertion: %v", err)
                }</span>

        }

        <span class="cov8" title="1">return buf.String(), nil</span>
}

var errPoll = errors.New("serial-request accepted, poll later")

func submitSerialRequest(t *state.Task, serialRequest string, client *http.Client, cfg *serialRequestConfig) (*asserts.Serial, *asserts.Batch, error) <span class="cov8" title="1">{
        st := t.State()
        st.Unlock()
        defer st.Lock()

        req, err := http.NewRequest("POST", cfg.serialRequestURL, bytes.NewBufferString(serialRequest))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("internal error: cannot create serial-request request %q", cfg.serialRequestURL)
        }</span>
        <span class="cov8" title="1">req.Header.Set("User-Agent", snapdenv.UserAgent())
        req.Header.Set("Snap-Device-Capabilities", strings.Join(registrationCapabilities, " "))
        cfg.applyHeaders(req)
        req.Header.Set("Content-Type", asserts.MediaType)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, retryErr(t, 0, "cannot deliver device serial request: %v", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        switch resp.StatusCode </span>{
        case 200, 201:<span class="cov8" title="1"></span>
        case 202:<span class="cov0" title="0">
                return nil, nil, errPoll</span>
        default:<span class="cov0" title="0">
                return nil, nil, retryBadStatus(t, 0, "cannot deliver device serial request", resp)</span>
        }

        <span class="cov8" title="1">var serial *asserts.Serial
        var batch *asserts.Batch
        // decode body with stream of assertions, of which one is the serial
        dec := asserts.NewDecoder(resp.Body)
        for </span><span class="cov8" title="1">{
                got, err := dec.Decode()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{ // assume broken i/o
                        return nil, nil, retryErr(t, 0, "cannot read response to request for a serial: %v", err)
                }</span>
                <span class="cov8" title="1">if got.Type() == asserts.SerialType </span><span class="cov8" title="1">{
                        if serial != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("cannot accept more than a single device serial assertion from the device service")
                        }</span>
                        <span class="cov8" title="1">serial = got.(*asserts.Serial)</span>
                } else<span class="cov0" title="0"> {
                        if batch == nil </span><span class="cov0" title="0">{
                                batch = asserts.NewBatch(nil)
                        }</span>
                        <span class="cov0" title="0">if err := batch.Add(got); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                }
                // TODO: consider a size limit?
        }

        <span class="cov8" title="1">if serial == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot proceed, received assertion stream from the device service missing device serial assertion")
        }</span>

        <span class="cov8" title="1">return serial, batch, nil</span>
}

var httputilNewHTTPClient = httputil.NewHTTPClient

var errStoreOffline = errors.New("snap store is marked offline")

func getSerial(t *state.Task, regCtx registrationContext, privKey asserts.PrivateKey, device *auth.DeviceState, tm timings.Measurer, hookMgr *hookstate.HookManager) (serial *asserts.Serial, ancillaryBatch *asserts.Batch, err error) <span class="cov8" title="1">{
        var serialSup serialSetup
        err = t.Get("serial-setup", &amp;serialSup)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if serialSup.Serial != "" </span><span class="cov0" title="0">{
                // we got a serial, just haven't managed to save its info yet
                a, err := asserts.Decode([]byte(serialSup.Serial))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("internal error: cannot decode previously saved serial: %v", err)
                }</span>
                <span class="cov0" title="0">return a.(*asserts.Serial), nil, nil</span>
        }

        <span class="cov8" title="1">st := t.State()

        shouldRequest, err := shouldRequestSerial(st, regCtx.GadgetForSerialRequestConfig())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if !shouldRequest </span><span class="cov0" title="0">{
                return nil, nil, errStoreOffline
        }</span>

        <span class="cov8" title="1">proxyConf := proxyconf.New(st)
        client := httputilNewHTTPClient(&amp;httputil.ClientOptions{
                Timeout:            30 * time.Second,
                MayLogBody:         true,
                Proxy:              proxyConf.Conf,
                ProxyConnectHeader: http.Header{"User-Agent": []string{snapdenv.UserAgent()}},
                ExtraSSLCerts: &amp;httputil.ExtraSSLCertsFromDir{
                        Dir: dirs.SnapdStoreSSLCertsDir,
                },
        })

        cfg, err := getSerialRequestConfig(t, regCtx, client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // NB: until we get at least an Accepted (202) we need to
        // retry from scratch creating a new request-id because the
        // previous one used could have expired

        <span class="cov8" title="1">if serialSup.SerialRequest == "" </span><span class="cov8" title="1">{
                var serialRequest string
                var err error
                timings.Run(tm, "prepare-serial-request", "prepare device serial request", func(timings.Measurer) </span><span class="cov8" title="1">{
                        serialRequest, err = prepareSerialRequest(t, regCtx, privKey, device, client, cfg, hookMgr)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{ // errors &amp; retries
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">serialSup.SerialRequest = serialRequest</span>
        }

        <span class="cov8" title="1">timings.Run(tm, "submit-serial-request", "submit device serial request", func(timings.Measurer) </span><span class="cov8" title="1">{
                serial, ancillaryBatch, err = submitSerialRequest(t, serialSup.SerialRequest, client, cfg)
        }</span>)
        <span class="cov8" title="1">if err == errPoll </span><span class="cov0" title="0">{
                // we can/should reuse the serial-request
                t.Set("serial-setup", serialSup)
                return nil, nil, errPoll
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{ // errors &amp; retries
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">keyID := privKey.PublicKey().ID()
        if serial.BrandID() != device.Brand || serial.Model() != device.Model || serial.DeviceKey().ID() != keyID </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("obtained serial assertion does not match provided device identity information (brand, model, key id): %s / %s / %s != %s / %s / %s", serial.BrandID(), serial.Model(), serial.DeviceKey().ID(), device.Brand, device.Model, keyID)
        }</span>

        // cross check authority if different from brand-id
        <span class="cov8" title="1">if serial.BrandID() != serial.AuthorityID() </span><span class="cov0" title="0">{
                model := regCtx.Model()
                if !strutil.ListContains(model.SerialAuthority(), serial.AuthorityID()) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("obtained serial assertion is signed by authority %q different from brand %q without model assertion with serial-authority set to to allow for them", serial.AuthorityID(), serial.BrandID())
                }</span>
        }

        <span class="cov8" title="1">if ancillaryBatch == nil </span><span class="cov8" title="1">{
                serialSup.Serial = string(asserts.Encode(serial))
                t.Set("serial-setup", serialSup)
        }</span>

        <span class="cov8" title="1">if repeatRequestSerial == "after-got-serial" </span><span class="cov0" title="0">{
                // For testing purposes, ensure a crash in this state works.
                return nil, nil, &amp;state.Retry{}
        }</span>

        <span class="cov8" title="1">return serial, ancillaryBatch, nil</span>
}

type serialRequestConfig struct {
        requestIDURL     string
        serialRequestURL string
        headers          map[string]string
        proposedSerial   string
        body             []byte
}

func (cfg *serialRequestConfig) applyHeaders(req *http.Request) <span class="cov8" title="1">{
        for k, v := range cfg.headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>
}

func getSerialRequestConfig(t *state.Task, regCtx registrationContext, client *http.Client) (*serialRequestConfig, error) <span class="cov8" title="1">{
        var svcURL, proxyURL *url.URL

        st := t.State()
        tr := config.NewTransaction(st)
        if proxyStore, err := proxyStore(st, tr); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if proxyStore != nil </span><span class="cov0" title="0">{
                proxyURL = proxyStore.URL()
        }</span>

        <span class="cov8" title="1">cfg := serialRequestConfig{}

        gadgetName := regCtx.GadgetForSerialRequestConfig()
        // gadget is optional on classic
        if gadgetName != "" </span><span class="cov8" title="1">{
                var gadgetSt snapstate.SnapState
                if err := snapstate.Get(st, gadgetName, &amp;gadgetSt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find gadget snap %q: %v", gadgetName, err)
                }</span>

                <span class="cov8" title="1">var svcURI string
                err := tr.GetMaybe(gadgetName, "device-service.url", &amp;svcURI)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if svcURI != "" </span><span class="cov8" title="1">{
                        svcURL, err = url.Parse(svcURI)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot parse device registration base URL %q: %v", svcURI, err)
                        }</span>
                        <span class="cov8" title="1">if !strings.HasSuffix(svcURL.Path, "/") </span><span class="cov0" title="0">{
                                svcURL.Path += "/"
                        }</span>
                }

                <span class="cov8" title="1">err = tr.GetMaybe(gadgetName, "device-service.headers", &amp;cfg.headers)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var bodyStr string
                err = tr.GetMaybe(gadgetName, "registration.body", &amp;bodyStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">cfg.body = []byte(bodyStr)

                err = tr.GetMaybe(gadgetName, "registration.proposed-serial", &amp;cfg.proposedSerial)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if proxyURL != nil &amp;&amp; svcURL != nil </span><span class="cov0" title="0">{
                newEnough, err := newEnoughProxy(st, proxyURL, client)
                if err != nil </span><span class="cov0" title="0">{
                        // Ignore the proxy on any error for
                        // compatibility with previous versions of
                        // snapd.
                        //
                        // TODO: provide a way for the users to specify
                        // if they want to use the proxy store for their
                        // device-service.url or not. This needs design.
                        // (see LP:#2023166)
                        logger.Noticef("cannot reach proxy store: %v; ignore the proxy", err)
                        proxyURL = nil
                }</span>
                <span class="cov0" title="0">if !newEnough </span><span class="cov0" title="0">{
                        logger.Noticef("Proxy store does not support custom serial vault; ignoring the proxy")
                        proxyURL = nil
                }</span>
        }

        <span class="cov8" title="1">cfg.setURLs(proxyURL, svcURL)

        return &amp;cfg, nil</span>
}

func shouldRequestSerial(s *state.State, gadgetName string) (bool, error) <span class="cov8" title="1">{
        tr := config.NewTransaction(s)

        var storeAccess string
        if err := tr.GetMaybe("core", "store.access", &amp;storeAccess); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // if there isn't a gadget, just use store.access to determine if we should
        // request
        <span class="cov8" title="1">if gadgetName == "" </span><span class="cov0" title="0">{
                return storeAccess != "offline", nil
        }</span>

        <span class="cov8" title="1">var deviceServiceAccess string
        if err := tr.GetMaybe(gadgetName, "device-service.access", &amp;deviceServiceAccess); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // if we have a gadget and device-service.access is set to offline, then we
        // will not request a serial
        <span class="cov8" title="1">if deviceServiceAccess == "offline" </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">var deviceServiceURL string
        if err := tr.GetMaybe(gadgetName, "device-service.url", &amp;deviceServiceURL); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // if we'd be using the fallback device-service.url (which is the store),
        // then use store.access to determine if we should request
        <span class="cov8" title="1">if deviceServiceURL == "" </span><span class="cov8" title="1">{
                return storeAccess != "offline", nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (m *DeviceManager) doRequestSerial(t *state.Task, _ *tomb.Tomb) error <span class="cov8" title="1">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        perfTimings := state.TimingsForTask(t)
        defer perfTimings.Save(st)

        regCtx, err := m.registrationCtx(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">device, err := regCtx.Device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // NB: the keyPair is fixed for now
        <span class="cov8" title="1">privKey, err := m.keyPair()
        if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot find device key pair")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // make this idempotent, look if we have already a serial assertion
        // for privKey
        <span class="cov8" title="1">serials, err := assertstate.DB(st).FindMany(asserts.SerialType, map[string]string{
                "brand-id":            device.Brand,
                "model":               device.Model,
                "device-key-sha3-384": privKey.PublicKey().ID(),
        })
        if err != nil &amp;&amp; !errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">finish := func(serial *asserts.Serial) error </span><span class="cov8" title="1">{
                // save serial if appropriate into the device save
                // assertion database
                err := m.withSaveAssertDB(func(savedb *asserts.Database) error </span><span class="cov0" title="0">{
                        db := assertstate.DB(st)
                        retrieve := func(ref *asserts.Ref) (asserts.Assertion, error) </span><span class="cov0" title="0">{
                                return ref.Resolve(db.Find)
                        }</span>
                        <span class="cov0" title="0">b := asserts.NewBatch(nil)
                        err := b.Fetch(savedb, retrieve, func(f asserts.Fetcher) error </span><span class="cov0" title="0">{
                                // save the associated model as well
                                // as it might be required for cross-checks
                                // of the serial
                                if err := f.Save(regCtx.Model()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return f.Save(serial)</span>
                        })
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return b.CommitTo(savedb, nil)</span>
                })
                <span class="cov8" title="1">if err != nil &amp;&amp; err != errNoSaveSupport </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot save serial to device save assertion database: %v", err)
                }</span>

                <span class="cov8" title="1">if err := regCtx.FinishRegistration(serial); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.SetStatus(state.DoneStatus)
                return nil</span>
        }

        <span class="cov8" title="1">if len(serials) == 1 </span><span class="cov0" title="0">{
                // means we saved the assertion but didn't get to the end of the task
                return finish(serials[0].(*asserts.Serial))
        }</span>
        <span class="cov8" title="1">if len(serials) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: multiple serial assertions for the same device key")
        }</span>

        <span class="cov8" title="1">var serial *asserts.Serial
        var ancillaryBatch *asserts.Batch
        timings.Run(perfTimings, "get-serial", "get device serial", func(tm timings.Measurer) </span><span class="cov8" title="1">{
                serial, ancillaryBatch, err = getSerial(t, regCtx, privKey, device, tm, m.hookMgr)
        }</span>)
        <span class="cov8" title="1">if err == errPoll </span><span class="cov0" title="0">{
                t.Logf("Will poll for device serial assertion in 60 seconds")
                return &amp;state.Retry{After: retryInterval}
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{ // errors &amp; retries
                if errors.Is(err, errStoreOffline) </span><span class="cov0" title="0">{
                        t.Logf("skipping getting serial, store is marked as offline")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // TODO: the accept* helpers put the serial directly in the
        // system assertion database, that will not work
        // for 3rd-party signed serials in the case of a remodel
        // because the model is added only later. If needed, the best way
        // to fix this requires rethinking how remodel and new assertions
        // interact
        <span class="cov8" title="1">if ancillaryBatch == nil </span><span class="cov8" title="1">{
                // the device service returned only the serial
                if err := acceptSerialOnly(t, serial, perfTimings); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // the device service returned a stream of assertions
                timings.Run(perfTimings, "fetch-keys", "fetch signing key chain", func(timings.Measurer) </span><span class="cov0" title="0">{
                        err = acceptSerialPlusBatch(t, serial, ancillaryBatch)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        t.Errorf("cannot accept stream of assertions from device service: %v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">if repeatRequestSerial == "after-add-serial" </span><span class="cov0" title="0">{
                // For testing purposes, ensure a crash in this state works.
                return &amp;state.Retry{}
        }</span>

        <span class="cov8" title="1">return finish(serial)</span>
}

func acceptSerialOnly(t *state.Task, serial *asserts.Serial, perfTimings *timings.Timings) error <span class="cov8" title="1">{
        st := t.State()
        var err error
        var errAcctKey error
        // try to fetch the signing key chain of the serial
        timings.Run(perfTimings, "fetch-keys", "fetch signing key chain", func(timings.Measurer) </span><span class="cov8" title="1">{
                errAcctKey, err = fetchKeys(st, serial.SignKeyID())
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // add the serial assertion to the system assertion db
        <span class="cov8" title="1">err = assertstate.Add(st, serial)
        if err != nil </span><span class="cov0" title="0">{
                // if we had failed to fetch the signing key, retry in a bit
                if errAcctKey != nil </span><span class="cov0" title="0">{
                        t.Errorf("cannot fetch signing key for the serial: %v", errAcctKey)
                        return &amp;state.Retry{After: retryInterval}
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func acceptSerialPlusBatch(t *state.Task, serial *asserts.Serial, batch *asserts.Batch) error <span class="cov0" title="0">{
        st := t.State()
        err := batch.Add(serial)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return assertstate.AddBatch(st, batch, &amp;asserts.CommitOptions{Precheck: true})</span>
}

var repeatRequestSerial string // for tests

func fetchKeys(st *state.State, keyID string) (errAcctKey error, err error) <span class="cov8" title="1">{
        // TODO: right now any store should be good enough here but
        // that might change. As an alternative we do support
        // receiving a stream with any relevant assertions.
        sto := snapstate.Store(st, nil)
        db := assertstate.DB(st)

        retrieveError := false
        retrieve := func(ref *asserts.Ref) (asserts.Assertion, error) </span><span class="cov8" title="1">{
                st.Unlock()
                defer st.Lock()
                a, err := sto.Assertion(ref.Type, ref.PrimaryKey, nil)
                retrieveError = err != nil
                return a, err
        }</span>

        <span class="cov8" title="1">save := func(a asserts.Assertion) error </span><span class="cov8" title="1">{
                err = assertstate.Add(st, a)
                if err != nil &amp;&amp; !asserts.IsUnaccceptedUpdate(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">f := asserts.NewFetcher(db, retrieve, save)

        keyRef := &amp;asserts.Ref{
                Type:       asserts.AccountKeyType,
                PrimaryKey: []string{keyID},
        }
        if err := f.Fetch(keyRef); err != nil </span><span class="cov0" title="0">{
                if retrieveError </span><span class="cov0" title="0">{
                        return err, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2021 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "gopkg.in/tomb.v2"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/restart"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/seed"
        "github.com/snapcore/snapd/strutil"
        "github.com/snapcore/snapd/timings"
)

func taskRecoverySystemSetup(t *state.Task) (*recoverySystemSetup, error) <span class="cov0" title="0">{
        var setup recoverySystemSetup

        err := t.Get("recovery-system-setup", &amp;setup)
        if err == nil </span><span class="cov0" title="0">{
                return &amp;setup, nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // find the task which holds the data
        <span class="cov0" title="0">var id string
        if err := t.Get("recovery-system-setup-task", &amp;id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ts := t.State().Task(id)
        if ts == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: cannot find referenced task %v", id)
        }</span>
        <span class="cov0" title="0">if err := ts.Get("recovery-system-setup", &amp;setup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;setup, nil</span>
}

func setTaskRecoverySystemSetup(t *state.Task, setup *recoverySystemSetup) error <span class="cov0" title="0">{
        if t.Has("recovery-system-setup") </span><span class="cov0" title="0">{
                t.Set("recovery-system-setup", setup)
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("internal error: cannot indirectly set recovery-system-setup")</span>
}

func logNewSystemSnapFile(logfile, fileName string) error <span class="cov0" title="0">{
        if !strings.HasPrefix(filepath.Dir(fileName), boot.InitramfsUbuntuSeedDir+"/") </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: unexpected recovery system snap location %q", fileName)
        }</span>
        <span class="cov0" title="0">currentLog, err := os.ReadFile(logfile)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">modifiedLog := bytes.NewBuffer(currentLog)
        fmt.Fprintln(modifiedLog, fileName)
        return osutil.AtomicWriteFile(logfile, modifiedLog.Bytes(), 0644, 0)</span>
}

func purgeNewSystemSnapFiles(logfile string) error <span class="cov0" title="0">{
        f, err := os.Open(logfile)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer f.Close()
        s := bufio.NewScanner(f)
        for </span><span class="cov0" title="0">{
                if !s.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }
                // one file per line
                <span class="cov0" title="0">fileName := strings.TrimSpace(s.Text())
                if fileName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !strings.HasPrefix(fileName, boot.InitramfsUbuntuSeedDir) </span><span class="cov0" title="0">{
                        logger.Noticef("while removing new seed snap %q: unexpected recovery system snap location", fileName)
                        continue</span>
                }
                <span class="cov0" title="0">if err := os.Remove(fileName); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logger.Noticef("while removing new seed snap %q: %v", fileName, err)
                }</span>
        }
        <span class="cov0" title="0">return s.Err()</span>
}

type uniqueSnapsInRecoverySystem struct {
        SnapPaths []string `json:"snap-paths"`
}

func snapsUniqueToRecoverySystem(target string, systems []*System) ([]string, error) <span class="cov0" title="0">{
        // asserted snaps are shared by systems, figure out which ones are unique to
        // the system we want to remove
        requiredByOtherSystems := make(map[string]bool)
        for _, sys := range systems </span><span class="cov0" title="0">{
                if sys.Label == target </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sd, err := seed.Open(dirs.SnapSeedDir, sys.Label)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if err := sd.LoadAssertions(nil, func(*asserts.Batch) error </span><span class="cov0" title="0">{
                        return nil
                }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if err := sd.LoadMeta(seed.AllModes, nil, timings.New(nil)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = sd.Iter(func(sn *seed.Snap) error </span><span class="cov0" title="0">{
                        if sn.ID() != "" </span><span class="cov0" title="0">{
                                requiredByOtherSystems[sn.Path] = true
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">targetSeed, err := seed.Open(dirs.SnapSeedDir, target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := targetSeed.LoadAssertions(nil, func(*asserts.Batch) error </span><span class="cov0" title="0">{
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := targetSeed.LoadMeta(seed.AllModes, nil, timings.New(nil)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var uniqueToTarget []string
        err = targetSeed.Iter(func(sn *seed.Snap) error </span><span class="cov0" title="0">{
                if sn.ID() != "" &amp;&amp; !requiredByOtherSystems[sn.Path] </span><span class="cov0" title="0">{
                        uniqueToTarget = append(uniqueToTarget, sn.Path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return uniqueToTarget, nil</span>
}

func (m *DeviceManager) doRemoveRecoverySystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        systems, err := m.systems()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get recovery systems: %w", err)
        }</span>

        <span class="cov0" title="0">var setup removeRecoverySystemSetup
        if err := t.Get("remove-recovery-system-setup", &amp;setup); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">found := false
        for _, sys := range systems </span><span class="cov0" title="0">{
                if sys.Label == setup.Label </span><span class="cov0" title="0">{
                        found = true
                        if sys.Current </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot remove current recovery system: %q", setup.Label)
                        }</span>

                        <span class="cov0" title="0">if sys.DefaultRecoverySystem </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot remove default recovery system: %q", setup.Label)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        // if we couldn't find the system in the returned list of systems, then we
        // might have already attempted to remove it. in that case, we should do our
        // best effort at making sure that it is fully removed.

        <span class="cov0" title="0">if found &amp;&amp; len(systems) == 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove last recovery system: %q", setup.Label)
        }</span>

        <span class="cov0" title="0">deviceCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get device context: %w", err)
        }</span>

        // if this task has partially run before, then we might have already removed
        // some files required to load the being-removed system seed. to avoid this,
        // we first check if we already have stored a list of snaps to remove
        // (meaning, this task is being re-run). if the list isn't present, then we
        // calculate it and store it in the task state for potential future re-runs.
        <span class="cov0" title="0">var snapsToRemove uniqueSnapsInRecoverySystem
        if err := t.Get("snaps-to-remove", &amp;snapsToRemove); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot get snaps to remove from task: %w", err)
                }</span>

                <span class="cov0" title="0">uniqueSnapPaths, err := snapsUniqueToRecoverySystem(setup.Label, systems)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot get snaps unique to recovery system %q: %w", setup.Label, err)
                }</span>

                <span class="cov0" title="0">snapsToRemove.SnapPaths = uniqueSnapPaths

                t.Set("snaps-to-remove", snapsToRemove)

                // we need to unlock and re-lock the state to make sure that
                // snaps-to-remove is persisted. if we ever change how the exclusive
                // changes are handled, then we might need to revisit this.
                st.Unlock()
                st.Lock()</span>
        }

        <span class="cov0" title="0">recoverySystemsDir := filepath.Join(boot.InitramfsUbuntuSeedDir, "systems")

        if err := boot.DropRecoverySystem(deviceCtx, setup.Label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot drop recovery system %q: %v", setup.Label, err)
        }</span>

        <span class="cov0" title="0">for _, sn := range snapsToRemove.SnapPaths </span><span class="cov0" title="0">{
                path := filepath.Join(boot.InitramfsUbuntuSeedDir, "snaps", filepath.Base(sn))
                if err := os.RemoveAll(path); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot remove snap %q: %w", path, err)
                }</span>
        }

        <span class="cov0" title="0">if err := os.RemoveAll(filepath.Join(recoverySystemsDir, setup.Label)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove recovery system %q: %w", setup.Label, err)
        }</span>

        <span class="cov0" title="0">t.SetStatus(state.DoneStatus)

        return nil</span>
}

func (m *DeviceManager) doCreateRecoverySystem(t *state.Task, _ *tomb.Tomb) (err error) <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        remodelCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !remodelCtx.IsCoreBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create recovery systems on a classic (non-hybrid) system")
        }</span>

        <span class="cov0" title="0">model := remodelCtx.Model()
        isRemodel := remodelCtx.ForRemodeling()

        setup, err := taskRecoverySystemSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot obtain recovery system setup information")
        }</span>

        <span class="cov0" title="0">label := setup.Label
        systemDirectory := setup.Directory

        infoGetter := setupInfoGetter{setup: setup}

        observeSnapFileWrite := func(recoverySystemDir, where string) error </span><span class="cov0" title="0">{
                if recoverySystemDir != systemDirectory </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: unexpected recovery system path %q", recoverySystemDir)
                }</span>
                // track all the files, both asserted shared snaps and private
                // ones
                <span class="cov0" title="0">return logNewSystemSnapFile(filepath.Join(recoverySystemDir, "snapd-new-file-log"), where)</span>
        }

        <span class="cov0" title="0">var db asserts.RODatabase
        if isRemodel </span><span class="cov0" title="0">{
                // during remodel, the model assertion is not yet present in the
                // assertstate database, hence we need to use a temporary one to
                // which we explicitly add the new model assertion, as
                // createSystemForModelFromValidatedSnaps expects all relevant
                // assertions to be present in the passed db
                tempDB := assertstate.TemporaryDB(st)
                if err := tempDB.Add(model); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot create a temporary database with model: %v", err)
                }</span>
                <span class="cov0" title="0">db = tempDB</span>
        } else<span class="cov0" title="0"> {
                db = assertstate.DB(st)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if err := purgeNewSystemSnapFiles(filepath.Join(systemDirectory, "snapd-new-file-log")); err != nil </span><span class="cov0" title="0">{
                        logger.Noticef("when removing seed files: %v", err)
                }</span>
                // this is ok, as before the change with this task was created,
                // we checked that the system directory did not exist; it may
                // exist now if one of the post-create steps failed, or the the
                // task is being re-run after a reboot and creating a system
                // failed
                <span class="cov0" title="0">if err := os.RemoveAll(systemDirectory); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logger.Noticef("when removing recovery system %q: %v", label, err)
                }</span>
                <span class="cov0" title="0">if err := boot.DropRecoverySystem(remodelCtx, label); err != nil </span><span class="cov0" title="0">{
                        logger.Noticef("when dropping the recovery system %q: %v", label, err)
                }</span>
                // we could have reentered the task after a reboot, but the
                // state was set up sufficiently such that the system was
                // actually tried and ended up in the tried systems list, which
                // we should reset now
                <span class="cov0" title="0">st.Set("tried-systems", nil)</span>
        }()
        // 1. prepare recovery system from remodel snaps (or current snaps)
        // TODO: this fails when there is a partially complete system seed which
        // creation could have been interrupted by an unexpected reboot;
        // consider clearing the recovery system directory and restarting from
        // scratch
        <span class="cov0" title="0">_, err = createSystemForModelFromValidatedSnaps(st, model, label, db, &amp;infoGetter, observeSnapFileWrite)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create a recovery system with label %q for %v: %v", label, model.Model(), err)
        }</span>
        <span class="cov0" title="0">logger.Debugf("recovery system dir: %v", systemDirectory)

        // 2. keep track of the system in task state
        if err := setTaskRecoverySystemSetup(t, setup); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot record recovery system setup state: %v", err)
        }</span>

        // during a remodel, we will always test the system. this handles the case
        // that the task was created prior to a snapd update, so setup.TestSystem
        // may have defaulted to false
        <span class="cov0" title="0">skipSystemTest := !setup.TestSystem &amp;&amp; !remodelCtx.ForRemodeling()

        // if we do not need to test the system (testing not requested and task is
        // not part of a remodel), then we immediately promote the system and mark
        // it as ready to use
        if skipSystemTest </span><span class="cov0" title="0">{
                if err := boot.PromoteTriedRecoverySystem(remodelCtx, label, []string{label}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot promote recovery system %q: %v", label, err)
                }</span>

                <span class="cov0" title="0">model := remodelCtx.Model()

                if err := markSystemRecoveryCapableAndDefault(t, setup.MarkDefault, label, model); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // 3. set up boot variables for tracking the tried system state
        <span class="cov0" title="0">if err := boot.SetTryRecoverySystem(remodelCtx, label); err != nil </span><span class="cov0" title="0">{
                // rollback?
                return fmt.Errorf("cannot attempt booting into recovery system %q: %v", label, err)
        }</span>
        // 4. and set up the next boot that that system
        <span class="cov0" title="0">if err := boot.SetRecoveryBootSystemAndMode(remodelCtx, label, "recover"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set device to boot into candidate system %q: %v", label, err)
        }</span>

        // this task is done, further processing happens in finalize
        <span class="cov0" title="0">logger.Noticef("restarting into candidate system %q", label)
        return snapstate.FinishTaskWithRestart(t, state.DoneStatus, restart.RestartSystemNow, nil)</span>
}

func (m *DeviceManager) undoCreateRecoverySystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        remodelCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !remodelCtx.IsCoreBoot() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create recovery systems on a classic (non-hybrid) system")
        }</span>

        <span class="cov0" title="0">setup, err := taskRecoverySystemSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot obtain recovery system setup information")
        }</span>
        <span class="cov0" title="0">label := setup.Label

        var undoErr error

        skipSystemTest := !setup.TestSystem &amp;&amp; !remodelCtx.ForRemodeling()

        // if we were not planning on testing the system , then we need to undo
        // marking the system as seeded and recovery capable
        if skipSystemTest </span><span class="cov0" title="0">{
                // TODO: should this error go in undoErr, rather than just being logged?
                // this undoes what happens in markSystemRecoveryCapableAndDefault
                if err := unmarkSystemRecoveryCapableAndDefault(t, label); err != nil </span><span class="cov0" title="0">{
                        t.Logf("when deleting and unmarking seeded system: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if err := purgeNewSystemSnapFiles(filepath.Join(setup.Directory, "snapd-new-file-log")); err != nil </span><span class="cov0" title="0">{
                t.Logf("when removing seed files: %v", err)
        }</span>
        <span class="cov0" title="0">if err := os.RemoveAll(setup.Directory); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                t.Logf("when removing recovery system %q: %v", label, err)
                undoErr = err
        }</span> else<span class="cov0" title="0"> {
                t.Logf("removed recovery system directory %v", setup.Directory)
        }</span>

        <span class="cov0" title="0">if err := boot.DropRecoverySystem(remodelCtx, label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot drop a current recovery system %q: %v", label, err)
        }</span>

        <span class="cov0" title="0">return undoErr</span>
}

func (m *DeviceManager) doFinalizeTriedRecoverySystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        if ok, _ := restart.Pending(st); ok </span><span class="cov0" title="0">{
                // don't continue until we are in the restarted snapd
                t.Logf("Waiting for system reboot...")
                return &amp;state.Retry{}
        }</span>

        <span class="cov0" title="0">remodelCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">isRemodel := remodelCtx.ForRemodeling()

        var triedSystems []string
        // after rebooting to the recovery system and back, the system got moved
        // to the tried-systems list in the state
        if err := st.Get("tried-systems", &amp;triedSystems); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot obtain tried recovery systems: %v", err)
        }</span>

        <span class="cov0" title="0">setup, err := taskRecoverySystemSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">label := setup.Label

        logger.Debugf("finalize recovery system with label %q", label)

        if isRemodel </span><span class="cov0" title="0">{
                // so far so good, a recovery system created during remodel was
                // tested successfully
                if !strutil.ListContains(triedSystems, label) </span><span class="cov0" title="0">{
                        // system failed, trigger undoing of everything we did so far
                        return fmt.Errorf("tried recovery system %q failed", label)
                }</span>

                // XXX: candidate system is promoted to the list of good ones once we
                // complete the whole remodel change
                <span class="cov0" title="0">logger.Debugf("recovery system created during remodel will be promoted later")</span>
        } else<span class="cov0" title="0"> {
                logger.Debugf("promoting recovery system %q", label)

                if err := boot.PromoteTriedRecoverySystem(remodelCtx, label, triedSystems); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot promote recovery system %q: %v", label, err)
                }</span>

                <span class="cov0" title="0">model := remodelCtx.Model()

                if err := markSystemRecoveryCapableAndDefault(t, setup.MarkDefault, label, model); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // tried systems should be a one item list, we can clear it now
                <span class="cov0" title="0">st.Set("tried-systems", nil)</span>
        }

        // we are done
        <span class="cov0" title="0">t.SetStatus(state.DoneStatus)

        return nil</span>
}

type DefaultRecoverySystem struct {
        // System is the label that is the current default recovery system.
        System string `json:"system"`
        // Model is the model that the system was derived from.
        Model string `json:"model"`
        // BrandID is the brand account ID
        BrandID string `json:"brand-id"`
        // Revision is the revision of the model assertion
        Revision int `json:"revision"`
        // Timestamp is the timestamp of the model assertion
        Timestamp time.Time `json:"timestamp"`
        // TimeMadeDefault is the timestamp when the system was made the default
        TimeMadeDefault time.Time `json:"time-made-default"`
}

func (d *DefaultRecoverySystem) sameAs(other *System) bool <span class="cov0" title="0">{
        return d != nil &amp;&amp;
                d.System == other.Label &amp;&amp;
                d.Model == other.Model.Model() &amp;&amp;
                d.BrandID == other.Brand.AccountID()
}</span>

func markSystemRecoveryCapableAndDefault(t *state.Task, markDefault bool, label string, model *asserts.Model) error <span class="cov0" title="0">{
        if markDefault </span><span class="cov0" title="0">{
                st := t.State()

                var previousDefault DefaultRecoverySystem
                if err := st.Get("default-recovery-system", &amp;previousDefault); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">t.Set("previous-default-recovery-system", previousDefault)
                st.Set("default-recovery-system", DefaultRecoverySystem{
                        System:          label,
                        Model:           model.Model(),
                        BrandID:         model.BrandID(),
                        Revision:        model.Revision(),
                        Timestamp:       model.Timestamp(),
                        TimeMadeDefault: time.Now(),
                })</span>
        }

        <span class="cov0" title="0">if err := boot.MarkRecoveryCapableSystem(label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot mark system %q as recovery capable", label)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func unmarkSystemRecoveryCapableAndDefault(t *state.Task, label string) error <span class="cov0" title="0">{
        if err := unmarkRecoverySystemDefault(t, label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot unmark system as default recovery system: %w", err)
        }</span>

        <span class="cov0" title="0">if err := boot.UnmarkRecoveryCapableSystem(label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot unark system as recovery capable: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func unmarkRecoverySystemDefault(t *state.Task, label string) error <span class="cov0" title="0">{
        st := t.State()

        var currentDefault DefaultRecoverySystem
        if err := st.Get("default-recovery-system", &amp;currentDefault); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>

        // if the current default isn't this label, then there is nothing to do.
        <span class="cov0" title="0">if currentDefault.System != label </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var previousDefault DefaultRecoverySystem
        if err := t.Get("previous-default-recovery-system", &amp;previousDefault); err != nil </span><span class="cov0" title="0">{
                // if this task doesn't have a previous default, then we know that this
                // task did not update the default, so there is nothing to do
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">st.Set("default-recovery-system", previousDefault)

        return nil</span>
}

func (m *DeviceManager) undoFinalizeTriedRecoverySystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        remodelCtx, err := DeviceCtx(st, t, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">setup, err := taskRecoverySystemSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">label := setup.Label

        // during a remodel, setting the system as seeded and recovery capable will
        // happen in the set-model task
        if !remodelCtx.ForRemodeling() </span><span class="cov0" title="0">{
                // this undoes what happens in markSystemRecoveryCapableAndDefault
                if err := unmarkSystemRecoveryCapableAndDefault(t, label); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := boot.DropRecoverySystem(remodelCtx, label); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot drop a good recovery system %q: %v", label, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *DeviceManager) cleanupRecoverySystem(t *state.Task, _ *tomb.Tomb) error <span class="cov0" title="0">{
        st := t.State()
        st.Lock()
        defer st.Unlock()

        setup, err := taskRecoverySystemSetup(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := os.Remove(filepath.Join(setup.Directory, "snapd-new-file-log")); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2019-2020 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/devicestate/internal"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/snap"
)

func setDeviceFromModelAssertion(st *state.State, device *auth.DeviceState, model *asserts.Model) error <span class="cov0" title="0">{
        device.Brand = model.BrandID()
        device.Model = model.Model()
        return internal.SetDevice(st, device)
}</span>

func gadgetDataFromInfo(info *snap.Info, model *asserts.Model) (*gadget.GadgetData, error) <span class="cov0" title="0">{
        // we do not perform consistency validation here because that
        // has been done when the gadget was installed for
        // current/already local revisions, or in the check-snap task
        // for incoming gadgets.
        gi, err := gadget.ReadInfo(info.MountDir(), model)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;gadget.GadgetData{Info: gi, RootDir: info.MountDir()}, nil</span>
}

var systemForPreseeding = func() (label string, err error) <span class="cov0" title="0">{
        systemLabels, err := filepath.Glob(filepath.Join(dirs.SnapSeedDir, "systems", "*"))
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot list available systems: %v", err)
        }</span>
        <span class="cov0" title="0">if len(systemLabels) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no system to preseed")
        }</span>
        <span class="cov0" title="0">if len(systemLabels) &gt; 1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("expected a single system for preseeding, found %d", len(systemLabels))
        }</span>
        <span class="cov0" title="0">return filepath.Base(systemLabels[0]), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2019 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "fmt"
        "time"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/overlord/storecontext"
)

/*

This is the central logic to setup and mediate the access to the to-be
device state and dedicated store during remodeling and drive the
re-registration, leveraging the snapstate.DeviceContext/DeviceCtx and
storecontext.DeviceBackend mechanisms and also registrationContext.

Different context implementations will be used depending on the kind
of remodel, and those will play the roles/implement as needed
snapstate.DeviceContext, storecontext.DeviceBackend and
registrationContext:

* same brand/model, brand store =&gt; updateRemodel
  this is just a contextual carrier for the new model

* same brand/model different brand store =&gt; storeSwitchRemodel this
  mediates access to device state kept on the remodel change, it also
  creates a store that uses that and refers to the new brand store

* different brand/model, maybe different brand store =&gt; reregRemodel
  similar to storeSwitchRemodel case after a first phase that performs
  re-registration where the context plays registrationContext's role
  (NOT IMPLEMENTED YET)

*/

// RemodelKind designates a kind of remodeling.
type RemodelKind int

const (
        // same brand/model, brand store
        UpdateRemodel RemodelKind = iota
        // same brand/model, different brand store
        StoreSwitchRemodel
        // different brand/model, maybe different brand store
        ReregRemodel
)

func (k RemodelKind) String() string <span class="cov0" title="0">{
        switch k </span>{
        case UpdateRemodel:<span class="cov0" title="0">
                return "revision update remodel"</span>
        case StoreSwitchRemodel:<span class="cov0" title="0">
                return "store switch remodel"</span>
        case ReregRemodel:<span class="cov0" title="0">
                return "re-registration remodel"</span>
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("internal error: unknown remodel kind: %d", k))</span>
}

// ClassifyRemodel returns what kind of remodeling is going from oldModel to newModel.
func ClassifyRemodel(oldModel, newModel *asserts.Model) RemodelKind <span class="cov0" title="0">{
        if oldModel.BrandID() != newModel.BrandID() </span><span class="cov0" title="0">{
                return ReregRemodel
        }</span>
        <span class="cov0" title="0">if oldModel.Model() != newModel.Model() </span><span class="cov0" title="0">{
                return ReregRemodel
        }</span>
        <span class="cov0" title="0">if oldModel.Store() != newModel.Store() </span><span class="cov0" title="0">{
                return StoreSwitchRemodel
        }</span>
        <span class="cov0" title="0">return UpdateRemodel</span>
}

type remodelCtxKey struct {
        chgID string
}

func cachedRemodelCtx(chg *state.Change) (remodelContext, bool) <span class="cov0" title="0">{
        key := remodelCtxKey{chg.ID()}
        remodCtx, ok := chg.State().Cached(key).(remodelContext)
        return remodCtx, ok
}</span>

func cleanupRemodelCtx(chg *state.Change) <span class="cov0" title="0">{
        chg.State().Cache(remodelCtxKey{chg.ID()}, nil)
}</span>

// A remodelContext mediates the correct and isolated device state
// access and evolution during a remodel.
// All remodelContexts are at least a DeviceContext.
type remodelContext interface {
        Init(chg *state.Change)
        Finish() error
        snapstate.DeviceContext

        Kind() RemodelKind

        // initialDevice takes the current/initial device state
        // when setting up the remodel context
        initialDevice(device *auth.DeviceState) error
        // associate associates the remodel context with the change
        // and caches it
        associate(chg *state.Change)
        // setTriedRecoverySystemLabel records the label of a good recovery
        // system created during remodel
        setRecoverySystemLabel(label string)
}

// remodelCtx returns a remodeling context for the given transition.
// It constructs and caches a dedicated store as needed as well.
func remodelCtx(st *state.State, oldModel, newModel *asserts.Model) (remodelContext, error) <span class="cov0" title="0">{
        var remodCtx remodelContext

        devMgr := deviceMgr(st)

        switch kind := ClassifyRemodel(oldModel, newModel); kind </span>{
        case UpdateRemodel:<span class="cov0" title="0">
                // simple context for the simple case
                groundCtx := groundDeviceContext{
                        model:      newModel,
                        systemMode: devMgr.SystemMode(SysAny),
                }
                remodCtx = &amp;updateRemodelContext{baseRemodelContext{
                        groundDeviceContext: groundCtx,

                        oldModel:  oldModel,
                        deviceMgr: devMgr,
                        st:        st,
                }}</span>
        case StoreSwitchRemodel:<span class="cov0" title="0">
                remodCtx = newNewStoreRemodelContext(st, devMgr, newModel, oldModel)</span>
        case ReregRemodel:<span class="cov0" title="0">
                remodCtx = &amp;reregRemodelContext{
                        newStoreRemodelContext: newNewStoreRemodelContext(st, devMgr, newModel, oldModel),
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported remodel: %s", kind)</span>
        }

        <span class="cov0" title="0">device, err := devMgr.device()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := remodCtx.initialDevice(device); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return remodCtx, nil</span>
}

// remodelCtxFromTask returns a possibly cached remodeling context associated
// with the task via its change, if task is nil or the task change
// is not a remodeling it will return ErrNoState.
func remodelCtxFromTask(t *state.Task) (remodelContext, error) <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return nil, state.ErrNoState
        }</span>
        <span class="cov8" title="1">chg := t.Change()
        if chg == nil </span><span class="cov0" title="0">{
                return nil, state.ErrNoState
        }</span>

        <span class="cov8" title="1">var encNewModel string
        if err := chg.Get("new-model", &amp;encNewModel); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // shortcut, cached?
        <span class="cov0" title="0">if remodCtx, ok := cachedRemodelCtx(chg); ok </span><span class="cov0" title="0">{
                return remodCtx, nil
        }</span>

        <span class="cov0" title="0">st := t.State()
        oldModel, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: cannot find old model during remodel: %v", err)
        }</span>
        <span class="cov0" title="0">newModelA, err := asserts.Decode([]byte(encNewModel))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">newModel, ok := newModelA.(*asserts.Model)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: cannot use a remodel new-model, wrong type")
        }</span>

        <span class="cov0" title="0">remodCtx, err := remodelCtx(st, oldModel, newModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">remodCtx.associate(chg)
        return remodCtx, nil</span>
}

type baseRemodelContext struct {
        // groundDeviceContext will carry the new device model
        groundDeviceContext
        oldModel *asserts.Model

        deviceMgr *DeviceManager
        st        *state.State

        recoverySystemLabel string
}

func (rc *baseRemodelContext) ForRemodeling() bool <span class="cov0" title="0">{
        return true
}</span>

func (rc *baseRemodelContext) GroundContext() snapstate.DeviceContext <span class="cov0" title="0">{
        return &amp;groundDeviceContext{
                model:      rc.oldModel,
                systemMode: rc.systemMode,
        }
}</span>

func (rc *baseRemodelContext) initialDevice(*auth.DeviceState) error <span class="cov0" title="0">{
        // do nothing
        return nil
}</span>

func (rc *baseRemodelContext) cacheViaChange(chg *state.Change, remodCtx remodelContext) <span class="cov0" title="0">{
        chg.State().Cache(remodelCtxKey{chg.ID()}, remodCtx)
}</span>

func (rc *baseRemodelContext) init(chg *state.Change) <span class="cov0" title="0">{
        chg.Set("new-model", string(asserts.Encode(rc.model)))
}</span>

func (rc *baseRemodelContext) SystemMode() string <span class="cov0" title="0">{
        return rc.systemMode
}</span>

func (rc *baseRemodelContext) setRecoverySystemLabel(label string) <span class="cov0" title="0">{
        rc.recoverySystemLabel = label
}</span>

// updateRunModeSystem updates the device context used during boot and makes a
// record of the new seeded system.
func (rc *baseRemodelContext) updateRunModeSystem() error <span class="cov0" title="0">{
        hasSystemSeed, err := checkForSystemSeed(rc.st, &amp;rc.groundDeviceContext)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot look up ubuntu seed role: %w", err)
        }</span>

        <span class="cov0" title="0">if rc.model.Grade() == asserts.ModelGradeUnset || !hasSystemSeed </span><span class="cov0" title="0">{
                // nothing special for non-UC20 systems or systems without a real seed
                // partition
                return nil
        }</span>
        <span class="cov0" title="0">if rc.recoverySystemLabel == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: recovery system label is unset during remodel finish")
        }</span>
        // for UC20 systems we need record the fact that a new model is used for
        // booting and consider a new recovery system as as seeded
        <span class="cov0" title="0">oldDeviceContext := rc.GroundContext()
        newDeviceContext := &amp;rc.groundDeviceContext
        err = boot.DeviceChange(oldDeviceContext, newDeviceContext, rc.st.Unlocker())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot switch device: %v", err)
        }</span>
        <span class="cov0" title="0">now := time.Now()
        if err := rc.deviceMgr.recordSeededSystem(rc.st, &amp;seededSystem{
                System:    rc.recoverySystemLabel,
                Model:     rc.model.Model(),
                BrandID:   rc.model.BrandID(),
                Revision:  rc.model.Revision(),
                Timestamp: rc.model.Timestamp(),
                SeedTime:  now,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot record a new seeded system: %v", err)
        }</span>

        <span class="cov0" title="0">rc.st.Set("default-recovery-system", DefaultRecoverySystem{
                System:          rc.recoverySystemLabel,
                Model:           rc.model.Model(),
                BrandID:         rc.model.BrandID(),
                Revision:        rc.model.Revision(),
                Timestamp:       rc.model.Timestamp(),
                TimeMadeDefault: now,
        })

        if err := boot.MarkRecoveryCapableSystem(rc.recoverySystemLabel); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot mark system %q as recovery capable", rc.recoverySystemLabel)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// updateRemodelContext: model assertion revision-only update remodel
// (no change to brand/model or store)
type updateRemodelContext struct {
        baseRemodelContext
}

func (rc *updateRemodelContext) Kind() RemodelKind <span class="cov0" title="0">{
        return UpdateRemodel
}</span>

func (rc *updateRemodelContext) associate(chg *state.Change) <span class="cov0" title="0">{
        rc.cacheViaChange(chg, rc)
}</span>

func (rc *updateRemodelContext) Init(chg *state.Change) <span class="cov0" title="0">{
        rc.init(chg)

        rc.associate(chg)
}</span>

func (rc *updateRemodelContext) Store() snapstate.StoreService <span class="cov0" title="0">{
        return nil
}</span>

func (rc *updateRemodelContext) Finish() error <span class="cov0" title="0">{
        // nothing special to do as part of the finish action, so just run the
        // update boot step
        return rc.updateRunModeSystem()
}</span>

// newStoreRemodelContext: remodel needing a new store session
// (for change of store (or brand/model))
type newStoreRemodelContext struct {
        baseRemodelContext

        // device state storage before this is associate with a change
        deviceState *auth.DeviceState
        // the associated change
        remodelChange *state.Change

        store snapstate.StoreService
}

func newNewStoreRemodelContext(st *state.State, devMgr *DeviceManager, newModel, oldModel *asserts.Model) *newStoreRemodelContext <span class="cov0" title="0">{
        rc := &amp;newStoreRemodelContext{}
        groundCtx := groundDeviceContext{
                model:      newModel,
                systemMode: devMgr.SystemMode(SysAny),
        }
        rc.baseRemodelContext = baseRemodelContext{
                groundDeviceContext: groundCtx,
                oldModel:            oldModel,

                deviceMgr: devMgr,
                st:        st,
        }
        rc.store = devMgr.newStore(rc.deviceBackend())
        return rc
}</span>

func (rc *newStoreRemodelContext) Kind() RemodelKind <span class="cov0" title="0">{
        return StoreSwitchRemodel
}</span>

func (rc *newStoreRemodelContext) associate(chg *state.Change) <span class="cov0" title="0">{
        rc.remodelChange = chg
        rc.cacheViaChange(chg, rc)
}</span>

func (rc *newStoreRemodelContext) initialDevice(device *auth.DeviceState) error <span class="cov0" title="0">{
        device1 := *device
        // we will need a new one, it might embed the store as well
        device1.SessionMacaroon = ""
        rc.deviceState = &amp;device1
        return nil
}</span>

func (rc *newStoreRemodelContext) init(chg *state.Change) <span class="cov0" title="0">{
        rc.baseRemodelContext.init(chg)

        chg.Set("device", rc.deviceState)
        rc.deviceState = nil
}</span>

func (rc *newStoreRemodelContext) Init(chg *state.Change) <span class="cov0" title="0">{
        rc.init(chg)

        rc.associate(chg)
}</span>

func (rc *newStoreRemodelContext) Store() snapstate.StoreService <span class="cov0" title="0">{
        return rc.store
}</span>

func (rc *newStoreRemodelContext) device() (*auth.DeviceState, error) <span class="cov0" title="0">{
        var err error
        var device auth.DeviceState
        if rc.remodelChange == nil </span><span class="cov0" title="0">{
                // no remodelChange yet
                device = *rc.deviceState
        }</span> else<span class="cov0" title="0"> {
                err = rc.remodelChange.Get("device", &amp;device)
        }</span>
        <span class="cov0" title="0">return &amp;device, err</span>
}

func (rc *newStoreRemodelContext) setCtxDevice(device *auth.DeviceState) <span class="cov0" title="0">{
        if rc.remodelChange == nil </span><span class="cov0" title="0">{
                // no remodelChange yet
                rc.deviceState = device
        }</span> else<span class="cov0" title="0"> {
                rc.remodelChange.Set("device", device)
        }</span>
}

func (rc *newStoreRemodelContext) Finish() error <span class="cov0" title="0">{
        // expose the device state of the remodel with the new session
        // to the rest of the system
        remodelDevice, err := rc.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rc.deviceMgr.setDevice(remodelDevice); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return rc.updateRunModeSystem()</span>
}

func (rc *newStoreRemodelContext) deviceBackend() storecontext.DeviceBackend <span class="cov0" title="0">{
        return &amp;remodelDeviceBackend{rc}
}</span>

type remodelDeviceBackend struct {
        *newStoreRemodelContext
}

func (b remodelDeviceBackend) Device() (*auth.DeviceState, error) <span class="cov0" title="0">{
        return b.device()
}</span>

func (b remodelDeviceBackend) SetDevice(device *auth.DeviceState) error <span class="cov0" title="0">{
        b.setCtxDevice(device)
        return nil
}</span>

func (b remodelDeviceBackend) Model() (*asserts.Model, error) <span class="cov0" title="0">{
        return b.model, nil
}</span>

func (b remodelDeviceBackend) Serial() (*asserts.Serial, error) <span class="cov0" title="0">{
        // this the shared logic, also correct for the rereg case
        // we should lookup the serial with the remodeling device state
        device, err := b.device()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return findSerial(b.st, device)</span>
}

// reregRemodelContext: remodel for a change of brand/model
type reregRemodelContext struct {
        *newStoreRemodelContext

        origModel  *asserts.Model
        origSerial *asserts.Serial
}

func (rc *reregRemodelContext) Kind() RemodelKind <span class="cov0" title="0">{
        return ReregRemodel
}</span>

func (rc *reregRemodelContext) associate(chg *state.Change) <span class="cov0" title="0">{
        rc.remodelChange = chg
        rc.cacheViaChange(chg, rc)
}</span>

func (rc *reregRemodelContext) initialDevice(device *auth.DeviceState) error <span class="cov0" title="0">{
        origModel, err := findModel(rc.st)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">origSerial, err := findSerial(rc.st, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot find current serial before proceeding with re-registration: %v", err)
        }</span>
        <span class="cov0" title="0">rc.origModel = origModel
        rc.origSerial = origSerial

        // starting almost from scratch with only device-key
        rc.deviceState = &amp;auth.DeviceState{
                Brand: rc.model.BrandID(),
                Model: rc.model.Model(),
                KeyID: device.KeyID,
        }
        return nil</span>
}

func (rc *reregRemodelContext) Init(chg *state.Change) <span class="cov0" title="0">{
        rc.init(chg)

        rc.associate(chg)
}</span>

// reregRemodelContext impl of registrationContext

func (rc *reregRemodelContext) Device() (*auth.DeviceState, error) <span class="cov0" title="0">{
        return rc.device()
}</span>

func (rc *reregRemodelContext) GadgetForSerialRequestConfig() string <span class="cov0" title="0">{
        return rc.origModel.Gadget()
}</span>

func (rc *reregRemodelContext) SerialRequestExtraHeaders() map[string]any <span class="cov0" title="0">{
        return map[string]any{
                "original-brand-id": rc.origSerial.BrandID(),
                "original-model":    rc.origSerial.Model(),
                "original-serial":   rc.origSerial.Serial(),
        }
}</span>

func (rc *reregRemodelContext) SerialRequestAncillaryAssertions() []asserts.Assertion <span class="cov0" title="0">{
        return []asserts.Assertion{rc.model, rc.origSerial}
}</span>

func (rc *reregRemodelContext) FinishRegistration(serial *asserts.Serial) error <span class="cov0" title="0">{
        device, err := rc.device()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">device.Serial = serial.Serial()
        rc.setCtxDevice(device)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "errors"
        "fmt"
        "path/filepath"
        "strings"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/boot"
        "github.com/snapcore/snapd/dirs"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/seed"
        "github.com/snapcore/snapd/seed/seedwriter"
        "github.com/snapcore/snapd/snap"
        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/snap/snapfile"
        "github.com/snapcore/snapd/strutil"
)

func checkSystemRequestConflict(st *state.State, systemLabel string) error <span class="cov0" title="0">{
        st.Lock()
        defer st.Unlock()

        var seeded bool
        if err := st.Get("seeded", &amp;seeded); err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if seeded </span><span class="cov0" title="0">{
                // the system is fully seeded already
                return nil
        }</span>

        // inspect the current system which is stored in modeenv, note we are
        // holding the state lock so there is no race against mark-seeded
        // clearing recovery system; recovery system is not cleared when seeding
        // fails
        <span class="cov0" title="0">modeEnv, err := boot.MaybeReadModeenv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                // non UC20 systems do not support actions, no conflict can
                // happen
                return nil
        }</span>

        // not yet fully seeded, hold off requests for the system that is being
        // seeded, but allow requests for other systems
        <span class="cov0" title="0">if modeEnv.RecoverySystem == systemLabel </span><span class="cov0" title="0">{
                return &amp;snapstate.ChangeConflictError{
                        ChangeKind: "seed",
                        Message:    "cannot request system action, system is seeding",
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func systemFromSeed(label string, current *currentSystem, defaultRecoverySystem *DefaultRecoverySystem) (*System, error) <span class="cov0" title="0">{
        _, sys, err := loadSeedAndSystem(label, current, defaultRecoverySystem)
        return sys, err
}</span>

func loadSeedAndSystem(label string, current *currentSystem, defaultRecoverySystem *DefaultRecoverySystem) (seed.Seed, *System, error) <span class="cov0" title="0">{
        s, err := seedOpen(dirs.SnapSeedDir, label)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot open: %v", err)
        }</span>
        <span class="cov0" title="0">if err := s.LoadAssertions(nil, nil); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot load assertions for label %q: %v", label, err)
        }</span>
        // get the model
        <span class="cov0" title="0">model := s.Model()
        brand, err := s.Brand()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot obtain brand: %v", err)
        }</span>

        <span class="cov0" title="0">var optionalContainers OptionalContainers
        if copier, ok := s.(seed.Copier); ok </span><span class="cov0" title="0">{
                oc, err := copier.OptionalContainers()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("cannot list optional containers: %v", err)
                }</span>
                <span class="cov0" title="0">optionalContainers = OptionalContainers{
                        Snaps:      oc.Snaps,
                        Components: oc.Components,
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Debugf("seed %q does not support copying", label)
        }</span>

        <span class="cov0" title="0">system := &amp;System{
                Current:            false,
                Label:              label,
                Model:              model,
                Brand:              brand,
                Actions:            defaultSystemActions,
                OptionalContainers: optionalContainers,
        }
        system.DefaultRecoverySystem = defaultRecoverySystem.sameAs(system)
        if current.sameAs(system) </span><span class="cov0" title="0">{
                system.Current = true
                system.Actions = current.actions
        }</span>
        <span class="cov0" title="0">return s, system, nil</span>
}

type currentSystem struct {
        *seededSystem
        actions []SystemAction
}

func (c *currentSystem) sameAs(other *System) bool <span class="cov0" title="0">{
        return c != nil &amp;&amp;
                c.System == other.Label &amp;&amp;
                c.Model == other.Model.Model() &amp;&amp;
                c.BrandID == other.Brand.AccountID()
}</span>

func currentSystemForMode(st *state.State, mode string) (*currentSystem, error) <span class="cov0" title="0">{
        var system *seededSystem
        var actions []SystemAction
        var err error

        switch mode </span>{
        case "run":<span class="cov0" title="0">
                actions = currentSystemActions
                system, err = currentSeededSystem(st)</span>
        case "install":<span class="cov0" title="0">
                // there is no current system for install mode
                return nil, nil</span>
        case "recover":<span class="cov0" title="0">
                actions = recoverSystemActions
                // recover mode uses modeenv for reference
                system, err = seededSystemFromModeenv()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("internal error: cannot identify current system for unsupported mode %q", mode)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">currentSys := &amp;currentSystem{
                seededSystem: system,
                actions:      actions,
        }
        return currentSys, nil</span>
}

func currentSeededSystem(st *state.State) (*seededSystem, error) <span class="cov0" title="0">{
        var whatseeded []seededSystem
        if err := st.Get("seeded-systems", &amp;whatseeded); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(whatseeded) == 0 </span><span class="cov0" title="0">{
                // unexpected
                return nil, state.ErrNoState
        }</span>
        // seeded systems are prepended to the list, so the most recently seeded
        // one comes first
        <span class="cov0" title="0">return &amp;whatseeded[0], nil</span>
}

func seededSystemFromModeenv() (*seededSystem, error) <span class="cov0" title="0">{
        modeEnv, err := boot.MaybeReadModeenv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if modeEnv == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: modeenv does not exist")
        }</span>
        <span class="cov0" title="0">if modeEnv.RecoverySystem == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: recovery system is unset")
        }</span>

        <span class="cov0" title="0">system, err := systemFromSeed(modeEnv.RecoverySystem, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">seededSys := &amp;seededSystem{
                System:    modeEnv.RecoverySystem,
                Model:     system.Model.Model(),
                BrandID:   system.Model.BrandID(),
                Revision:  system.Model.Revision(),
                Timestamp: system.Model.Timestamp(),
                // SeedTime is intentionally left unset
        }
        return seededSys, nil</span>
}

// infoGetter is an interface that helps us get information about snaps and
// components that are being installed in a new recovery system.
type infoGetter interface {
        // SnapInfo is expected to return for a given snap name a snap.Info for that
        // snap, a path on disk where the snap file can be found, and whether the
        // snap is present. The last bit is relevant for non-essential snaps
        // mentioned in the model, which if present and having an 'optional'
        // presence in the model, will be added to the recovery system.
        SnapInfo(st *state.State, name string) (info *snap.Info, path string, snapIsPresent bool, err error)
        // ComponentInfo is expected to return for a given component ref a
        // snap.ComponentInfo for that component, a path on disk where the component
        // file can be found, and whether the component is present. The last bit is
        // relevant for non-essential components mentioned in the model, which if
        // present and having an 'optional' presence in the model, will be added to
        // the recovery system.
        ComponentInfo(st *state.State, cref naming.ComponentRef, snapInfo *snap.Info) (info *snap.ComponentInfo, path string, present bool, err error)
}

// setupInfoGetter is an infoGetter that uses a recoverySystemSetup to get
// information about snaps and components that are being installed in a new
// recovery system.
type setupInfoGetter struct {
        setup *recoverySystemSetup
}

func (ig *setupInfoGetter) ComponentInfo(st *state.State, cref naming.ComponentRef, snapInfo *snap.Info) (info *snap.ComponentInfo, path string, present bool, err error) <span class="cov0" title="0">{
        // components will come from one of these places:
        //   * passed into the task via a list of side infos (these would have
        //     come from a user posting snaps via the API)
        //   * have just been downloaded by a task in setup.ComponentSetupTasks
        //   * already installed on the system

        logger.Debugf("requested info for component %q being installed during remodel", cref)
        for _, l := range ig.setup.LocalComponents </span><span class="cov0" title="0">{
                if l.SideInfo.Component != cref </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">snapf, err := snapfile.Open(l.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">info, err := snap.ReadComponentInfoFromContainer(snapf, snapInfo, l.SideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">return info, l.Path, true, nil</span>
        }

        // in a remodel scenario, the components may need to be fetched and thus
        // their content can be different from what we have already installed, so we
        // should first check the download tasks before consulting snapstate
        <span class="cov0" title="0">for _, tskID := range ig.setup.ComponentSetupTasks </span><span class="cov0" title="0">{
                taskWithComponentSetup := st.Task(tskID)
                compsup, snapsup, err := snapstate.TaskComponentSetup(taskWithComponentSetup)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>
                <span class="cov0" title="0">if compsup.CompSideInfo.Component != cref </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mountFile := compsup.BlobPath(snapsup.InstanceName())

                f, err := snapfile.Open(mountFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">info, err = snap.ReadComponentInfoFromContainer(f, snapInfo, compsup.CompSideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">return info, mountFile, true, nil</span>
        }

        // either a remodel scenario, in which case the component is not among the
        // ones being fetched, or just creating a recovery system, in which case we
        // use the components that are already installed

        <span class="cov0" title="0">var snapst snapstate.SnapState
        if err := snapstate.Get(st, snapInfo.InstanceName(), &amp;snapst); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                        return nil, "", false, nil
                }</span>
                <span class="cov0" title="0">return nil, "", false, err</span>
        }

        <span class="cov0" title="0">info, err = snapst.CurrentComponentInfo(cref)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, snapstate.ErrNoCurrent) </span><span class="cov0" title="0">{
                        return nil, "", false, nil
                }</span>
                <span class="cov0" title="0">return nil, "", false, err</span>
        }

        <span class="cov0" title="0">cpi := snap.MinimalComponentContainerPlaceInfo(
                cref.ComponentName,
                info.Revision,
                snapInfo.InstanceName(),
        )

        return info, cpi.MountFile(), true, nil</span>
}

func (ig *setupInfoGetter) SnapInfo(st *state.State, name string) (info *snap.Info, path string, present bool, err error) <span class="cov0" title="0">{
        // snaps will come from one of these places:
        //   * passed into the task via a list of side infos (these would have
        //     come from a user posting snaps via the API)
        //   * have just been downloaded by a task in setup.SnapSetupTasks
        //   * already installed on the system

        for _, l := range ig.setup.LocalSnaps </span><span class="cov0" title="0">{
                if l.SideInfo.RealName != name </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">snapf, err := snapfile.Open(l.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">info, err := snap.ReadInfoFromSnapFile(snapf, l.SideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">return info, l.Path, true, nil</span>
        }

        // in a remodel scenario, the snaps may need to be fetched and thus
        // their content can be different from what we have in already installed
        // snaps, so we should first check the download tasks before consulting
        // snapstate
        <span class="cov0" title="0">logger.Debugf("requested info for snap %q being installed during remodel", name)
        for _, tskID := range ig.setup.SnapSetupTasks </span><span class="cov0" title="0">{
                taskWithSnapSetup := st.Task(tskID)
                snapsup, err := snapstate.TaskSnapSetup(taskWithSnapSetup)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>
                <span class="cov0" title="0">if snapsup.SnapName() != name </span><span class="cov0" title="0">{
                        continue</span>
                }
                // by the time this task runs, the file has already been
                // downloaded and validated
                <span class="cov0" title="0">snapFile, err := snapfile.Open(snapsup.BlobPath())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>
                <span class="cov0" title="0">info, err = snap.ReadInfoFromSnapFile(snapFile, snapsup.SideInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", false, err
                }</span>

                <span class="cov0" title="0">return info, info.MountFile(), true, nil</span>
        }

        // either a remodel scenario, in which case the snap is not
        // among the ones being fetched, or just creating a recovery
        // system, in which case we use the snaps that are already
        // installed

        <span class="cov0" title="0">info, err = snapstate.CurrentInfo(st, name)
        if err == nil </span><span class="cov0" title="0">{
                hash, _, err := asserts.SnapFileSHA3_384(info.MountFile())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", true, fmt.Errorf("cannot compute SHA3 of snap file: %v", err)
                }</span>
                <span class="cov0" title="0">info.Sha3_384 = hash
                return info, info.MountFile(), true, nil</span>
        }
        <span class="cov0" title="0">if _, ok := err.(*snap.NotInstalledError); !ok </span><span class="cov0" title="0">{
                return nil, "", false, err
        }</span>
        <span class="cov0" title="0">return nil, "", false, nil</span>
}

// snapWriteObserveFunc is called with the recovery system directory and the
// path to a snap file being written. The snap file may be written to a location
// under the common snaps directory.
type snapWriteObserveFunc func(systemDir, where string) error

// createSystemForModelFromValidatedSnaps creates a new recovery system for the
// specified model with the specified label using the snaps in the database and
// the getInfo function.
//
// The function returns the directory of the new recovery system as well as the
// set of absolute file paths to the new snap files that were written for the
// recovery system - some snaps may be in the recovery system directory while
// others may be in the common snaps directory shared between multiple recovery
// systems on ubuntu-seed.
func createSystemForModelFromValidatedSnaps(
        st *state.State,
        model *asserts.Model,
        label string,
        db asserts.RODatabase,
        getInfo infoGetter,
        observeWrite snapWriteObserveFunc,
) (dir string, err error) <span class="cov0" title="0">{
        if model.Grade() == asserts.ModelGradeUnset </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot create a system for pre-UC20 model")
        }</span>

        <span class="cov0" title="0">logger.Noticef("creating recovery system with label %q for %q", label, model.Model())

        // TODO: should that path provided by boot package instead?
        recoverySystemDirInRootDir := filepath.Join("/systems", label)
        assertedSnapsDir := filepath.Join(boot.InitramfsUbuntuSeedDir, "snaps")
        recoverySystemDir := filepath.Join(boot.InitramfsUbuntuSeedDir, recoverySystemDirInRootDir)

        wOpts := &amp;seedwriter.Options{
                // RW mount of ubuntu-seed
                SeedDir: boot.InitramfsUbuntuSeedDir,
                Label:   label,
                // due to the way that temp files are handled in daemon, they do not
                // have .snap or .comp extensions. this flag lets us ignore that
                // requirement.
                IgnoreOptionFileExtentions: true,
        }
        w, err := seedwriter.New(model, wOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">optsSnaps := make([]*seedwriter.OptionsSnap, 0, len(model.RequiredWithEssentialSnaps()))
        // collect all snaps that are present
        modelSnaps := make(map[string]*snap.Info)
        // mapping of snap names to map of component names to component infos.
        modelComponents := make(map[string]map[string]*snap.ComponentInfo)

        getModelSnap := func(sn *asserts.ModelSnap, essential bool) error </span><span class="cov0" title="0">{
                kind := "essential"
                if !essential </span><span class="cov0" title="0">{
                        kind = "non-essential"
                        if sn.Presence != "" </span><span class="cov0" title="0">{
                                kind = fmt.Sprintf("non-essential but %v", sn.Presence)
                        }</span>
                }
                <span class="cov0" title="0">snapInfo, snapPath, present, err := getInfo.SnapInfo(st, sn.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot obtain %v snap information: %v", kind, err)
                }</span>
                <span class="cov0" title="0">if !essential &amp;&amp; !present &amp;&amp; sn.Presence == "optional" </span><span class="cov0" title="0">{
                        // non-essential snap which is declared as optionally
                        // present in the model
                        return nil
                }</span>
                // grab those
                <span class="cov0" title="0">logger.Debugf("%v snap: %v", kind, sn.Name)
                if !present </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: %v snap %q not present", kind, sn.Name)
                }</span>
                <span class="cov0" title="0">if _, ok := modelSnaps[snapPath]; ok </span><span class="cov0" title="0">{
                        // we've already seen this snap
                        return nil
                }</span>

                <span class="cov0" title="0">var comps []seedwriter.OptionsComponent
                modelComponents[sn.Name] = make(map[string]*snap.ComponentInfo)
                for compName, comp := range sn.Components </span><span class="cov0" title="0">{
                        cref := naming.NewComponentRef(sn.Name, compName)
                        compInfo, compPath, present, err := getInfo.ComponentInfo(st, cref, snapInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot obtain component %q information: %v", cref, err)
                        }</span>

                        <span class="cov0" title="0">if !present </span><span class="cov0" title="0">{
                                if comp.Presence == "optional" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("internal error: required component %q not present", cref)</span>
                        }

                        // since everything here is done by path, we omit the component
                        // names. this is what the seedwriter code wants.
                        <span class="cov0" title="0">comps = append(comps, seedwriter.OptionsComponent{
                                Path: compPath,
                        })
                        modelComponents[sn.Name][compPath] = compInfo</span>
                }

                // present locally
                // TODO: for grade dangerous we could have a channel here which is not
                //       the model channel, handle that here
                <span class="cov0" title="0">optsSnaps = append(optsSnaps, &amp;seedwriter.OptionsSnap{
                        Path:       snapPath,
                        Components: comps,
                })
                modelSnaps[snapPath] = snapInfo
                return nil</span>
        }

        <span class="cov0" title="0">for _, sn := range model.EssentialSnaps() </span><span class="cov0" title="0">{
                const essential = true
                if err := getModelSnap(sn, essential); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        // snapd is implicitly needed
        <span class="cov0" title="0">const snapdIsEssential = true
        if err := getModelSnap(&amp;asserts.ModelSnap{Name: "snapd"}, snapdIsEssential); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">for _, sn := range model.SnapsWithoutEssential() </span><span class="cov0" title="0">{
                const essential = false
                if err := getModelSnap(sn, essential); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">if err := w.SetOptionsSnaps(optsSnaps); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">newFetcher := func(save func(asserts.Assertion) error) asserts.Fetcher </span><span class="cov0" title="0">{
                fromDB := func(ref *asserts.Ref) (asserts.Assertion, error) </span><span class="cov0" title="0">{
                        return ref.Resolve(db.Find)
                }</span>

                <span class="cov0" title="0">seqFromDB := func(ref *asserts.AtSequence) (asserts.Assertion, error) </span><span class="cov0" title="0">{
                        if ref.Sequence &lt;= 0 </span><span class="cov0" title="0">{
                                hdrs, err := asserts.HeadersFromSequenceKey(ref.Type, ref.SequenceKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">return db.FindSequence(ref.Type, hdrs, -1, -1)</span>
                        }
                        <span class="cov0" title="0">return ref.Resolve(db.Find)</span>
                }

                <span class="cov0" title="0">return asserts.NewSequenceFormingFetcher(db, fromDB, seqFromDB, save)</span>
        }

        <span class="cov0" title="0">sf := seedwriter.MakeSeedAssertionFetcher(newFetcher)
        if err := w.Start(db, sf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // past this point the system directory is present

        // TODO:COMPS: take into account local components
        <span class="cov0" title="0">localSnaps, err := w.LocalSnaps()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">localARefs := make(map[*seedwriter.SeedSnap][]*asserts.Ref)
        for _, sn := range localSnaps </span><span class="cov0" title="0">{
                info, ok := modelSnaps[sn.Path]
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("internal error: no snap info for %q", sn.Path)
                }</span>

                <span class="cov0" title="0">asserted := info.ID() != ""

                // TODO: the side info derived here can be different from what
                // we have in snap.Info, but getting it this way can be
                // expensive as we need to compute the hash, try to find a
                // better way
                _, assertions, err := seedwriter.DeriveSideInfo(sn.Path, model, sf, db)
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        // snap info from state must have come from the store, so it is
                        // unexpected if no assertions for it were found
                        <span class="cov0" title="0">if asserted </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("internal error: no assertions for asserted snap with ID: %v", info.SnapID)
                        }</span>
                }

                <span class="cov0" title="0">seedComps := make(map[string]*seedwriter.SeedComponent, len(sn.Components))
                for compPath, comp := range modelComponents[info.SnapName()] </span><span class="cov0" title="0">{
                        if asserted </span><span class="cov0" title="0">{
                                _, compAssertions, err := seedwriter.DeriveComponentSideInfo(compPath, comp, info, model, sf, db)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>

                                <span class="cov0" title="0">assertions = append(assertions, compAssertions...)</span>
                        }

                        <span class="cov0" title="0">seedComps[comp.Component.ComponentName] = &amp;seedwriter.SeedComponent{
                                ComponentRef: comp.Component,
                                Path:         compPath,
                                Info:         comp,
                        }</span>
                }

                <span class="cov0" title="0">if err := w.SetInfo(sn, info, seedComps); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">localARefs[sn] = assertions</span>
        }

        <span class="cov0" title="0">if err := w.InfoDerived(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">retrieveAsserts := func(sn, _, _ *seedwriter.SeedSnap) ([]*asserts.Ref, error) </span><span class="cov0" title="0">{
                return localARefs[sn], nil
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // get the list of snaps we need in this iteration
                toDownload, err := w.SnapsToDownload()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // which should be empty as all snaps should be accounted for
                // already
                <span class="cov0" title="0">if len(toDownload) &gt; 0 </span><span class="cov0" title="0">{
                        which := make([]string, 0, len(toDownload))
                        for _, sn := range toDownload </span><span class="cov0" title="0">{
                                which = append(which, sn.SnapName())
                        }</span>
                        <span class="cov0" title="0">return "", fmt.Errorf("internal error: need to download snaps: %v", strings.Join(which, ", "))</span>
                }

                <span class="cov0" title="0">complete, err := w.Downloaded(retrieveAsserts)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if complete </span><span class="cov0" title="0">{
                        logger.Debugf("snap processing for creating %q complete", label)
                        break</span>
                }
        }

        <span class="cov0" title="0">for _, warn := range w.Warnings() </span><span class="cov0" title="0">{
                logger.Noticef("WARNING creating system %q: %s", label, warn)
        }</span>

        <span class="cov0" title="0">unassertedSnaps, err := w.UnassertedSnaps()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(unassertedSnaps) &gt; 0 </span><span class="cov0" title="0">{
                locals := make([]string, len(unassertedSnaps))
                for i, sn := range unassertedSnaps </span><span class="cov0" title="0">{
                        locals[i] = sn.SnapName()
                }</span>
                <span class="cov0" title="0">logger.Noticef("system %q contains unasserted snaps %s", label, strutil.Quoted(locals))</span>
        }

        <span class="cov0" title="0">copySnap := func(name, src, dst string) error </span><span class="cov0" title="0">{
                // if the destination snap is in the asserted snaps dir and already
                // exists, we don't need to copy it since asserted snaps are shared
                if strings.HasPrefix(dst, assertedSnapsDir+"/") &amp;&amp; osutil.FileExists(dst) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // otherwise, unasserted snaps are not shared, so even if the
                // destination already exists if it is not in the asserted snaps we
                // should copy it
                <span class="cov0" title="0">logger.Noticef("copying new seed snap %q from %v to %v", name, src, dst)
                if observeWrite != nil </span><span class="cov0" title="0">{
                        if err := observeWrite(recoverySystemDir, dst); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return osutil.CopyFile(src, dst, 0)</span>
        }
        <span class="cov0" title="0">if err := w.SeedSnaps(copySnap); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if err := w.WriteMeta(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">bootSnaps, err := w.BootSnaps()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">bootWith := &amp;boot.RecoverySystemBootableSet{}
        for _, sn := range bootSnaps </span><span class="cov0" title="0">{
                switch sn.Info.Type() </span>{
                case snap.TypeKernel:<span class="cov0" title="0">
                        bootWith.Kernel = sn.Info
                        bootWith.KernelPath = sn.Path</span>
                case snap.TypeGadget:<span class="cov0" title="0">
                        bootWith.GadgetSnapOrDir = sn.Path</span>
                }
        }
        <span class="cov0" title="0">if err := boot.MakeRecoverySystemBootable(model, boot.InitramfsUbuntuSeedDir, recoverySystemDirInRootDir, bootWith); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot make candidate recovery system %q bootable: %v", label, err)
        }</span>
        <span class="cov0" title="0">logger.Noticef("created recovery system %q", label)

        return recoverySystemDir, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-
/*
 * Copyright (C) 2022-2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "time"

        "github.com/snapcore/snapd/asserts"
        "github.com/snapcore/snapd/logger"
        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/osutil/user"
        "github.com/snapcore/snapd/overlord/assertstate"
        "github.com/snapcore/snapd/overlord/auth"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/strutil"
)

var (
        osutilAddUser = osutil.AddUser
        osutilDelUser = osutil.DelUser
        userLookup    = user.Lookup
)

// UserError is returned when invalid or insufficient data is supplied,
// or if a user-assertion is not found.
type UserError struct {
        Err error
}

func (e *UserError) Error() string <span class="cov0" title="0">{
        return e.Err.Error()
}</span>

type RemoveUserOptions struct {
        Force bool
}

// CreatedUser holds the results from a create user operation.
type CreatedUser struct {
        Username string
        SSHKeys  []string
}

// CreateUser creates a Linux user based on the specified email.
// The username and public ssh keys for the created account are
// determined from Ubuntu store based on the email.
func CreateUser(st *state.State, sudoer bool, email string, expiration time.Time) (*CreatedUser, error) <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return nil, &amp;UserError{Err: fmt.Errorf("cannot create user: 'email' field is empty")}
        }</span>

        <span class="cov0" title="0">storeService := snapstate.Store(st, nil)
        username, opts, err := getUserDetailsFromStore(st, storeService, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;UserError{Err: fmt.Errorf("cannot create user %q: %s", email, err)}
        }</span>

        <span class="cov0" title="0">opts.Sudoer = sudoer
        return addUser(st, username, email, expiration, opts)</span>
}

// CreateKnownUsers creates known users. The user details are fetched
// from existing system user assertions.
// If no email is passed, all known users will be created based on valid system user assertions.
// If an email is passed, only the corresponding system user assertion is used.
func CreateKnownUsers(st *state.State, sudoer bool, email string) ([]*CreatedUser, error) <span class="cov0" title="0">{
        model, err := findModel(st)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create user: cannot get model assertion: %v", err)
        }</span>

        <span class="cov0" title="0">serial, err := findSerial(st, nil)
        if err != nil &amp;&amp; !errors.Is(err, state.ErrNoState) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create user: cannot get serial: %v", err)
        }</span>

        <span class="cov0" title="0">db := assertstate.DB(st)
        if email == "" </span><span class="cov0" title="0">{
                return createAllKnownSystemUsers(st, db, model, serial, sudoer)
        }</span>

        <span class="cov0" title="0">username, expiration, opts, err := getUserDetailsFromAssertion(db, model, serial, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;UserError{Err: fmt.Errorf("cannot create user %q: %v", email, err)}
        }</span>

        <span class="cov0" title="0">opts.Sudoer = sudoer
        createdUser, err := addUser(st, username, email, expiration, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return []*CreatedUser{createdUser}, nil</span>
}

// RemoveUser removes linux user account of passed username.
func RemoveUser(st *state.State, username string, opts *RemoveUserOptions) (*auth.UserState, error) <span class="cov0" title="0">{
        // TODO: allow to remove user entries by email as well
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;RemoveUserOptions{}
        }</span>

        // catch silly errors
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return nil, &amp;UserError{Err: fmt.Errorf("need a username to remove")}
        }</span>

        // check the user is known to snapd
        <span class="cov0" title="0">_, err := auth.UserByUsername(st, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, auth.ErrInvalidUser) </span><span class="cov0" title="0">{
                        return nil, &amp;UserError{Err: fmt.Errorf("user %q is not known", username)}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // first remove the system user
        <span class="cov0" title="0">delUseropts := &amp;osutil.DelUserOptions{
                ExtraUsers: !release.OnClassic,
                Force:      opts.Force,
        }
        if err := osutilDelUser(username, delUseropts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // then the UserState
        <span class="cov0" title="0">u, err := auth.RemoveUserByUsername(st, username)
        // ErrInvalidUser means "not found" in this case
        if err != nil &amp;&amp; err != auth.ErrInvalidUser </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return u, nil</span>
}

func getUserDetailsFromStore(st *state.State, theStore snapstate.StoreService, email string) (string, *osutil.AddUserOptions, error) <span class="cov0" title="0">{
        st.Unlock()
        defer st.Lock()

        v, err := theStore.UserInfo(email)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov0" title="0">if len(v.SSHKeys) == 0 </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("no ssh keys found")
        }</span>

        // Amend information where the key came from to ensure it can
        // be update/replaced later
        <span class="cov0" title="0">for i, k := range v.SSHKeys </span><span class="cov0" title="0">{
                v.SSHKeys[i] = fmt.Sprintf(`%s # snapd {"origin":"store","email":%q}`, k, email)
        }</span>

        <span class="cov0" title="0">gecos := fmt.Sprintf("%s,%s", email, v.OpenIDIdentifier)
        opts := &amp;osutil.AddUserOptions{
                SSHKeys: v.SSHKeys,
                Gecos:   gecos,
        }
        return v.Username, opts, nil</span>
}

func createKnownSystemUser(state *state.State, userAssertion *asserts.SystemUser, assertDb asserts.RODatabase, model *asserts.Model, serial *asserts.Serial, sudoer bool) (*CreatedUser, error) <span class="cov0" title="0">{
        email := userAssertion.Email()
        // we need to use getUserDetailsFromAssertion as this verifies
        // the assertion against the current brand/model/time
        username, expiration, addUserOpts, err := getUserDetailsFromAssertion(assertDb, model, serial, email)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errSystemUserBoundToSerialButTooEarly) </span><span class="cov0" title="0">{
                        // let callers decide how to proceed
                        return nil, err
                }</span>
                <span class="cov0" title="0">logger.Noticef("ignoring system-user assertion for %q: %s", email, err)
                return nil, nil</span>
        }

        // ignore already existing users
        <span class="cov0" title="0">if _, err := userLookup(username); err == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">addUserOpts.Sudoer = sudoer
        return addUser(state, username, email, expiration, addUserOpts)</span>
}

var createAllKnownSystemUsers = func(state *state.State, assertDb asserts.RODatabase, model *asserts.Model, serial *asserts.Serial, sudoer bool) ([]*CreatedUser, error) <span class="cov0" title="0">{
        headers := map[string]string{
                "brand-id": model.BrandID(),
        }

        assertions, err := assertDb.FindMany(asserts.SystemUserType, headers)
        if err != nil &amp;&amp; !errors.Is(err, &amp;asserts.NotFoundError{}) </span><span class="cov0" title="0">{
                return nil, &amp;UserError{Err: fmt.Errorf("cannot find system-user assertion: %s", err)}
        }</span>

        <span class="cov0" title="0">var createdUsers []*CreatedUser
        for _, as := range assertions </span><span class="cov0" title="0">{
                userAs := as.(*asserts.SystemUser)
                createdUser, err := createKnownSystemUser(state, userAs, assertDb, model, serial, sudoer)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errSystemUserBoundToSerialButTooEarly) </span><span class="cov0" title="0">{
                                state.Set("system-user-waiting-on-serial", true)
                                logger.Noticef("waiting for serial to add user %q: %s", userAs.Email(), err)
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">if createdUser == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">createdUsers = append(createdUsers, createdUser)</span>
        }

        <span class="cov0" title="0">return createdUsers, nil</span>
}

var errSystemUserBoundToSerialButTooEarly = errors.New("bound to serial assertion but device not yet registered")

func getUserDetailsFromAssertion(assertDb asserts.RODatabase, modelAs *asserts.Model, serialAs *asserts.Serial, email string) (string, time.Time, *osutil.AddUserOptions, error) <span class="cov0" title="0">{
        brandID := modelAs.BrandID()
        series := modelAs.Series()
        model := modelAs.Model()

        a, err := assertDb.Find(asserts.SystemUserType, map[string]string{
                "brand-id": brandID,
                "email":    email,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, nil, err
        }</span>
        // the asserts package guarantees that this cast will work
        <span class="cov0" title="0">su := a.(*asserts.SystemUser)

        // check that the signer of the assertion is one of the accepted ones
        sysUserAuths := modelAs.SystemUserAuthority()
        if len(sysUserAuths) &gt; 0 &amp;&amp; !strutil.ListContains(sysUserAuths, su.AuthorityID()) </span><span class="cov0" title="0">{
                return "", time.Time{}, nil, fmt.Errorf("%q not in accepted authorities %q", su.AuthorityID(), sysUserAuths)
        }</span>
        // cross check that the assertion is valid for the given series/model
        <span class="cov0" title="0">if len(su.Series()) &gt; 0 &amp;&amp; !strutil.ListContains(su.Series(), series) </span><span class="cov0" title="0">{
                return "", time.Time{}, nil, fmt.Errorf("%q not in series %q", series, su.Series())
        }</span>
        <span class="cov0" title="0">if len(su.Models()) &gt; 0 &amp;&amp; !strutil.ListContains(su.Models(), model) </span><span class="cov0" title="0">{
                return "", time.Time{}, nil, fmt.Errorf("%q not in models %q", model, su.Models())
        }</span>
        <span class="cov0" title="0">if len(su.Serials()) &gt; 0 </span><span class="cov0" title="0">{
                if serialAs == nil </span><span class="cov0" title="0">{
                        return "", time.Time{}, nil, errSystemUserBoundToSerialButTooEarly
                }</span>
                <span class="cov0" title="0">serial := serialAs.Serial()
                if !strutil.ListContains(su.Serials(), serial) </span><span class="cov0" title="0">{
                        return "", time.Time{}, nil, fmt.Errorf("%q not in serials %q", serial, su.Serials())
                }</span>
        }

        <span class="cov0" title="0">if !su.ValidAt(time.Now()) </span><span class="cov0" title="0">{
                return "", time.Time{}, nil, fmt.Errorf("assertion not valid anymore")
        }</span>

        <span class="cov0" title="0">gecos := fmt.Sprintf("%s,%s", email, su.Name())
        opts := &amp;osutil.AddUserOptions{
                SSHKeys:             su.SSHKeys(),
                Gecos:               gecos,
                Password:            su.Password(),
                ForcePasswordChange: su.ForcePasswordChange(),
        }
        return su.Username(), su.UserExpiration(), opts, nil</span>
}

func setupLocalUser(state *state.State, username, email string, expiration time.Time) error <span class="cov0" title="0">{
        user, err := userLookup(username)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot lookup user %q: %s", username, err)
        }</span>
        <span class="cov0" title="0">uid, gid, err := osutil.UidGid(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">authDataFn := filepath.Join(user.HomeDir, ".snap", "auth.json")
        if err := osutil.MkdirAllChown(filepath.Dir(authDataFn), 0700, uid, gid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // setup new user, local-only
        <span class="cov0" title="0">authUser, err := auth.NewUser(state, auth.NewUserParams{
                Username:   username,
                Email:      email,
                Macaroon:   "",
                Discharges: nil,
                Expiration: expiration,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot persist authentication details: %v", err)
        }</span>
        // store macaroon auth, user's ID, email and username in auth.json in
        // the new users home dir
        <span class="cov0" title="0">outStr, err := json.Marshal(struct {
                ID       int    `json:"id"`
                Username string `json:"username"`
                Email    string `json:"email"`
                Macaroon string `json:"macaroon"`
        }{
                ID:       authUser.ID,
                Username: authUser.Username,
                Email:    authUser.Email,
                Macaroon: authUser.Macaroon,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot marshal auth data: %s", err)
        }</span>
        <span class="cov0" title="0">if err := osutil.AtomicWriteFileChown(authDataFn, []byte(outStr), 0600, 0, uid, gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write auth file %q: %s", authDataFn, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addUser(state *state.State, username string, email string, expiration time.Time, opts *osutil.AddUserOptions) (*CreatedUser, error) <span class="cov0" title="0">{
        opts.ExtraUsers = !release.OnClassic
        if err := osutilAddUser(username, opts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot add user %q: %s", username, err)
        }</span>
        <span class="cov0" title="0">if err := setupLocalUser(state, username, email, expiration); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;CreatedUser{
                Username: username,
                SSHKeys:  opts.SSHKeys,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2025 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package devicestate

import (
        "fmt"

        "github.com/snapcore/snapd/gadget"
        "github.com/snapcore/snapd/overlord/fdestate"
        "github.com/snapcore/snapd/overlord/snapstate"
        "github.com/snapcore/snapd/overlord/state"
)

var (
        fdestateGetKeyslots = fdestate.GetKeyslots
        snapstateGadgetInfo = snapstate.GadgetInfo
)

// VolumeStructureWithKeyslots is gadget.VolumeStructure with
// the corresponding key slots attached.
type VolumeStructureWithKeyslots struct {
        gadget.VolumeStructure

        Keyslots []fdestate.Keyslot
}

// GetVolumeStructuresWithKeyslots returns the current gadget
// volume structures with their corresponding key slots attached.
//
// The state needs to be locked by the caller.
func GetVolumeStructuresWithKeyslots(st *state.State) ([]VolumeStructureWithKeyslots, error) <span class="cov0" title="0">{
        deviceCtx, err := DeviceCtx(st, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get device context: %v", err)
        }</span>
        <span class="cov0" title="0">gadgetSnapInfo, err := snapstateGadgetInfo(st, deviceCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get gadget snap info: %v", err)
        }</span>

        <span class="cov0" title="0">gadgetInfo, err := gadget.ReadInfo(gadgetSnapInfo.MountDir(), deviceCtx.Model())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read gadget: %v", err)
        }</span>

        <span class="cov0" title="0">keyslots, _, err := fdestateGetKeyslots(st, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get key slots: %v", err)
        }</span>
        <span class="cov0" title="0">keyslotsByContainerRole := make(map[string][]fdestate.Keyslot)
        for _, keyslot := range keyslots </span><span class="cov0" title="0">{
                keyslotsByContainerRole[keyslot.ContainerRole] = append(keyslotsByContainerRole[keyslot.ContainerRole], keyslot)
        }</span>

        <span class="cov0" title="0">var structuresWithKeyslots []VolumeStructureWithKeyslots
        for _, gv := range gadgetInfo.Volumes </span><span class="cov0" title="0">{
                for _, gs := range gv.Structure </span><span class="cov0" title="0">{
                        structuresWithKeyslots = append(structuresWithKeyslots, VolumeStructureWithKeyslots{
                                VolumeStructure: gs,
                                Keyslots:        keyslotsByContainerRole[gs.Role],
                        })
                }</span>
        }

        <span class="cov0" title="0">return structuresWithKeyslots, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
