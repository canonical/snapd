
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>asserts: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/snapcore/snapd/asserts/account.go (0.0%)</option>
				
				<option value="file1">github.com/snapcore/snapd/asserts/account_key.go (0.0%)</option>
				
				<option value="file2">github.com/snapcore/snapd/asserts/asserts.go (12.8%)</option>
				
				<option value="file3">github.com/snapcore/snapd/asserts/batch.go (0.0%)</option>
				
				<option value="file4">github.com/snapcore/snapd/asserts/cluster.go (0.0%)</option>
				
				<option value="file5">github.com/snapcore/snapd/asserts/confdb.go (0.0%)</option>
				
				<option value="file6">github.com/snapcore/snapd/asserts/constraint.go (0.0%)</option>
				
				<option value="file7">github.com/snapcore/snapd/asserts/crypto.go (1.2%)</option>
				
				<option value="file8">github.com/snapcore/snapd/asserts/database.go (0.0%)</option>
				
				<option value="file9">github.com/snapcore/snapd/asserts/digest.go (62.5%)</option>
				
				<option value="file10">github.com/snapcore/snapd/asserts/extkeypairmgr.go (0.0%)</option>
				
				<option value="file11">github.com/snapcore/snapd/asserts/fetcher.go (0.0%)</option>
				
				<option value="file12">github.com/snapcore/snapd/asserts/findwildcard.go (0.0%)</option>
				
				<option value="file13">github.com/snapcore/snapd/asserts/fsbackstore.go (0.0%)</option>
				
				<option value="file14">github.com/snapcore/snapd/asserts/fsentryutils.go (0.0%)</option>
				
				<option value="file15">github.com/snapcore/snapd/asserts/fskeypairmgr.go (0.0%)</option>
				
				<option value="file16">github.com/snapcore/snapd/asserts/gpgkeypairmgr.go (0.0%)</option>
				
				<option value="file17">github.com/snapcore/snapd/asserts/hardware_identity.go (98.6%)</option>
				
				<option value="file18">github.com/snapcore/snapd/asserts/header_checks.go (22.6%)</option>
				
				<option value="file19">github.com/snapcore/snapd/asserts/headers.go (13.7%)</option>
				
				<option value="file20">github.com/snapcore/snapd/asserts/ifacedecls.go (0.0%)</option>
				
				<option value="file21">github.com/snapcore/snapd/asserts/membackstore.go (0.0%)</option>
				
				<option value="file22">github.com/snapcore/snapd/asserts/memkeypairmgr.go (0.0%)</option>
				
				<option value="file23">github.com/snapcore/snapd/asserts/messages.go (0.0%)</option>
				
				<option value="file24">github.com/snapcore/snapd/asserts/model.go (0.0%)</option>
				
				<option value="file25">github.com/snapcore/snapd/asserts/pool.go (0.0%)</option>
				
				<option value="file26">github.com/snapcore/snapd/asserts/preseed.go (0.0%)</option>
				
				<option value="file27">github.com/snapcore/snapd/asserts/repair.go (0.0%)</option>
				
				<option value="file28">github.com/snapcore/snapd/asserts/serial_asserts.go (0.0%)</option>
				
				<option value="file29">github.com/snapcore/snapd/asserts/snap_asserts.go (0.0%)</option>
				
				<option value="file30">github.com/snapcore/snapd/asserts/snap_resource_asserts.go (0.0%)</option>
				
				<option value="file31">github.com/snapcore/snapd/asserts/store_asserts.go (0.0%)</option>
				
				<option value="file32">github.com/snapcore/snapd/asserts/system_user.go (0.0%)</option>
				
				<option value="file33">github.com/snapcore/snapd/asserts/validation_set.go (3.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "regexp"
        "time"
)

var (
        // account ids look like snap-ids or a nice identifier
        validAccountID = regexp.MustCompile("^(?:[a-z0-9A-Z]{32}|[-a-z0-9]{2,28})$")
)

// Account holds an account assertion, which ties a name for an account
// to its identifier and provides the authority's confidence in the name's validity.
type Account struct {
        assertionBase
        validation string
        timestamp  time.Time
}

func IsValidAccountID(accountID string) bool <span class="cov0" title="0">{
        return validAccountID.MatchString(accountID)
}</span>

// AccountID returns the account-id of the account.
func (acc *Account) AccountID() string <span class="cov0" title="0">{
        return acc.HeaderString("account-id")
}</span>

// Username returns the user name for the account.
func (acc *Account) Username() string <span class="cov0" title="0">{
        return acc.HeaderString("username")
}</span>

// DisplayName returns the human-friendly name for the account.
func (acc *Account) DisplayName() string <span class="cov0" title="0">{
        return acc.HeaderString("display-name")
}</span>

// Validation returns the level of confidence of the authority in the
// account's identity, expected to be "unproven", "starred" or "verified".
func (acc *Account) Validation() string <span class="cov0" title="0">{
        return acc.validation
}</span>

// Timestamp returns the time when the account was issued.
func (acc *Account) Timestamp() time.Time <span class="cov0" title="0">{
        return acc.timestamp
}</span>

// Implement further consistency checks.
func (acc *Account) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        if !db.IsTrustedAccount(acc.AuthorityID()) </span><span class="cov0" title="0">{
                return fmt.Errorf("account assertion for %q is not signed by a directly trusted authority: %s", acc.AccountID(), acc.AuthorityID())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*Account)(nil)

func assembleAccount(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkNotEmptyString(assert.headers, "display-name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">validation, err := checkNotEmptyString(assert.headers, "validation")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // backward compatibility with the hard-coded trusted account
        // assertions
        // TODO: generate revision 1 of them with validation
        // s/certified/verified/
        <span class="cov0" title="0">if validation == "certified" </span><span class="cov0" title="0">{
                validation = "verified"
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkOptionalString(assert.headers, "username")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Account{
                assertionBase: assert,
                validation:    validation,
                timestamp:     timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "regexp"
        "time"
)

var validAccountKeyName = regexp.MustCompile(`^(?:[a-z0-9]+-?)*[a-z](?:-?[a-z0-9])*$`)

// AccountKey holds an account-key assertion, asserting a public key
// belonging to the account.
type AccountKey struct {
        assertionBase
        sinceUntil
        constraintMatchers []attrMatcher
        pubKey             PublicKey
}

type sinceUntil struct {
        since time.Time
        until time.Time
}

func checkSinceUntilWhat(m map[string]any, what string) (*sinceUntil, error) <span class="cov0" title="0">{
        since, err := checkRFC3339DateWhat(m, "since", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">until, err := checkRFC3339DateWithDefaultWhat(m, "until", what, time.Time{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !until.IsZero() &amp;&amp; until.Before(since) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'until' time cannot be before 'since' time")
        }</span>

        <span class="cov0" title="0">return &amp;sinceUntil{
                since: since,
                until: until,
        }, nil</span>
}

// AccountID returns the account-id of this account-key.
func (ak *AccountKey) AccountID() string <span class="cov0" title="0">{
        return ak.HeaderString("account-id")
}</span>

// Name returns the name of the account key.
func (ak *AccountKey) Name() string <span class="cov0" title="0">{
        return ak.HeaderString("name")
}</span>

func IsValidAccountKeyName(name string) bool <span class="cov0" title="0">{
        return validAccountKeyName.MatchString(name)
}</span>

// Since returns the time when the account key starts being valid.
func (ak *AccountKey) Since() time.Time <span class="cov0" title="0">{
        return ak.since
}</span>

// Until returns the time when the account key stops being valid. A zero time means the key is valid forever.
func (ak *AccountKey) Until() time.Time <span class="cov0" title="0">{
        return ak.until
}</span>

// PublicKeyID returns the key id used for lookup of the account key.
func (ak *AccountKey) PublicKeyID() string <span class="cov0" title="0">{
        return ak.pubKey.ID()
}</span>

// isValidAt returns whether the since-until constraint is valid at 'when' time.
func (su *sinceUntil) isValidAt(when time.Time) bool <span class="cov0" title="0">{
        valid := when.After(su.since) || when.Equal(su.since)
        if valid &amp;&amp; !su.until.IsZero() </span><span class="cov0" title="0">{
                valid = when.Before(su.until)
        }</span>
        <span class="cov0" title="0">return valid</span>
}

// isValidAssumingCurTimeWithin returns whether the since-until constraint  is
// possibly valid if the current time is known to be within [earliest,
// latest]. That means the intersection of possible current times and
// validity is not empty.
// If latest is zero, then current time is assumed to be &gt;=earliest.
// If earliest == latest this is equivalent to isKeyValidAt().
func (su *sinceUntil) isValidAssumingCurTimeWithin(earliest, latest time.Time) bool <span class="cov0" title="0">{
        if !latest.IsZero() </span><span class="cov0" title="0">{
                // impossible input =&gt; false
                if latest.Before(earliest) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if latest.Before(su.since) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">if !su.until.IsZero() </span><span class="cov0" title="0">{
                if earliest.After(su.until) || earliest.Equal(su.until) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// publicKey returns the underlying public key of the account key.
func (ak *AccountKey) publicKey() PublicKey <span class="cov0" title="0">{
        return ak.pubKey
}</span>

// ConstraintsPrecheck checks whether the given type and headers match the signing constraints of the account key.
func (ak *AccountKey) ConstraintsPrecheck(assertType *AssertionType, headers map[string]any) error <span class="cov0" title="0">{
        headersWithType := copyHeaders(headers)
        headersWithType["type"] = assertType.Name
        if !ak.matchAgainstConstraints(headersWithType) </span><span class="cov0" title="0">{
                return fmt.Errorf("headers do not match the account-key constraints")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ak *AccountKey) matchAgainstConstraints(headers map[string]any) bool <span class="cov0" title="0">{
        matchers := ak.constraintMatchers
        // no constraints, everything is allowed
        if len(matchers) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, m := range matchers </span><span class="cov0" title="0">{
                if m.match("", headers, &amp;attrMatchingContext{
                        attrWord: "header",
                }) == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// canSign checks whether the given assertion matches the signing constraints of the account key.
func (ak *AccountKey) canSign(a Assertion) bool <span class="cov0" title="0">{
        return ak.matchAgainstConstraints(a.Headers())
}</span>

func checkPublicKey(ab *assertionBase, keyIDName string) (PublicKey, error) <span class="cov0" title="0">{
        pubKey, err := DecodePublicKey(ab.Body())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keyID, err := checkNotEmptyString(ab.headers, keyIDName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyID != pubKey.ID() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public key does not match provided key id")
        }</span>
        <span class="cov0" title="0">return pubKey, nil</span>
}

// Implement further consistency checks.
func (ak *AccountKey) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        if !db.IsTrustedAccount(ak.AuthorityID()) </span><span class="cov0" title="0">{
                return fmt.Errorf("account-key assertion for %q is not signed by a directly trusted authority: %s", ak.AccountID(), ak.AuthorityID())
        }</span>
        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{
                "account-id": ak.AccountID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("account-key assertion for %q does not have a matching account assertion", ak.AccountID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // XXX: Make this unconditional once account-key assertions are required to have a name.
        <span class="cov0" title="0">if ak.Name() != "" </span><span class="cov0" title="0">{
                // Check that we don't end up with multiple keys with
                // different IDs but the same account-id and name.
                // Note that this is a non-transactional check-then-add, so
                // is not a hard guarantee.  Backstores that can implement a
                // unique constraint should do so.
                assertions, err := db.FindMany(AccountKeyType, map[string]string{
                        "account-id": ak.AccountID(),
                        "name":       ak.Name(),
                })
                if err != nil &amp;&amp; !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, assertion := range assertions </span><span class="cov0" title="0">{
                        existingAccKey := assertion.(*AccountKey)
                        if ak.PublicKeyID() != existingAccKey.PublicKeyID() </span><span class="cov0" title="0">{
                                return fmt.Errorf("account-key assertion for %q with ID %q has the same name %q as existing ID %q", ak.AccountID(), ak.PublicKeyID(), ak.Name(), existingAccKey.PublicKeyID())
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*AccountKey)(nil)

// Prerequisites returns references to this account-key's prerequisite assertions.
func (ak *AccountKey) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: AccountType, PrimaryKey: []string{ak.AccountID()}},
        }
}</span>

func assembleAccountKey(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkNotEmptyString(assert.headers, "account-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // XXX: We should require name to be present after backfilling existing assertions.
        <span class="cov0" title="0">_, ok := assert.headers["name"]
        if ok </span><span class="cov0" title="0">{
                _, err = checkStringMatches(assert.headers, "name", validAccountKeyName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">sinceUntil, err := checkSinceUntilWhat(assert.headers, "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubk, err := checkPublicKey(&amp;assert, "public-key-sha3-384")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var matchers []attrMatcher
        if cs, ok := assert.headers["constraints"]; ok </span><span class="cov0" title="0">{
                matchers, err = checkAKConstraints(cs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // ignore extra headers for future compatibility
        <span class="cov0" title="0">return &amp;AccountKey{
                assertionBase:      assert,
                sinceUntil:         *sinceUntil,
                constraintMatchers: matchers,
                pubKey:             pubk,
        }, nil</span>
}

func checkAKConstraints(cs any) ([]attrMatcher, error) <span class="cov0" title="0">{
        csmaps, ok := cs.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertions constraints must be a list of maps")
        }</span>
        <span class="cov0" title="0">if len(csmaps) == 0 </span><span class="cov0" title="0">{
                // there is no syntax producing this scenario but be robust
                return nil, fmt.Errorf("assertions constraints cannot be empty")
        }</span>
        <span class="cov0" title="0">matchers := make([]attrMatcher, 0, len(csmaps))
        for _, csmap := range csmaps </span><span class="cov0" title="0">{
                m, ok := csmap.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("assertions constraints must be a list of maps")
                }</span>
                <span class="cov0" title="0">hm, err := checkMapWhat(m, "headers", "constraint")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if hm == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"headers" constraint mandatory in asserions constraints`)
                }</span>
                <span class="cov0" title="0">t, ok := hm["type"]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("type header constraint mandatory in asserions constraints")
                }</span>
                <span class="cov0" title="0">tstr, ok := t.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("type header constraint must be a string")
                }</span>
                <span class="cov0" title="0">if tstr != regexp.QuoteMeta(tstr) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("type header constraint must be a precise string and not a regexp")
                }</span>
                <span class="cov0" title="0">cc := compileContext{
                        opts: &amp;compileAttrMatcherOptions{},
                }
                matcher, err := compileAttrMatcher(cc, hm)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot compile headers constraint: %v", err)
                }</span>
                <span class="cov0" title="0">matchers = append(matchers, matcher)</span>
        }
        <span class="cov0" title="0">return matchers, nil</span>
}

func accountKeyFormatAnalyze(headers map[string]any, body []byte) (formatnum int, err error) <span class="cov0" title="0">{
        formatnum = 0
        if _, ok := headers["constraints"]; ok </span><span class="cov0" title="0">{
                formatnum = 1
        }</span>
        <span class="cov0" title="0">return formatnum, nil</span>
}

// AccountKeyRequest holds an account-key-request assertion, which is a self-signed request to prove that the requester holds the private key and wishes to create an account-key assertion for it.
type AccountKeyRequest struct {
        assertionBase
        sinceUntil
        pubKey PublicKey
}

// AccountID returns the account-id of this account-key-request.
func (akr *AccountKeyRequest) AccountID() string <span class="cov0" title="0">{
        return akr.HeaderString("account-id")
}</span>

// Name returns the name of the account key.
func (akr *AccountKeyRequest) Name() string <span class="cov0" title="0">{
        return akr.HeaderString("name")
}</span>

// Since returns the time when the requested account key starts being valid.
func (akr *AccountKeyRequest) Since() time.Time <span class="cov0" title="0">{
        return akr.since
}</span>

// Until returns the time when the requested account key stops being valid. A zero time means the key is valid forever.
func (akr *AccountKeyRequest) Until() time.Time <span class="cov0" title="0">{
        return akr.until
}</span>

// PublicKeyID returns the underlying public key ID of the requested account key.
func (akr *AccountKeyRequest) PublicKeyID() string <span class="cov0" title="0">{
        return akr.pubKey.ID()
}</span>

// signKey returns the underlying public key of the requested account key.
func (akr *AccountKeyRequest) signKey(db RODatabase) (PublicKey, error) <span class="cov0" title="0">{
        return akr.pubKey, nil
}</span>

// Implement further consistency checks.
func (akr *AccountKeyRequest) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        _, err := db.Find(AccountType, map[string]string{
                "account-id": akr.AccountID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("account-key-request assertion for %q does not have a matching account assertion", akr.AccountID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// expected interfaces are implemented
var (
        _ consistencyChecker = (*AccountKeyRequest)(nil)
        _ customSigner       = (*AccountKeyRequest)(nil)
)

// Prerequisites returns references to this account-key-request's prerequisite assertions.
func (akr *AccountKeyRequest) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: AccountType, PrimaryKey: []string{akr.AccountID()}},
        }
}</span>

func assembleAccountKeyRequest(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkNotEmptyString(assert.headers, "account-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkStringMatches(assert.headers, "name", validAccountKeyName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sinceUntil, err := checkSinceUntilWhat(assert.headers, "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pubk, err := checkPublicKey(&amp;assert, "public-key-sha3-384")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // XXX TODO: support constraints also in account-key-request when
        // implementing more fully automated registration flows

        // ignore extra headers for future compatibility
        <span class="cov0" title="0">return &amp;AccountKeyRequest{
                assertionBase: assert,
                sinceUntil:    *sinceUntil,
                pubKey:        pubk,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bufio"
        "bytes"
        "crypto"
        "encoding/json"
        "fmt"
        "io"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "unicode/utf8"

        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/snap/naming"
)

type typeFlags int

const (
        noAuthority typeFlags = 1 &lt;&lt; iota
        sequenceForming
        jsonBody
)

// MetaHeaders is a list of headers in assertions which are about the assertion
// itself.
var MetaHeaders = [...]string{
        "type",
        "format",
        "authority-id",
        "revision",
        "body-length",
        "sign-key-sha3-384",
}

// AssertionType describes a known assertion type with its name and metadata.
type AssertionType struct {
        // Name of the type.
        Name string
        // PrimaryKey holds the names of the headers that constitute the
        // unique primary key for this assertion type.
        PrimaryKey []string
        // OptionalPrimaryKeyDefaults holds the default values for
        // optional primary key headers.
        // Optional primary key headers can be added to types defined
        // in previous versions of snapd, as long as they are added at
        // the end of the old primary key together with a default value set in
        // this map. So they must form a contiguous suffix of PrimaryKey with
        // each member having a default value set in this map.
        // Optional primary key headers are not supported for sequence
        // forming types.
        OptionalPrimaryKeyDefaults map[string]string

        assembler func(assert assertionBase) (Assertion, error)
        flags     typeFlags
}

func (at *AssertionType) validate() <span class="cov8" title="1">{
        if len(at.OptionalPrimaryKeyDefaults) != 0 &amp;&amp; at.flags&amp;sequenceForming != 0 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assertion type %q cannot be both sequence forming and have optional primary keys", at.Name))</span>
        }
        <span class="cov8" title="1">noptional := 0
        for _, k := range at.PrimaryKey </span><span class="cov8" title="1">{
                defl := at.OptionalPrimaryKeyDefaults[k]
                if noptional &gt; 0 </span><span class="cov0" title="0">{
                        if defl == "" </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("assertion type %q primary key header %q has no default, optional primary keys must be a proper suffix of the primary key", at.Name, k))</span>
                        }
                }
                <span class="cov8" title="1">if defl != "" </span><span class="cov8" title="1">{
                        noptional++
                }</span>
        }
        <span class="cov8" title="1">if len(at.OptionalPrimaryKeyDefaults) != noptional </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("assertion type %q has defaults values for unknown primary key headers", at.Name))</span>
        }
}

// MaxSupportedFormat returns the maximum supported format iteration for the type.
func (at *AssertionType) MaxSupportedFormat() int <span class="cov0" title="0">{
        return maxSupportedFormat[at.Name]
}</span>

// SequenceForming returns true if the assertion type has a positive
// integer &gt;= 1 as the last component (preferably called "sequence")
// of its primary key over which the assertions of the type form
// sequences, usually without gaps, one sequence per sequence key (the
// primary key prefix omitting the sequence number).
// See SequenceMember.
func (at *AssertionType) SequenceForming() bool <span class="cov0" title="0">{
        return at.flags&amp;sequenceForming != 0
}</span>

// AcceptablePrimaryKey returns whether the given key could be an acceptable primary key for this type, allowing for the omission of optional primary key headers.
func (at *AssertionType) AcceptablePrimaryKey(key []string) bool <span class="cov0" title="0">{
        n := len(at.PrimaryKey)
        nopt := len(at.OptionalPrimaryKeyDefaults)
        ninp := len(key)
        if ninp &gt; n || ninp &lt; (n-nopt) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// JSONBody returns true if the body for this assertion type must be JSON.
func (at *AssertionType) JSONBody() bool <span class="cov0" title="0">{
        return at.flags&amp;jsonBody != 0
}</span>

// Understood assertion types.
var (
        AccountType              = &amp;AssertionType{"account", []string{"account-id"}, nil, assembleAccount, 0}
        AccountKeyType           = &amp;AssertionType{"account-key", []string{"public-key-sha3-384"}, nil, assembleAccountKey, 0}
        RepairType               = &amp;AssertionType{"repair", []string{"brand-id", "repair-id"}, nil, assembleRepair, sequenceForming}
        ModelType                = &amp;AssertionType{"model", []string{"series", "brand-id", "model"}, nil, assembleModel, 0}
        SerialType               = &amp;AssertionType{"serial", []string{"brand-id", "model", "serial"}, nil, assembleSerial, 0}
        BaseDeclarationType      = &amp;AssertionType{"base-declaration", []string{"series"}, nil, assembleBaseDeclaration, 0}
        SnapDeclarationType      = &amp;AssertionType{"snap-declaration", []string{"series", "snap-id"}, nil, assembleSnapDeclaration, 0}
        SnapBuildType            = &amp;AssertionType{"snap-build", []string{"snap-sha3-384"}, nil, assembleSnapBuild, 0}
        SnapRevisionType         = &amp;AssertionType{"snap-revision", []string{"snap-sha3-384", "provenance"}, map[string]string{"provenance": naming.DefaultProvenance}, assembleSnapRevision, 0}
        SnapDeveloperType        = &amp;AssertionType{"snap-developer", []string{"snap-id", "publisher-id"}, nil, assembleSnapDeveloper, 0}
        SystemUserType           = &amp;AssertionType{"system-user", []string{"brand-id", "email"}, nil, assembleSystemUser, 0}
        ValidationType           = &amp;AssertionType{"validation", []string{"series", "snap-id", "approved-snap-id", "approved-snap-revision"}, nil, assembleValidation, 0}
        ValidationSetType        = &amp;AssertionType{"validation-set", []string{"series", "account-id", "name", "sequence"}, nil, assembleValidationSet, sequenceForming}
        StoreType                = &amp;AssertionType{"store", []string{"store"}, nil, assembleStore, 0}
        PreseedType              = &amp;AssertionType{"preseed", []string{"series", "brand-id", "model", "system-label"}, nil, assemblePreseed, 0}
        SnapResourceRevisionType = &amp;AssertionType{"snap-resource-revision", []string{"snap-id", "resource-name", "resource-sha3-384", "provenance"}, map[string]string{"provenance": naming.DefaultProvenance}, assembleSnapResourceRevision, 0}
        SnapResourcePairType     = &amp;AssertionType{"snap-resource-pair", []string{"snap-id", "resource-name", "resource-revision", "snap-revision", "provenance"}, map[string]string{"provenance": naming.DefaultProvenance}, assembleSnapResourcePair, 0}
        ConfdbSchemaType         = &amp;AssertionType{"confdb-schema", []string{"account-id", "name"}, nil, assembleConfdbSchema, jsonBody}
        ClusterType              = &amp;AssertionType{"cluster", []string{"cluster-id", "sequence"}, nil, assembleCluster, sequenceForming}
        RequestMessageType       = &amp;AssertionType{"request-message", []string{"account-id", "message-id"}, nil, assembleRequestMessage, 0}
        HardwareIdentityType     = &amp;AssertionType{"hardware-identity", []string{"issuer-id", "hardware-id-key-sha3-384"}, nil, assembleHardwareIdentity, 0}
        // ...
)

// Assertion types without a definite authority set (on the wire and/or self-signed).
var (
        DeviceSessionRequestType = &amp;AssertionType{"device-session-request", []string{"brand-id", "model", "serial"}, nil, assembleDeviceSessionRequest, noAuthority}
        SerialRequestType        = &amp;AssertionType{"serial-request", nil, nil, assembleSerialRequest, noAuthority}
        AccountKeyRequestType    = &amp;AssertionType{"account-key-request", []string{"public-key-sha3-384"}, nil, assembleAccountKeyRequest, noAuthority}
        ConfdbControlType        = &amp;AssertionType{"confdb-control", []string{"brand-id", "model", "serial"}, nil, assembleConfdbControl, noAuthority}
        ResponseMessageType      = &amp;AssertionType{"response-message", []string{"account-id", "message-id", "device"}, nil, assembleResponseMessage, noAuthority}
)

var typeRegistry = map[string]*AssertionType{
        AccountType.Name:              AccountType,
        AccountKeyType.Name:           AccountKeyType,
        ModelType.Name:                ModelType,
        SerialType.Name:               SerialType,
        BaseDeclarationType.Name:      BaseDeclarationType,
        SnapDeclarationType.Name:      SnapDeclarationType,
        SnapBuildType.Name:            SnapBuildType,
        SnapRevisionType.Name:         SnapRevisionType,
        SnapDeveloperType.Name:        SnapDeveloperType,
        SystemUserType.Name:           SystemUserType,
        ValidationType.Name:           ValidationType,
        ValidationSetType.Name:        ValidationSetType,
        RepairType.Name:               RepairType,
        StoreType.Name:                StoreType,
        PreseedType.Name:              PreseedType,
        SnapResourceRevisionType.Name: SnapResourceRevisionType,
        SnapResourcePairType.Name:     SnapResourcePairType,
        ConfdbSchemaType.Name:         ConfdbSchemaType,
        ClusterType.Name:              ClusterType,
        RequestMessageType.Name:       RequestMessageType,
        HardwareIdentityType.Name:     HardwareIdentityType,
        // no authority
        DeviceSessionRequestType.Name: DeviceSessionRequestType,
        SerialRequestType.Name:        SerialRequestType,
        AccountKeyRequestType.Name:    AccountKeyRequestType,
        ConfdbControlType.Name:        ConfdbControlType,
        ResponseMessageType.Name:      ResponseMessageType,
}

// Type returns the AssertionType with name or nil
func Type(name string) *AssertionType <span class="cov8" title="1">{
        return typeRegistry[name]
}</span>

// TypeNames returns a sorted list of known assertion type names.
func TypeNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(typeRegistry))
        for k := range typeRegistry </span><span class="cov0" title="0">{
                names = append(names, k)
        }</span>

        <span class="cov0" title="0">sort.Strings(names)

        return names</span>
}

var maxSupportedFormat = map[string]int{}

func init() <span class="cov8" title="1">{
        // register maxSupportedFormats while breaking initialisation loop

        // 1: plugs and slots
        // 2: support for $SLOT()/$PLUG()/$MISSING
        // 3: support for on-store/on-brand/on-model device scope constraints
        // 4: support for plug-names/slot-names constraints
        // 5: alt attr matcher usage (was unused before, has new behavior now)
        // 6: support for $PLUG_PUBLISHER_ID/$SLOT_PUBLISHER_ID in attr constraints
        maxSupportedFormat[SnapDeclarationType.Name] = 6

        // 1: support to limit to device serials
        // 2: support for user-presence constraint
        maxSupportedFormat[SystemUserType.Name] = 2

        // 1: support for constraints
        maxSupportedFormat[AccountKeyType.Name] = 1

        for _, at := range typeRegistry </span><span class="cov8" title="1">{
                at.validate()
        }</span>
}

func MockMaxSupportedFormat(assertType *AssertionType, maxFormat int) (restore func()) <span class="cov0" title="0">{
        prev := maxSupportedFormat[assertType.Name]
        maxSupportedFormat[assertType.Name] = maxFormat
        return func() </span><span class="cov0" title="0">{
                maxSupportedFormat[assertType.Name] = prev
        }</span>
}

func MockOptionalPrimaryKey(assertType *AssertionType, key, defaultValue string) (restore func()) <span class="cov0" title="0">{
        osutil.MustBeTestBinary("mocking new assertion optional primary keys can be done only from tests")
        oldPrimaryKey := assertType.PrimaryKey
        oldOptionalPrimaryKeyDefaults := assertType.OptionalPrimaryKeyDefaults
        newOptionalPrimaryKeyDefaults := make(map[string]string, len(oldOptionalPrimaryKeyDefaults)+1)
        for k, defl := range oldOptionalPrimaryKeyDefaults </span><span class="cov0" title="0">{
                newOptionalPrimaryKeyDefaults[k] = defl
        }</span>
        <span class="cov0" title="0">assertType.PrimaryKey = append(assertType.PrimaryKey, key)
        assertType.OptionalPrimaryKeyDefaults = newOptionalPrimaryKeyDefaults
        newOptionalPrimaryKeyDefaults[key] = defaultValue
        return func() </span><span class="cov0" title="0">{
                assertType.PrimaryKey = oldPrimaryKey
                assertType.OptionalPrimaryKeyDefaults = oldOptionalPrimaryKeyDefaults
        }</span>
}

var formatAnalyzer = map[*AssertionType]func(headers map[string]any, body []byte) (formatnum int, err error){
        AccountKeyType:      accountKeyFormatAnalyze,
        SnapDeclarationType: snapDeclarationFormatAnalyze,
        SystemUserType:      systemUserFormatAnalyze,
}

// MaxSupportedFormats returns a mapping between assertion type names
// and corresponding max supported format if it is &gt;= min. Typical
// usage passes 1 or 0 for min.
func MaxSupportedFormats(min int) (maxFormats map[string]int) <span class="cov0" title="0">{
        if min == 0 </span><span class="cov0" title="0">{
                maxFormats = make(map[string]int, len(typeRegistry))
        }</span> else<span class="cov0" title="0"> {
                maxFormats = make(map[string]int)
        }</span>
        <span class="cov0" title="0">for name := range typeRegistry </span><span class="cov0" title="0">{
                m := maxSupportedFormat[name]
                if m &gt;= min </span><span class="cov0" title="0">{
                        maxFormats[name] = m
                }</span>
        }
        <span class="cov0" title="0">return maxFormats</span>
}

// SuggestFormat returns a minimum format that supports the features that would be used by an assertion with the given components.
func SuggestFormat(assertType *AssertionType, headers map[string]any, body []byte) (formatnum int, err error) <span class="cov0" title="0">{
        analyzer := formatAnalyzer[assertType]
        if analyzer == nil </span><span class="cov0" title="0">{
                // no analyzer, format 0 is all there is
                return 0, nil
        }</span>
        <span class="cov0" title="0">formatnum, err = analyzer(headers, body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("assertion %s: %v", assertType.Name, err)
        }</span>
        <span class="cov0" title="0">return formatnum, nil</span>
}

// HeadersFromPrimaryKey constructs a headers mapping from the
// primaryKey values and the assertion type, it errors if primaryKey
// does not cover all the non-optional primary key headers or provides
// too many values.
func HeadersFromPrimaryKey(assertType *AssertionType, primaryKey []string) (headers map[string]string, err error) <span class="cov0" title="0">{
        if !assertType.AcceptablePrimaryKey(primaryKey) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("primary key has wrong length for %q assertion", assertType.Name)
        }</span>
        <span class="cov0" title="0">ninp := len(primaryKey)
        headers = make(map[string]string, len(assertType.PrimaryKey))
        for i, name := range assertType.PrimaryKey </span><span class="cov0" title="0">{
                var keyVal string
                if i &lt; ninp </span><span class="cov0" title="0">{
                        keyVal = primaryKey[i]
                        if keyVal == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("primary key %q header cannot be empty", name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        keyVal = assertType.OptionalPrimaryKeyDefaults[name]
                }</span>
                <span class="cov0" title="0">headers[name] = keyVal</span>
        }
        <span class="cov0" title="0">return headers, nil</span>
}

// HeadersFromSequenceKey constructs a headers mapping from the
// sequenceKey values and the sequence forming assertion type,
// it errors if sequenceKey has the wrong length; the length must be
// one less than the primary key of the given assertion type.
func HeadersFromSequenceKey(assertType *AssertionType, sequenceKey []string) (headers map[string]string, err error) <span class="cov0" title="0">{
        if !assertType.SequenceForming() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: HeadersFromSequenceKey should only be used for sequence forming assertion types, got: %s", assertType.Name)
        }</span>
        <span class="cov0" title="0">if len(sequenceKey) != len(assertType.PrimaryKey)-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sequence key has wrong length for %q assertion", assertType.Name)
        }</span>
        <span class="cov0" title="0">headers = make(map[string]string, len(sequenceKey))
        for i, val := range sequenceKey </span><span class="cov0" title="0">{
                key := assertType.PrimaryKey[i]
                if val == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sequence key %q header cannot be empty", key)
                }</span>
                <span class="cov0" title="0">headers[key] = val</span>
        }
        <span class="cov0" title="0">return headers, nil</span>
}

// PrimaryKeyFromHeaders extracts the tuple of values from headers
// corresponding to a primary key under the assertion type, it errors
// if there are missing primary key headers unless they are optional
// in which case it fills in their default values.
func PrimaryKeyFromHeaders(assertType *AssertionType, headers map[string]string) (primaryKey []string, err error) <span class="cov0" title="0">{
        return keysFromHeaders(assertType.PrimaryKey, headers, assertType.OptionalPrimaryKeyDefaults)
}</span>

func keysFromHeaders(keys []string, headers map[string]string, defaults map[string]string) (keyValues []string, err error) <span class="cov0" title="0">{
        keyValues = make([]string, len(keys))
        for i, k := range keys </span><span class="cov0" title="0">{
                keyVal := headers[k]
                if keyVal == "" </span><span class="cov0" title="0">{
                        keyVal = defaults[k]
                        if keyVal == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("must provide primary key: %v", k)
                        }</span>
                }
                <span class="cov0" title="0">keyValues[i] = keyVal</span>
        }
        <span class="cov0" title="0">return keyValues, nil</span>
}

// ReducePrimaryKey produces a primary key prefix by omitting any
// suffix of optional primary key headers default values.
// Too short or long primary keys are returned as is.
func ReducePrimaryKey(assertType *AssertionType, primaryKey []string) []string <span class="cov0" title="0">{
        n := len(assertType.PrimaryKey)
        nopt := len(assertType.OptionalPrimaryKeyDefaults)
        ninp := len(primaryKey)
        if ninp &gt; n || ninp &lt; (n-nopt) </span><span class="cov0" title="0">{
                return primaryKey
        }</span>
        <span class="cov0" title="0">reduced := make([]string, n-nopt, n)
        copy(reduced, primaryKey[:n-nopt])
        rest := ninp - (n - nopt)
        for i := ninp - 1; i &gt;= n-nopt; i-- </span><span class="cov0" title="0">{
                defl := assertType.OptionalPrimaryKeyDefaults[assertType.PrimaryKey[i]]
                if primaryKey[i] != defl </span><span class="cov0" title="0">{
                        break</span>
                }
                // it matches the default value, leave it out
                <span class="cov0" title="0">rest--</span>
        }
        <span class="cov0" title="0">reduced = append(reduced, primaryKey[n-nopt:n-nopt+rest]...)
        return reduced</span>
}

// Ref expresses a reference to an assertion.
type Ref struct {
        Type       *AssertionType
        PrimaryKey []string
}

func (ref *Ref) String() string <span class="cov0" title="0">{
        pkStr := "-"
        n := len(ref.Type.PrimaryKey)
        nopt := len(ref.Type.OptionalPrimaryKeyDefaults)
        ninp := len(ref.PrimaryKey)
        if ninp &gt; n || ninp &lt; (n-nopt) </span><span class="cov0" title="0">{
                pkStr = "???"
        }</span> else<span class="cov0" title="0"> if n &gt; 0 </span><span class="cov0" title="0">{
                pkStr = ref.PrimaryKey[n-nopt-1]
                if n &gt; 1 </span><span class="cov0" title="0">{
                        sfx := []string{pkStr + ";"}
                        for i, k := range ref.Type.PrimaryKey[:n-nopt-1] </span><span class="cov0" title="0">{
                                sfx = append(sfx, fmt.Sprintf("%s:%s", k, ref.PrimaryKey[i]))
                        }</span>
                        // optional primary keys
                        <span class="cov0" title="0">for i := n - nopt; i &lt; ninp; i++ </span><span class="cov0" title="0">{
                                v := ref.PrimaryKey[i]
                                k := ref.Type.PrimaryKey[i]
                                defl := ref.Type.OptionalPrimaryKeyDefaults[k]
                                if v != defl </span><span class="cov0" title="0">{
                                        sfx = append(sfx, fmt.Sprintf("%s:%s", k, v))
                                }</span>
                        }
                        <span class="cov0" title="0">pkStr = strings.Join(sfx, " ")</span>
                }
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s (%s)", ref.Type.Name, pkStr)</span>
}

// Unique returns a unique string representing the reference that can be used as a key in maps.
func (ref *Ref) Unique() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", ref.Type.Name, strings.Join(ReducePrimaryKey(ref.Type, ref.PrimaryKey), "/"))
}</span>

// Resolve resolves the reference using the given find function.
func (ref *Ref) Resolve(find func(assertType *AssertionType, headers map[string]string) (Assertion, error)) (Assertion, error) <span class="cov0" title="0">{
        headers, err := HeadersFromPrimaryKey(ref.Type, ref.PrimaryKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q assertion reference primary key has the wrong length (expected %v): %v", ref.Type.Name, ref.Type.PrimaryKey, ref.PrimaryKey)
        }</span>
        <span class="cov0" title="0">return find(ref.Type, headers)</span>
}

const RevisionNotKnown = -1

// AtRevision represents an assertion at a given revision, possibly
// not known (RevisionNotKnown).
type AtRevision struct {
        Ref
        Revision int
}

func (at *AtRevision) String() string <span class="cov0" title="0">{
        s := at.Ref.String()
        if at.Revision == RevisionNotKnown </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s at revision %d", s, at.Revision)</span>
}

// AtSequence references a sequence forming assertion at a given sequence point,
// possibly &lt;=0 (meaning not specified) and revision, possibly not known
// (RevisionNotKnown).
// Setting Pinned = true means pinning at the given sequence point (which must be
// set, i.e. &gt; 0). Pinned sequence forming assertion will be updated to the
// latest revision at the specified sequence point.
type AtSequence struct {
        Type        *AssertionType
        SequenceKey []string
        Sequence    int
        Pinned      bool
        Revision    int
}

// Unique returns a unique string representing the sequence by its sequence key
// that can be used as a key in maps.
func (at *AtSequence) Unique() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", at.Type.Name, strings.Join(at.SequenceKey, "/"))
}</span>

func (at *AtSequence) String() string <span class="cov0" title="0">{
        var pkStr string
        if len(at.SequenceKey) != len(at.Type.PrimaryKey)-1 </span><span class="cov0" title="0">{
                pkStr = "???"
        }</span> else<span class="cov0" title="0"> {
                n := 0
                // omit series if present in the primary key
                if at.Type.PrimaryKey[0] == "series" </span><span class="cov0" title="0">{
                        n++
                }</span>
                <span class="cov0" title="0">pkStr = strings.Join(at.SequenceKey[n:], "/")
                if at.Sequence &gt; 0 </span><span class="cov0" title="0">{
                        sep := "/"
                        if at.Pinned </span><span class="cov0" title="0">{
                                sep = "="
                        }</span>
                        <span class="cov0" title="0">pkStr = fmt.Sprintf("%s%s%d", pkStr, sep, at.Sequence)</span>
                }
        }
        <span class="cov0" title="0">sk := fmt.Sprintf("%s %s", at.Type.Name, pkStr)
        if at.Revision == RevisionNotKnown </span><span class="cov0" title="0">{
                return sk
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s at revision %d", sk, at.Revision)</span>
}

// Resolve resolves the sequence with known sequence number using the given find function.
func (at *AtSequence) Resolve(find func(assertType *AssertionType, headers map[string]string) (Assertion, error)) (Assertion, error) <span class="cov0" title="0">{
        if at.Sequence &lt;= 0 </span><span class="cov0" title="0">{
                hdrs, err := HeadersFromSequenceKey(at.Type, at.SequenceKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%q assertion reference sequence key %v is invalid: %v", at.Type.Name, at.SequenceKey, err)
                }</span>
                <span class="cov0" title="0">return nil, &amp;NotFoundError{
                        Type:    at.Type,
                        Headers: hdrs,
                }</span>
        }
        <span class="cov0" title="0">pkey := append(at.SequenceKey, fmt.Sprintf("%d", at.Sequence))
        headers, err := HeadersFromPrimaryKey(at.Type, pkey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q assertion reference primary key has the wrong length (expected %v): %v", at.Type.Name, at.Type.PrimaryKey, pkey)
        }</span>
        <span class="cov0" title="0">return find(at.Type, headers)</span>
}

// Assertion represents an assertion through its general elements.
type Assertion interface {
        // Type returns the type of this assertion
        Type() *AssertionType
        // Format returns the format iteration of this assertion
        Format() int
        // SupportedFormat returns whether the assertion uses a supported
        // format iteration. If false the assertion might have been only
        // partially parsed.
        SupportedFormat() bool
        // Revision returns the revision of this assertion
        Revision() int
        // AuthorityID returns the authority responsible for this
        // assertion
        AuthorityID() string

        // Header retrieves the header with name
        Header(name string) any

        // Headers returns the complete headers
        Headers() map[string]any

        // HeaderString retrieves the string value of header with name or ""
        HeaderString(name string) string

        // Body returns the body of this assertion
        Body() []byte

        // Signature returns the signed content and its unprocessed signature
        Signature() (content, signature []byte)

        // SignKeyID returns the key id for the key that signed this assertion.
        SignKeyID() string

        // Prerequisites returns references to the prerequisite assertions for the validity of this one.
        Prerequisites() []*Ref

        // Ref returns a reference representing this assertion.
        Ref() *Ref

        // At returns an AtRevision referencing this assertion at its revision.
        At() *AtRevision
}

// SequenceMember is implemented by assertions of sequence forming types.
type SequenceMember interface {
        Assertion

        // Sequence returns the sequence number of this assertion.
        Sequence() int
}

// customSigner represents an assertion with special arrangements for its signing key (e.g. self-signed), rather than the usual case where an assertion is signed by its authority.
type customSigner interface {
        // signKey returns the public key material for the key that signed this assertion.  See also SignKeyID.
        signKey(db RODatabase) (PublicKey, error)
}

// MediaType is the media type for encoded assertions on the wire.
const MediaType = "application/x.ubuntu.assertion"

// assertionBase is the concrete base to hold representation data for actual assertions.
type assertionBase struct {
        headers map[string]any
        body    []byte
        // parsed format iteration
        format int
        // parsed revision
        revision int
        // preserved content
        content []byte
        // unprocessed signature
        signature []byte
}

// HeaderString retrieves the string value of header with name or ""
func (ab *assertionBase) HeaderString(name string) string <span class="cov8" title="1">{
        s, _ := ab.headers[name].(string)
        return s
}</span>

// Type returns the assertion type.
func (ab *assertionBase) Type() *AssertionType <span class="cov8" title="1">{
        return Type(ab.HeaderString("type"))
}</span>

// Format returns the assertion format iteration.
func (ab *assertionBase) Format() int <span class="cov0" title="0">{
        return ab.format
}</span>

// SupportedFormat returns whether the assertion uses a supported
// format iteration. If false the assertion might have been only
// partially parsed.
func (ab *assertionBase) SupportedFormat() bool <span class="cov0" title="0">{
        return ab.format &lt;= maxSupportedFormat[ab.HeaderString("type")]
}</span>

// Revision returns the assertion revision.
func (ab *assertionBase) Revision() int <span class="cov0" title="0">{
        return ab.revision
}</span>

// AuthorityID returns the authority-id a.k.a the authority responsible for the assertion.
func (ab *assertionBase) AuthorityID() string <span class="cov0" title="0">{
        return ab.HeaderString("authority-id")
}</span>

// Header returns the value of an header by name.
func (ab *assertionBase) Header(name string) any <span class="cov0" title="0">{
        v := ab.headers[name]
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return copyHeader(v)</span>
}

// Headers returns the complete headers.
func (ab *assertionBase) Headers() map[string]any <span class="cov0" title="0">{
        return copyHeaders(ab.headers)
}</span>

// Body returns the body of the assertion.
func (ab *assertionBase) Body() []byte <span class="cov8" title="1">{
        return ab.body
}</span>

// Signature returns the signed content and its unprocessed signature.
func (ab *assertionBase) Signature() (content, signature []byte) <span class="cov0" title="0">{
        return ab.content, ab.signature
}</span>

// SignKeyID returns the key id for the key that signed this assertion.
func (ab *assertionBase) SignKeyID() string <span class="cov0" title="0">{
        return ab.HeaderString("sign-key-sha3-384")
}</span>

// Prerequisites returns references to the prerequisite assertions for the validity of this one.
func (ab *assertionBase) Prerequisites() []*Ref <span class="cov0" title="0">{
        return nil
}</span>

// Ref returns a reference representing this assertion.
func (ab *assertionBase) Ref() *Ref <span class="cov0" title="0">{
        assertType := ab.Type()
        primKey := make([]string, len(assertType.PrimaryKey))
        for i, name := range assertType.PrimaryKey </span><span class="cov0" title="0">{
                primKey[i] = ab.HeaderString(name)
        }</span>
        <span class="cov0" title="0">return &amp;Ref{
                Type:       assertType,
                PrimaryKey: primKey,
        }</span>
}

// At returns an AtRevision referencing this assertion at its revision.
func (ab *assertionBase) At() *AtRevision <span class="cov0" title="0">{
        return &amp;AtRevision{Ref: *ab.Ref(), Revision: ab.Revision()}
}</span>

// expected interface is implemented
var _ Assertion = (*assertionBase)(nil)

// Decode parses a serialized assertion.
//
// The expected serialisation format looks like:
//
//        HEADER ("\n\n" BODY?)? "\n\n" SIGNATURE
//
// where:
//
//        HEADER is a set of header entries separated by "\n"
//        BODY can be arbitrary text,
//        SIGNATURE is the signature
//
// Both BODY and HEADER must be UTF8.
//
// A header entry for a single line value (no '\n' in it) looks like:
//
//        NAME ": " SIMPLEVALUE
//
// The format supports multiline text values (with '\n's in them) and
// lists or maps, possibly nested, with string scalars in them.
//
// For those a header entry looks like:
//
//        NAME ":\n" MULTI(baseindent)
//
// where MULTI can be
//
// * (baseindent + 4)-space indented value (multiline text)
//
// * entries of a list each of the form:
//
//        " "*baseindent "  -"  ( " " SIMPLEVALUE | "\n" MULTI )
//
// * entries of map each of the form:
//
//        " "*baseindent "  " NAME ":"  ( " " SIMPLEVALUE | "\n" MULTI )
//
// baseindent starts at 0 and then grows with nesting matching the
// previous level introduction (e.g. the " "*baseindent " -" bit)
// length minus 1.
//
// In general the following headers are mandatory:
//
//        type
//        authority-id (except for on the wire/self-signed assertions like serial-request)
//
// Further for a given assertion type all the primary key headers
// must be non empty and must not contain '/'.
//
// The following headers expect string representing integer values and
// if omitted otherwise are assumed to be 0:
//
//        revision (a positive int)
//        body-length (expected to be equal to the length of BODY)
//        format (a positive int for the format iteration of the type used)
//
// Times are expected to be in the RFC3339 format: "2006-01-02T15:04:05Z07:00".
func Decode(serializedAssertion []byte) (Assertion, error) <span class="cov8" title="1">{
        // copy to get an independent backstorage that can't be mutated later
        assertionSnapshot := make([]byte, len(serializedAssertion))
        copy(assertionSnapshot, serializedAssertion)
        contentSignatureSplit := bytes.LastIndex(assertionSnapshot, nlnl)
        if contentSignatureSplit == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion content/signature separator not found")
        }</span>
        <span class="cov8" title="1">content := assertionSnapshot[:contentSignatureSplit]
        signature := assertionSnapshot[contentSignatureSplit+2:]

        headersBodySplit := bytes.Index(content, nlnl)
        var body, head []byte
        if headersBodySplit == -1 </span><span class="cov8" title="1">{
                head = content
        }</span> else<span class="cov0" title="0"> {
                body = content[headersBodySplit+2:]
                if len(body) == 0 </span><span class="cov0" title="0">{
                        body = nil
                }</span>
                <span class="cov0" title="0">head = content[:headersBodySplit]</span>
        }

        <span class="cov8" title="1">headers, err := parseHeaders(head)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing assertion headers: %v", err)
        }</span>

        <span class="cov8" title="1">return assemble(headers, body, content, signature)</span>
}

// Maximum assertion component sizes.
const (
        MaxBodySize      = 2 * 1024 * 1024
        MaxHeadersSize   = 128 * 1024
        MaxSignatureSize = 128 * 1024
)

// Decoder parses a stream of assertions bundled by separating them with double newlines.
type Decoder struct {
        rd             io.Reader
        initialBufSize int
        b              *bufio.Reader
        err            error
        maxHeadersSize int
        maxSigSize     int

        defaultMaxBodySize int
        typeMaxBodySize    map[*AssertionType]int
}

// initBuffer finishes a Decoder initialization by setting up the bufio.Reader,
// it returns the *Decoder for convenience of notation.
func (d *Decoder) initBuffer() *Decoder <span class="cov0" title="0">{
        d.b = bufio.NewReaderSize(d.rd, d.initialBufSize)
        return d
}</span>

const defaultDecoderBufSize = 4096

// NewDecoder returns a Decoder to parse the stream of assertions from the reader.
func NewDecoder(r io.Reader) *Decoder <span class="cov0" title="0">{
        return (&amp;Decoder{
                rd:                 r,
                initialBufSize:     defaultDecoderBufSize,
                maxHeadersSize:     MaxHeadersSize,
                maxSigSize:         MaxSignatureSize,
                defaultMaxBodySize: MaxBodySize,
        }).initBuffer()
}</span>

// NewDecoderWithTypeMaxBodySize returns a Decoder to parse the stream of assertions from the reader enforcing optional per type max body sizes or the default one as fallback.
func NewDecoderWithTypeMaxBodySize(r io.Reader, typeMaxBodySize map[*AssertionType]int) *Decoder <span class="cov0" title="0">{
        return (&amp;Decoder{
                rd:                 r,
                initialBufSize:     defaultDecoderBufSize,
                maxHeadersSize:     MaxHeadersSize,
                maxSigSize:         MaxSignatureSize,
                defaultMaxBodySize: MaxBodySize,
                typeMaxBodySize:    typeMaxBodySize,
        }).initBuffer()
}</span>

func (d *Decoder) peek(size int) ([]byte, error) <span class="cov0" title="0">{
        buf, err := d.b.Peek(size)
        if err == bufio.ErrBufferFull </span><span class="cov0" title="0">{
                rebuf, reerr := d.b.Peek(d.b.Buffered())
                if reerr != nil </span><span class="cov0" title="0">{
                        panic(reerr)</span>
                }
                <span class="cov0" title="0">mr := io.MultiReader(bytes.NewBuffer(rebuf), d.rd)
                d.b = bufio.NewReaderSize(mr, (size/d.initialBufSize+1)*d.initialBufSize)
                buf, err = d.b.Peek(size)</span>
        }
        <span class="cov0" title="0">if err != nil &amp;&amp; d.err == nil </span><span class="cov0" title="0">{
                d.err = err
        }</span>
        <span class="cov0" title="0">return buf, d.err</span>
}

// NB: readExact and readUntil use peek underneath and their returned
// buffers are valid only until the next reading call

func (d *Decoder) readExact(size int) ([]byte, error) <span class="cov0" title="0">{
        buf, err := d.peek(size)
        d.b.Discard(len(buf))
        if len(buf) == size </span><span class="cov0" title="0">{
                return buf, nil
        }</span>
        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                return buf, io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return buf, err</span>
}

func (d *Decoder) readUntil(delim []byte, maxSize int) ([]byte, error) <span class="cov0" title="0">{
        last := 0
        size := d.initialBufSize
        for </span><span class="cov0" title="0">{
                buf, err := d.peek(size)
                if i := bytes.Index(buf[last:], delim); i &gt;= 0 </span><span class="cov0" title="0">{
                        d.b.Discard(last + i + len(delim))
                        return buf[:last+i+len(delim)], nil
                }</span>
                // report errors only once we have consumed what is buffered
                <span class="cov0" title="0">if err != nil &amp;&amp; len(buf) == d.b.Buffered() </span><span class="cov0" title="0">{
                        d.b.Discard(len(buf))
                        return buf, err
                }</span>
                <span class="cov0" title="0">last = size - len(delim) + 1
                size *= 2
                if size &gt; maxSize </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("maximum size exceeded while looking for delimiter %q", delim)
                }</span>
        }
}

// Decode parses the next assertion from the stream.
// It returns the error io.EOF at the end of a well-formed stream.
func (d *Decoder) Decode() (Assertion, error) <span class="cov0" title="0">{
        // read the headers and the nlnl separator after them
        headAndSep, err := d.readUntil(nlnl, d.maxHeadersSize)
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        if len(headAndSep) != 0 </span><span class="cov0" title="0">{
                                return nil, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return nil, io.EOF</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("error reading assertion headers: %v", err)</span>
        }

        <span class="cov0" title="0">headLen := len(headAndSep) - len(nlnl)
        headers, err := parseHeaders(headAndSep[:headLen])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing assertion headers: %v", err)
        }</span>

        <span class="cov0" title="0">typeStr, _ := headers["type"].(string)
        typ := Type(typeStr)

        length, err := checkIntWithDefault(headers, "body-length", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>
        <span class="cov0" title="0">if typMaxBodySize := d.typeMaxBodySize[typ]; typMaxBodySize != 0 &amp;&amp; length &gt; typMaxBodySize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion body length %d exceeds maximum body size %d for %q assertions", length, typMaxBodySize, typ.Name)
        }</span> else<span class="cov0" title="0"> if length &gt; d.defaultMaxBodySize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion body length %d exceeds maximum body size", length)
        }</span>

        // save the headers before we try to read more, and setup to capture
        // the whole content in a buffer
        <span class="cov0" title="0">contentBuf := bytes.NewBuffer(make([]byte, 0, len(headAndSep)+length))
        contentBuf.Write(headAndSep)

        if length &gt; 0 </span><span class="cov0" title="0">{
                // read the body if length != 0
                body, err := d.readExact(length)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">contentBuf.Write(body)</span>
        }

        // try to read the end of body a.k.a content/signature separator
        <span class="cov0" title="0">endOfBody, err := d.readUntil(nlnl, d.maxSigSize)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading assertion trailer: %v", err)
        }</span>

        <span class="cov0" title="0">var sig []byte
        if bytes.Equal(endOfBody, nlnl) </span><span class="cov0" title="0">{
                // we got the nlnl content/signature separator, read the signature now and the assertion/assertion nlnl separation
                sig, err = d.readUntil(nlnl, d.maxSigSize)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading assertion signature: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // we got the signature directly which is a ok format only if body length == 0
                if length &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("missing content/signature separator")
                }</span>
                <span class="cov0" title="0">sig = endOfBody
                contentBuf.Truncate(headLen)</span>
        }

        // normalize sig ending newlines
        <span class="cov0" title="0">if bytes.HasSuffix(sig, nlnl) </span><span class="cov0" title="0">{
                sig = sig[:len(sig)-1]
        }</span>

        <span class="cov0" title="0">finalContent := contentBuf.Bytes()
        var finalBody []byte
        if length &gt; 0 </span><span class="cov0" title="0">{
                finalBody = finalContent[headLen+len(nlnl):]
        }</span>

        <span class="cov0" title="0">finalSig := make([]byte, len(sig))
        copy(finalSig, sig)

        return assemble(headers, finalBody, finalContent, finalSig)</span>
}

func checkIteration(headers map[string]any, name string) (int, error) <span class="cov8" title="1">{
        iternum, err := checkIntWithDefault(headers, name, 0)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">if iternum &lt; 0 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("%s should be positive: %v", name, iternum)
        }</span>
        <span class="cov8" title="1">return iternum, nil</span>
}

func checkFormat(headers map[string]any) (int, error) <span class="cov8" title="1">{
        return checkIteration(headers, "format")
}</span>

func checkRevision(headers map[string]any) (int, error) <span class="cov8" title="1">{
        return checkIteration(headers, "revision")
}</span>

// Assemble assembles an assertion from its components.
func Assemble(headers map[string]any, body, content, signature []byte) (Assertion, error) <span class="cov0" title="0">{
        err := checkHeaders(headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return assemble(headers, body, content, signature)</span>
}

func checkAuthority(_ *AssertionType, headers map[string]any) error <span class="cov8" title="1">{
        if _, err := checkNotEmptyString(headers, "authority-id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkNoAuthority(assertType *AssertionType, headers map[string]any) error <span class="cov0" title="0">{
        if _, ok := headers["authority-id"]; ok </span><span class="cov0" title="0">{
                return fmt.Errorf("%q assertion cannot have authority-id set", assertType.Name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func checkJSON(assertType *AssertionType, body []byte) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("assertion %s: %v", assertType.Name, err)
                }</span>
        }()

        <span class="cov0" title="0">if body == nil </span><span class="cov0" title="0">{
                return fmt.Errorf(`body must contain JSON`)
        }</span>

        <span class="cov0" title="0">var val any
        if err := json.Unmarshal(body, &amp;val); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON in body: %v", err)
        }</span>

        <span class="cov0" title="0">formatted, err := json.MarshalIndent(val, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON in body: %v", err)
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(body, formatted) </span><span class="cov0" title="0">{
                // TODO: replace this with a manual comparison so we can give more context
                // in the error message
                return fmt.Errorf(`JSON in body must be indented with 2 spaces and sort object entries by key`)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// assemble is the internal variant of Assemble, assumes headers are already checked for supported types
func assemble(headers map[string]any, body, content, signature []byte) (Assertion, error) <span class="cov8" title="1">{
        length, err := checkIntWithDefault(headers, "body-length", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>
        <span class="cov8" title="1">if length != len(body) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion body length and declared body-length don't match: %v != %v", len(body), length)
        }</span>

        <span class="cov8" title="1">if !utf8.Valid(body) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion body is not utf8")
        }</span>

        <span class="cov8" title="1">if _, err := checkDigest(headers, "sign-key-sha3-384", crypto.SHA3_384); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>

        <span class="cov8" title="1">typ, err := checkNotEmptyString(headers, "type")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>
        <span class="cov8" title="1">assertType := Type(typ)
        if assertType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown assertion type: %q", typ)
        }</span>

        <span class="cov8" title="1">if assertType.flags&amp;jsonBody != 0 </span><span class="cov0" title="0">{
                if err := checkJSON(assertType, body); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if assertType.flags&amp;noAuthority == 0 </span><span class="cov8" title="1">{
                if err := checkAuthority(assertType, headers); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("assertion: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := checkNoAuthority(assertType, headers); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">formatnum, err := checkFormat(headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>

        <span class="cov8" title="1">for _, primKey := range assertType.PrimaryKey </span><span class="cov8" title="1">{
                if _, ok := headers[primKey]; !ok </span><span class="cov8" title="1">{
                        if defl := assertType.OptionalPrimaryKeyDefaults[primKey]; defl != "" </span><span class="cov0" title="0">{
                                headers[primKey] = defl
                        }</span>
                }
                <span class="cov8" title="1">if _, err := checkPrimaryKey(headers, primKey); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("assertion %s: %v", assertType.Name, err)
                }</span>
        }

        <span class="cov8" title="1">revision, err := checkRevision(headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion: %v", err)
        }</span>

        <span class="cov8" title="1">if len(signature) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty assertion signature")
        }</span>

        <span class="cov8" title="1">assert, err := assertType.assembler(assertionBase{
                headers:   headers,
                body:      body,
                format:    formatnum,
                revision:  revision,
                content:   content,
                signature: signature,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("assertion %s: %v", assertType.Name, err)
        }</span>
        <span class="cov8" title="1">return assert, nil</span>
}

func writeHeader(buf *bytes.Buffer, headers map[string]any, name string) <span class="cov0" title="0">{
        appendEntry(buf, fmt.Sprintf("%s:", name), headers[name], 0)
}</span>

func assembleAndSign(assertType *AssertionType, headers map[string]any, body []byte, privKey PrivateKey) (Assertion, error) <span class="cov0" title="0">{
        err := checkAssertType(assertType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">withAuthority := assertType.flags&amp;noAuthority == 0
        withJSONBody := assertType.flags&amp;jsonBody != 0

        err = checkHeaders(headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // there's no hint at all that we will need non-textual bodies,
        // make sure we actually enforce that
        <span class="cov0" title="0">if !utf8.Valid(body) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion body is not utf8")
        }</span>

        <span class="cov0" title="0">if withJSONBody </span><span class="cov0" title="0">{
                if err := checkJSON(assertType, body); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">finalHeaders := copyHeaders(headers)
        bodyLength := len(body)
        finalBody := make([]byte, bodyLength)
        copy(finalBody, body)
        finalHeaders["type"] = assertType.Name
        finalHeaders["body-length"] = strconv.Itoa(bodyLength)
        finalHeaders["sign-key-sha3-384"] = privKey.PublicKey().ID()

        if withAuthority </span><span class="cov0" title="0">{
                if err = checkAuthority(assertType, finalHeaders); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := checkNoAuthority(assertType, finalHeaders); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">formatnum, err := checkFormat(finalHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if formatnum &gt; assertType.MaxSupportedFormat() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign %q assertion with format %d higher than max supported format %d", assertType.Name, formatnum, assertType.MaxSupportedFormat())
        }</span>

        <span class="cov0" title="0">suggestedFormat, err := SuggestFormat(assertType, finalHeaders, finalBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if suggestedFormat &gt; formatnum </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign %q assertion with format set to %d lower than min format %d covering included features", assertType.Name, formatnum, suggestedFormat)
        }</span>

        <span class="cov0" title="0">revision, err := checkRevision(finalHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf := bytes.NewBufferString("type: ")
        buf.WriteString(assertType.Name)

        if formatnum &gt; 0 </span><span class="cov0" title="0">{
                writeHeader(buf, finalHeaders, "format")
        }</span> else<span class="cov0" title="0"> {
                delete(finalHeaders, "format")
        }</span>

        <span class="cov0" title="0">if withAuthority </span><span class="cov0" title="0">{
                writeHeader(buf, finalHeaders, "authority-id")
        }</span>

        <span class="cov0" title="0">if revision &gt; 0 </span><span class="cov0" title="0">{
                writeHeader(buf, finalHeaders, "revision")
        }</span> else<span class="cov0" title="0"> {
                delete(finalHeaders, "revision")
        }</span>
        <span class="cov0" title="0">written := map[string]bool{
                "type":              true,
                "format":            true,
                "authority-id":      true,
                "revision":          true,
                "body-length":       true,
                "sign-key-sha3-384": true,
        }
        for _, primKey := range assertType.PrimaryKey </span><span class="cov0" title="0">{
                defl := assertType.OptionalPrimaryKeyDefaults[primKey]
                _, ok := finalHeaders[primKey]
                if !ok &amp;&amp; defl != "" </span><span class="cov0" title="0">{
                        // optional but expected to be set in headers
                        // in the result assertion
                        finalHeaders[primKey] = defl
                        continue</span>
                }
                <span class="cov0" title="0">value, err := checkPrimaryKey(finalHeaders, primKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if value != defl </span><span class="cov0" title="0">{
                        writeHeader(buf, finalHeaders, primKey)
                }</span>
                <span class="cov0" title="0">written[primKey] = true</span>
        }

        // emit other headers in lexicographic order
        <span class="cov0" title="0">otherKeys := make([]string, 0, len(finalHeaders))
        for name := range finalHeaders </span><span class="cov0" title="0">{
                if !written[name] </span><span class="cov0" title="0">{
                        otherKeys = append(otherKeys, name)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(otherKeys)
        for _, k := range otherKeys </span><span class="cov0" title="0">{
                writeHeader(buf, finalHeaders, k)
        }</span>

        // body-length and body
        <span class="cov0" title="0">if bodyLength &gt; 0 </span><span class="cov0" title="0">{
                writeHeader(buf, finalHeaders, "body-length")
        }</span> else<span class="cov0" title="0"> {
                delete(finalHeaders, "body-length")
        }</span>

        // signing key reference
        <span class="cov0" title="0">writeHeader(buf, finalHeaders, "sign-key-sha3-384")

        if bodyLength &gt; 0 </span><span class="cov0" title="0">{
                buf.Grow(bodyLength + 2)
                buf.Write(nlnl)
                buf.Write(finalBody)
        }</span> else<span class="cov0" title="0"> {
                finalBody = nil
        }</span>
        <span class="cov0" title="0">content := buf.Bytes()

        signature, err := signAndEncode(content, privKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign assertion: %v", err)
        }</span>
        // be 'cat' friendly, add a ignored newline to the signature which is the last part of the encoded assertion
        <span class="cov0" title="0">signature = append(signature, '\n')

        assert, err := assertType.assembler(assertionBase{
                headers:   finalHeaders,
                body:      finalBody,
                format:    formatnum,
                revision:  revision,
                content:   content,
                signature: signature,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot assemble assertion %s: %v", assertType.Name, err)
        }</span>
        <span class="cov0" title="0">return assert, nil</span>
}

// SignWithoutAuthority assembles an assertion without a set authority with the provided information and signs it with the given private key.
func SignWithoutAuthority(assertType *AssertionType, headers map[string]any, body []byte, privKey PrivateKey) (Assertion, error) <span class="cov0" title="0">{
        if assertType.flags&amp;noAuthority == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign assertions needing a definite authority with SignWithoutAuthority")
        }</span>
        <span class="cov0" title="0">return assembleAndSign(assertType, headers, body, privKey)</span>
}

// Encode serializes an assertion.
func Encode(assert Assertion) []byte <span class="cov0" title="0">{
        content, signature := assert.Signature()
        needed := len(content) + 2 + len(signature)
        buf := bytes.NewBuffer(make([]byte, 0, needed))
        buf.Write(content)
        buf.Write(nlnl)
        buf.Write(signature)
        return buf.Bytes()
}</span>

// Encoder emits a stream of assertions bundled by separating them with double newlines.
type Encoder struct {
        wr      io.Writer
        nextSep []byte
}

// NewEncoder returns a Encoder to emit a stream of assertions to a writer.
func NewEncoder(w io.Writer) *Encoder <span class="cov0" title="0">{
        return &amp;Encoder{wr: w}
}</span>

func (enc *Encoder) writeSep(last byte) error <span class="cov0" title="0">{
        if last != '\n' </span><span class="cov0" title="0">{
                _, err := enc.wr.Write(nl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">enc.nextSep = nl
        return nil</span>
}

// WriteEncoded writes the encoded assertion into the stream with the required separator.
func (enc *Encoder) WriteEncoded(encoded []byte) error <span class="cov0" title="0">{
        sz := len(encoded)
        if sz == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: encoded assertion cannot be empty")
        }</span>

        <span class="cov0" title="0">_, err := enc.wr.Write(enc.nextSep)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = enc.wr.Write(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return enc.writeSep(encoded[sz-1])</span>
}

// WriteContentSignature writes the content and signature of an assertion into the stream with all the required separators.
func (enc *Encoder) WriteContentSignature(content, signature []byte) error <span class="cov0" title="0">{
        if len(content) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: content cannot be empty")
        }</span>

        <span class="cov0" title="0">sz := len(signature)
        if sz == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: signature cannot be empty")
        }</span>

        <span class="cov0" title="0">_, err := enc.wr.Write(enc.nextSep)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = enc.wr.Write(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = enc.wr.Write(nlnl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = enc.wr.Write(signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return enc.writeSep(signature[sz-1])</span>
}

// Encode emits the assertion into the stream with the required separator.
// Errors here are always about writing given that Encode() itself cannot error.
func (enc *Encoder) Encode(assert Assertion) error <span class="cov0" title="0">{
        return enc.WriteContentSignature(assert.Signature())
}</span>

// SignatureCheck checks the signature of the assertion against the given public key. Useful for assertions with no authority.
func SignatureCheck(assert Assertion, pubKey PublicKey) error <span class="cov0" title="0">{
        content, encodedSig := assert.Signature()
        sig, err := decodeSignature(encodedSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = pubKey.verify(content, sig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed signature verification: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2021 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "io"
        "strings"
)

// Batch allows to accumulate a set of assertions possibly out of
// prerequisite order and then add them in one go to an assertion
// database.
// Nothing will be committed if there are missing prerequisites, for a full
// consistency check beforehand there is the Precheck option.
type Batch struct {
        bs    Backstore
        added []Assertion
        // added is in prereq order
        inPrereqOrder bool

        unsupported func(u *Ref, err error) error
}

// NewBatch creates a new Batch to accumulate assertions to add in one
// go to an assertion database.
// unsupported can be used to ignore/log assertions with unsupported formats,
// default behavior is to error on them.
func NewBatch(unsupported func(u *Ref, err error) error) *Batch <span class="cov0" title="0">{
        if unsupported == nil </span><span class="cov0" title="0">{
                unsupported = func(_ *Ref, err error) error </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return &amp;Batch{
                bs:            NewMemoryBackstore(),
                inPrereqOrder: true, // empty list is trivially so
                unsupported:   unsupported,
        }</span>
}

// Add one assertion to the batch.
func (b *Batch) Add(a Assertion) error <span class="cov0" title="0">{
        b.inPrereqOrder = false

        if !a.SupportedFormat() </span><span class="cov0" title="0">{
                err := &amp;UnsupportedFormatError{Ref: a.Ref(), Format: a.Format()}
                return b.unsupported(a.Ref(), err)
        }</span>
        <span class="cov0" title="0">if err := b.bs.Put(a.Type(), a); err != nil </span><span class="cov0" title="0">{
                if revErr, ok := err.(*RevisionError); ok </span><span class="cov0" title="0">{
                        if revErr.Current &gt;= a.Revision() </span><span class="cov0" title="0">{
                                // we already got something more recent
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">b.added = append(b.added, a)
        return nil</span>
}

// AddStream adds a stream of assertions to the batch.
// Returns references to the assertions effectively added.
func (b *Batch) AddStream(r io.Reader) ([]*Ref, error) <span class="cov0" title="0">{
        b.inPrereqOrder = false

        start := len(b.added)
        dec := NewDecoder(r)
        for </span><span class="cov0" title="0">{
                a, err := dec.Decode()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := b.Add(a); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">added := b.added[start:]
        if len(added) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">refs := make([]*Ref, len(added))
        for i, a := range added </span><span class="cov0" title="0">{
                refs[i] = a.Ref()
        }</span>
        <span class="cov0" title="0">return refs, nil</span>
}

// Fetch adds to the batch by invoking fetching to drive an internal
// Fetcher that was built with trustedDB and retrieve.
func (b *Batch) Fetch(trustedDB RODatabase, retrieve func(*Ref) (Assertion, error), fetching func(Fetcher) error) error <span class="cov0" title="0">{
        f := NewFetcher(trustedDB, retrieve, b.Add)
        return fetching(f)
}</span>

func (b *Batch) precheck(db *Database) error <span class="cov0" title="0">{
        db = db.WithStackedBackstore(NewMemoryBackstore())
        return b.commitTo(db, nil)
}</span>

type CommitOptions struct {
        // Precheck indicates whether to do a full consistency check
        // before starting adding the batch.
        Precheck bool
}

// CommitTo adds the batch of assertions to the given assertion database.
// Nothing will be committed if there are missing prerequisites, for a full
// consistency check beforehand there is the Precheck option.
func (b *Batch) CommitTo(db *Database, opts *CommitOptions) error <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;CommitOptions{}
        }</span>
        <span class="cov0" title="0">if opts.Precheck </span><span class="cov0" title="0">{
                if err := b.precheck(db); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return b.commitTo(db, nil)</span>
}

// CommitToAndObserve adds the batch of assertions to the given
// assertion database while invoking observe for each one after they
// are added.
// Nothing will be committed if there are missing prerequisites, for a
// full consistency check beforehand there is the Precheck option.
// For convenience observe can be nil in which case is ignored.
func (b *Batch) CommitToAndObserve(db *Database, observe func(Assertion), opts *CommitOptions) error <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;CommitOptions{}
        }</span>
        <span class="cov0" title="0">if opts.Precheck </span><span class="cov0" title="0">{
                if err := b.precheck(db); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return b.commitTo(db, observe)</span>
}

// commitTo does a best effort of adding all the batch assertions to
// the target database.
func (b *Batch) commitTo(db *Database, observe func(Assertion)) error <span class="cov0" title="0">{
        if err := b.prereqSort(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: trigger w. caller a global validity check if something is revoked
        // (but try to save as much possible still),
        // or err is a check error

        <span class="cov0" title="0">var errs []error
        for _, a := range b.added </span><span class="cov0" title="0">{
                err := db.Add(a)
                if IsUnaccceptedUpdate(err) </span><span class="cov0" title="0">{
                        // unsupported format case is handled before
                        // be idempotent
                        // system db has already the same or newer
                        continue</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> if observe != nil </span><span class="cov0" title="0">{
                        observe(a)
                }</span>
        }
        <span class="cov0" title="0">if len(errs) != 0 </span><span class="cov0" title="0">{
                return &amp;commitError{errs: errs}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *Batch) prereqSort(db *Database) error <span class="cov0" title="0">{
        if b.inPrereqOrder </span><span class="cov0" title="0">{
                // nothing to do
                return nil
        }</span>

        // put in prereq order using a fetcher
        <span class="cov0" title="0">ordered := make([]Assertion, 0, len(b.added))
        retrieve := func(ref *Ref) (Assertion, error) </span><span class="cov0" title="0">{
                a, err := b.bs.Get(ref.Type, ref.PrimaryKey, ref.Type.MaxSupportedFormat())
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        // fallback to pre-existing assertions
                        a, err = ref.Resolve(db.Find)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, resolveError("cannot resolve prerequisite assertion: %s", ref, err)
                }</span>
                <span class="cov0" title="0">return a, nil</span>
        }
        <span class="cov0" title="0">save := func(a Assertion) error </span><span class="cov0" title="0">{
                ordered = append(ordered, a)
                return nil
        }</span>
        <span class="cov0" title="0">f := NewFetcher(db, retrieve, save)

        for _, a := range b.added </span><span class="cov0" title="0">{
                if err := f.Fetch(a.Ref()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">b.added = ordered
        b.inPrereqOrder = true
        return nil</span>
}

func resolveError(format string, ref *Ref, err error) error <span class="cov0" title="0">{
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf(format, ref)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf(format+": %v", ref, err)
        }</span>
}

type commitError struct {
        errs []error
}

func (e *commitError) Error() string <span class="cov0" title="0">{
        l := []string{""}
        for _, e := range e.errs </span><span class="cov0" title="0">{
                l = append(l, e.Error())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("cannot accept some assertions:%s", strings.Join(l, "\n - "))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2025 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"

        "github.com/snapcore/snapd/snap/channel"
        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

// Cluster holds a cluster assertion, which describes a cluster of devices and
// their organization into subclusters.
type Cluster struct {
        assertionBase
        seq         int
        devices     []ClusterDevice
        subclusters []Subcluster
}

// ClusterDevice holds the details about a device in a cluster assertion.
type ClusterDevice struct {
        // ID is the unique identifier referenced from subclusters.
        ID int
        // BrandID is the device's owning brand.
        BrandID string
        // Model is the device's snap model name.
        Model string
        // Serial is the device's serial identifier.
        Serial string
        // Addresses contains this device's known IP addresses.
        Addresses []string
}

// Subcluster holds the details about a subcluster in a cluster
// assertion.
type Subcluster struct {
        // Name is the subcluster's name.
        Name string
        // Devices lists device IDs that belong to this subcluster.
        Devices []int
        // Snaps contains the expected snap state for this subcluster.
        Snaps []ClusterSnap
}

// ClusterSnapState describes the relationship of a snap to the cluster.
type ClusterSnapState string

const (
        ClusterSnapStateClustered ClusterSnapState = "clustered"
        ClusterSnapStateEvacuated ClusterSnapState = "evacuated"
        ClusterSnapStateRemoved   ClusterSnapState = "removed"
)

// ClusterSnap holds the details about a snap in a subcluster.
type ClusterSnap struct {
        // State describes the snap's state in the cluster (clustered, evacuated,
        // removed).
        State ClusterSnapState
        // Instance is the snap's instance name.
        Instance string
        // Channel is the channel the snap should track.
        Channel string
}

func validateClusterSnapState(state string) error <span class="cov0" title="0">{
        switch ClusterSnapState(state) </span>{
        case ClusterSnapStateClustered, ClusterSnapStateEvacuated, ClusterSnapStateRemoved:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("snap state must be one of: %s", strutil.Quoted([]string{
                        string(ClusterSnapStateClustered), string(ClusterSnapStateEvacuated), string(ClusterSnapStateRemoved),
                }))</span>
        }
}

// ClusterID returns the cluster's ID.
func (c *Cluster) ClusterID() string <span class="cov0" title="0">{
        return c.HeaderString("cluster-id")
}</span>

// Sequence returns the sequence number of this cluster assertion.
func (c *Cluster) Sequence() int <span class="cov0" title="0">{
        return c.seq
}</span>

// Devices returns the list of devices in the cluster.
func (c *Cluster) Devices() []ClusterDevice <span class="cov0" title="0">{
        return c.devices
}</span>

// Subclusters returns the list of subclusters.
func (c *Cluster) Subclusters() []Subcluster <span class="cov0" title="0">{
        return c.subclusters
}</span>

func checkClusterDevice(device map[string]any) (ClusterDevice, error) <span class="cov0" title="0">{
        id, err := checkInt(device, "id")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterDevice{}, err
        }</span>

        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                return ClusterDevice{}, fmt.Errorf(`"id" header must be &gt;=1: %d`, id)
        }</span>

        // TODO: revisit how we represent/parse this information once the
        // request-message assertion has been merged
        <span class="cov0" title="0">brandID, err := checkStringMatches(device, "brand-id", validAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return ClusterDevice{}, err
        }</span>

        <span class="cov0" title="0">model, err := checkModel(device)
        if err != nil </span><span class="cov0" title="0">{
                return ClusterDevice{}, err
        }</span>

        <span class="cov0" title="0">serial, err := checkNotEmptyString(device, "serial")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterDevice{}, err
        }</span>

        <span class="cov0" title="0">addresses, err := checkStringList(device, "addresses")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterDevice{}, err
        }</span>

        <span class="cov0" title="0">return ClusterDevice{
                ID:        id,
                BrandID:   brandID,
                Model:     model,
                Serial:    serial,
                Addresses: addresses,
        }, nil</span>
}

func checkClusterDevices(devices []any) ([]ClusterDevice, error) <span class="cov0" title="0">{
        result := make([]ClusterDevice, 0, len(devices))
        seenIDs := make(map[int]bool, len(devices))
        for _, entry := range devices </span><span class="cov0" title="0">{
                device, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(`"devices" field must be a list of maps`)
                }</span>

                <span class="cov0" title="0">d, err := checkClusterDevice(device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if seenIDs[d.ID] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"devices" field contains duplicate device id %d`, d.ID)
                }</span>
                <span class="cov0" title="0">seenIDs[d.ID] = true

                result = append(result, d)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func checkClusterSnap(snap map[string]any) (ClusterSnap, error) <span class="cov0" title="0">{
        state, err := checkNotEmptyString(snap, "state")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, err
        }</span>

        <span class="cov0" title="0">if err := validateClusterSnapState(state); err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, err
        }</span>

        <span class="cov0" title="0">instance, err := checkNotEmptyString(snap, "instance")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, err
        }</span>

        <span class="cov0" title="0">if err := naming.ValidateInstance(instance); err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, fmt.Errorf("invalid snap instance name: %v", err)
        }</span>

        <span class="cov0" title="0">ch, err := checkNotEmptyString(snap, "channel")
        if err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, err
        }</span>

        <span class="cov0" title="0">if _, err := channel.Parse(ch, ""); err != nil </span><span class="cov0" title="0">{
                return ClusterSnap{}, fmt.Errorf("invalid channel name %q: %v", ch, err)
        }</span>

        <span class="cov0" title="0">return ClusterSnap{
                State:    ClusterSnapState(state),
                Instance: instance,
                Channel:  ch,
        }, nil</span>
}

func checkClusterSnaps(snaps []any) ([]ClusterSnap, error) <span class="cov0" title="0">{
        result := make([]ClusterSnap, 0, len(snaps))
        for _, entry := range snaps </span><span class="cov0" title="0">{
                snap, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(`"snaps" field must be a list of maps`)
                }</span>

                <span class="cov0" title="0">s, err := checkClusterSnap(snap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, s)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func checkClusterSubcluster(subcluster map[string]any) (Subcluster, error) <span class="cov0" title="0">{
        name, err := checkNotEmptyString(subcluster, "name")
        if err != nil </span><span class="cov0" title="0">{
                return Subcluster{}, err
        }</span>

        <span class="cov0" title="0">devices, err := checkStringList(subcluster, "devices")
        if err != nil </span><span class="cov0" title="0">{
                return Subcluster{}, err
        }</span>

        <span class="cov0" title="0">ids := make([]int, 0, len(devices))
        for _, dev := range devices </span><span class="cov0" title="0">{
                id, err := atoi(dev, "device id %q", dev)
                if err != nil </span><span class="cov0" title="0">{
                        return Subcluster{}, err
                }</span>
                <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                        return Subcluster{}, fmt.Errorf("device id must be &gt;=1: %d", id)
                }</span>
                <span class="cov0" title="0">ids = append(ids, id)</span>
        }

        <span class="cov0" title="0">list, err := checkList(subcluster, "snaps")
        if err != nil </span><span class="cov0" title="0">{
                return Subcluster{}, err
        }</span>

        <span class="cov0" title="0">snaps, err := checkClusterSnaps(list)
        if err != nil </span><span class="cov0" title="0">{
                return Subcluster{}, err
        }</span>

        <span class="cov0" title="0">return Subcluster{
                Name:    name,
                Devices: ids,
                Snaps:   snaps,
        }, nil</span>
}

func checkClusterSubclusters(subclusters []any) ([]Subcluster, error) <span class="cov0" title="0">{
        result := make([]Subcluster, 0, len(subclusters))
        names := make(map[string]bool, len(subclusters))
        for _, entry := range subclusters </span><span class="cov0" title="0">{
                subcluster, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(`"subclusters" field must be a list of maps`)
                }</span>

                <span class="cov0" title="0">s, err := checkClusterSubcluster(subcluster)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if names[s.Name] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"subclusters" field contains duplicate subcluster name %q`, s.Name)
                }</span>
                <span class="cov0" title="0">names[s.Name] = true

                result = append(result, s)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func validateClusterDeviceIDs(devices []ClusterDevice, subclusters []Subcluster) error <span class="cov0" title="0">{
        seen := make(map[int]bool, len(devices))
        for _, device := range devices </span><span class="cov0" title="0">{
                seen[device.ID] = true
        }</span>

        <span class="cov0" title="0">for _, subcluster := range subclusters </span><span class="cov0" title="0">{
                for _, id := range subcluster.Devices </span><span class="cov0" title="0">{
                        if !seen[id] </span><span class="cov0" title="0">{
                                return fmt.Errorf("\"subclusters\" references unknown device id %d", id)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func assembleCluster(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        seq, err := checkSequence(assert.headers, "sequence")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">list, err := checkList(assert.headers, "devices")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">devices, err := checkClusterDevices(list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">list, err = checkList(assert.headers, "subclusters")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">subclusters, err := checkClusterSubclusters(list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateClusterDeviceIDs(devices, subclusters); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Cluster{
                assertionBase: assert,
                seq:           seq,
                devices:       devices,
                subclusters:   subclusters,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2024 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/snapcore/snapd/confdb"
)

// ConfdbSchema holds a confdb-schema assertion, which is a definition by an
// account of access views and a storage schema for a set of related
// configuration options under the purview of the account.
type ConfdbSchema struct {
        assertionBase

        schema    *confdb.Schema
        timestamp time.Time
}

// AccountID returns the identifier of the account that signed this assertion.
func (ar *ConfdbSchema) AccountID() string <span class="cov0" title="0">{
        return ar.HeaderString("account-id")
}</span>

// Name returns the name for the confdb.
func (ar *ConfdbSchema) Name() string <span class="cov0" title="0">{
        return ar.HeaderString("name")
}</span>

// Schema returns a confdb.Schema assembled from the assertion that can
// be used to access confdb views.
func (ar *ConfdbSchema) Schema() *confdb.Schema <span class="cov0" title="0">{
        return ar.schema
}</span>

func assembleConfdbSchema(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        authorityID := assert.AuthorityID()
        accountID := assert.HeaderString("account-id")
        if accountID != authorityID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authority-id and account-id must match, confdb assertions are expected to be signed by the issuer account: %q != %q", authorityID, accountID)
        }</span>

        <span class="cov0" title="0">name, err := checkStringMatches(assert.headers, "name", confdb.ValidConfdbName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">viewsMap, err := checkMap(assert.headers, "views")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if viewsMap == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"views" stanza is mandatory`)
        }</span>

        <span class="cov0" title="0">if _, err := checkOptionalString(assert.headers, "summary"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var bodyMap map[string]json.RawMessage
        if err := json.Unmarshal(assert.body, &amp;bodyMap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">schemaRaw, ok := bodyMap["storage"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`body must contain a "storage" stanza`)
        }</span>

        <span class="cov0" title="0">schema, err := confdb.ParseStorageSchema(schemaRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`invalid schema: %w`, err)
        }</span>

        <span class="cov0" title="0">confdbSchema, err := confdb.NewSchema(accountID, name, viewsMap, schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ConfdbSchema{
                assertionBase: assert,
                schema:        confdbSchema,
                timestamp:     timestamp,
        }, nil</span>
}

// ConfdbControl holds a confdb-control assertion, which holds lists of
// views delegated by the device to operators.
type ConfdbControl struct {
        assertionBase

        control *confdb.Control
}

// expected interfaces are implemented
var (
        _ customSigner = (*ConfdbControl)(nil)
)

// signKey returns the public key of the device that signed this assertion.
func (cc *ConfdbControl) signKey(db RODatabase) (PublicKey, error) <span class="cov0" title="0">{
        a, err := db.Find(SerialType, map[string]string{
                "brand-id": cc.BrandID(),
                "model":    cc.Model(),
                "serial":   cc.Serial(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find matching device serial assertion: %w", err)
        }</span>

        <span class="cov0" title="0">serial := a.(*Serial)
        key := serial.DeviceKey()
        if key.ID() != cc.SignKeyID() </span><span class="cov0" title="0">{
                return nil, errors.New("confdb-control's signing key doesn't match the device key")
        }</span>

        <span class="cov0" title="0">return key, nil</span>
}

// Prerequisites returns references to this confdb-control's prerequisite assertions.
func (cc *ConfdbControl) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: SerialType, PrimaryKey: []string{cc.BrandID(), cc.Model(), cc.Serial()}},
        }
}</span>

// BrandID returns the brand identifier of the device.
func (cc *ConfdbControl) BrandID() string <span class="cov0" title="0">{
        return cc.HeaderString("brand-id")
}</span>

// Model returns the model name identifier of the device.
func (cc *ConfdbControl) Model() string <span class="cov0" title="0">{
        return cc.HeaderString("model")
}</span>

// Serial returns the serial identifier of the device.
// Together with brand-id and model, they form the device's unique identifier.
func (cc *ConfdbControl) Serial() string <span class="cov0" title="0">{
        return cc.HeaderString("serial")
}</span>

// Control returns the confdb.Control reflecting the assertion.
func (cc *ConfdbControl) Control() confdb.Control <span class="cov0" title="0">{
        return cc.control.Clone()
}</span>

// assembleConfdbControl creates a new confdb-control assertion after validating
// all required fields and constraints.
func assembleConfdbControl(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkStringMatches(assert.headers, "brand-id", validAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if _, err := checkModel(assert.headers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">groups, err := checkList(assert.headers, "groups")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cc, err := parseConfdbControlGroups(groups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ConfdbControl{
                assertionBase: assert,
                control:       cc,
        }, nil</span>
}

func parseConfdbControlGroups(rawGroups []any) (*confdb.Control, error) <span class="cov0" title="0">{
        cc := &amp;confdb.Control{}
        for i, rawGroup := range rawGroups </span><span class="cov0" title="0">{
                errPrefix := fmt.Sprintf("cannot parse group at position %d", i+1)

                group, ok := rawGroup.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: must be a map", errPrefix)
                }</span>

                <span class="cov0" title="0">auth, err := checkStringListInMap(group, "authentications", `"authentications" field`, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", errPrefix, err)
                }</span>
                <span class="cov0" title="0">if auth == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`%s: "authentications" must be provided`, errPrefix)
                }</span>

                <span class="cov0" title="0">views, err := checkStringListInMap(group, "views", `"views" field`, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", errPrefix, err)
                }</span>
                <span class="cov0" title="0">if views == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`%s: "views" must be provided`, errPrefix)
                }</span>

                <span class="cov0" title="0">operatorIDs, err := checkStringListInMap(group, "operators", `"operators" field`, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", errPrefix, err)
                }</span>
                <span class="cov0" title="0">if operatorIDs == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`%s: "operators" must be provided`, errPrefix)
                }</span>

                <span class="cov0" title="0">for _, operatorID := range operatorIDs </span><span class="cov0" title="0">{
                        if err := cc.Delegate(operatorID, views, auth); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: %w", errPrefix, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return cc, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"

        "github.com/snapcore/snapd/interfaces/compatibility"
        "github.com/snapcore/snapd/strutil"
)

const (
        // feature label for $SLOT()/$PLUG()/$MISSING
        dollarAttrConstraintsFeature = "dollar-attr-constraints"
        // feature label for alt attribute matcher usage
        altAttrMatcherFeature = "alt-attr-matcher"
        // feature label for $PLUG_PUBLISHER_ID/$SLOT_PUBLISHER_ID
        publisherIDConstraintsFeature = "publisher-id-constraints"
)

type attrMatchingContext struct {
        // attrWord is the usage context word for "attribute", mainly
        // useful in errors
        attrWord string
        helper   AttrMatchContext
}

type attrMatcher interface {
        match(apath string, v any, ctx *attrMatchingContext) error

        feature(flabel string) bool
}

func chain(path, k string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return k
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s.%s", path, k)</span>
}

type compileAttrMatcherOptions struct {
        allowedOperations []string
        allowedRefs       []string
}

type compileContext struct {
        dotted string
        hadMap bool
        wasAlt bool

        opts *compileAttrMatcherOptions
}

func (cc compileContext) String() string <span class="cov0" title="0">{
        return cc.dotted
}</span>

func (cc compileContext) keyEntry(k string) compileContext <span class="cov0" title="0">{
        return compileContext{
                dotted: chain(cc.dotted, k),
                hadMap: true,
                wasAlt: false,
                opts:   cc.opts,
        }
}</span>

func (cc compileContext) alt(alt int) compileContext <span class="cov0" title="0">{
        return compileContext{
                dotted: fmt.Sprintf("%s/alt#%d/", cc.dotted, alt+1),
                hadMap: cc.hadMap,
                wasAlt: true,
                opts:   cc.opts,
        }
}</span>

// compileAttrMatcher compiles an attrMatcher derived from constraints,
func compileAttrMatcher(cc compileContext, constraints any) (attrMatcher, error) <span class="cov0" title="0">{
        switch x := constraints.(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                return compileMapAttrMatcher(cc, x)</span>
        case []any:<span class="cov0" title="0">
                if cc.wasAlt </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot nest alternative constraints directly at %q", cc)
                }</span>
                <span class="cov0" title="0">return compileAltAttrMatcher(cc, x)</span>
        case string:<span class="cov0" title="0">
                if !cc.hadMap </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("first level of non alternative constraints must be a set of key-value constraints")
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(x, "$") </span><span class="cov0" title="0">{
                        if x == "$MISSING" </span><span class="cov0" title="0">{
                                return missingAttrMatcher{}, nil
                        }</span>
                        <span class="cov0" title="0">return compileEvalOrRefAttrMatcher(cc, x)</span>
                }
                <span class="cov0" title="0">return compileRegexpAttrMatcher(cc, x)</span>
        default:<span class="cov0" title="0">
                c := cc.String()
                if c == "" </span><span class="cov0" title="0">{
                        c = "top constraint"
                }</span> else<span class="cov0" title="0"> {
                        c = fmt.Sprintf("constraint %q", c)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("%s must be a key-value map, regexp or a list of alternative constraints: %v", c, x)</span>
        }
}

type mapAttrMatcher map[string]attrMatcher

func compileMapAttrMatcher(cc compileContext, m map[string]any) (attrMatcher, error) <span class="cov0" title="0">{
        matcher := make(mapAttrMatcher)
        for k, constraint := range m </span><span class="cov0" title="0">{
                matcher1, err := compileAttrMatcher(cc.keyEntry(k), constraint)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">matcher[k] = matcher1</span>
        }
        <span class="cov0" title="0">return matcher, nil</span>
}

func matchEntry(apath, k string, matcher1 attrMatcher, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        apath = chain(apath, k)
        // every entry matcher expects the attribute to be set except for $MISSING
        if _, ok := matcher1.(missingAttrMatcher); !ok &amp;&amp; v == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q has constraints but is unset", ctx.attrWord, apath)
        }</span>
        <span class="cov0" title="0">if err := matcher1.match(apath, v, ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func matchList(apath string, matcher attrMatcher, l []any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        for i, elem := range l </span><span class="cov0" title="0">{
                if err := matcher.match(chain(apath, strconv.Itoa(i)), elem, ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (matcher mapAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        for _, matcher1 := range matcher </span><span class="cov0" title="0">{
                if matcher1.feature(flabel) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (matcher mapAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        switch x := v.(type) </span>{
        case Attrer:<span class="cov0" title="0">
                // we get Atter from root-level Check (apath is "")
                for k, matcher1 := range matcher </span><span class="cov0" title="0">{
                        v, _ := x.Lookup(k)
                        if err := matchEntry("", k, matcher1, v, ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case map[string]any:<span class="cov0" title="0"> // maps in attributes look like this
                for k, matcher1 := range matcher </span><span class="cov0" title="0">{
                        if err := matchEntry(apath, k, matcher1, x[k], ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case []any:<span class="cov0" title="0">
                return matchList(apath, matcher, x, ctx)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("%s %q must be a map", ctx.attrWord, apath)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type missingAttrMatcher struct{}

func (matcher missingAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        return flabel == dollarAttrConstraintsFeature
}</span>

func (matcher missingAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q is constrained to be missing but is set", ctx.attrWord, apath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type evalAttrMatcher struct {
        // first iteration supports just $(SLOT|PLUG)(arg)
        op  string
        arg string
        // Function that checks if the attributes match
        matchAttr func(v1, v2 any) bool
}

var (
        validEvalAttrMatcher    = regexp.MustCompile(`^\$([A-Z][A-Z_]*)\(([^,]+)(?:,([^,]+))?\)$`)
        validEvalAttrMatcherOps = map[string]bool{
                "PLUG":        true,
                "PLUG_COMPAT": true,
                "SLOT":        true,
                "SLOT_COMPAT": true,
        }
)

func matchCompatLabels(v1, v2 any) bool <span class="cov0" title="0">{
        // Note that decoding errors should not happen as interfaces are
        // expected to check the format of the labels before this can even be
        // called.
        return compatibility.CheckCompatibility(v1.(string), v2.(string))
}</span>

func compileEvalOrRefAttrMatcher(cc compileContext, s string) (attrMatcher, error) <span class="cov0" title="0">{
        if len(cc.opts.allowedOperations) == 0 &amp;&amp; len(cc.opts.allowedRefs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot compile %q constraint %q: no $OP() or $REF constraints supported", cc, s)
        }</span>

        // check if constraint matches an allowed $REF constraint since the regexp
        // below only matches $OP(...) strings
        <span class="cov0" title="0">if strutil.ListContains(cc.opts.allowedRefs, s[1:]) </span><span class="cov0" title="0">{
                return refAttrMatcher{ref: s[1:]}, nil
        }</span>

        <span class="cov0" title="0">ops := validEvalAttrMatcher.FindStringSubmatch(s)
        if len(ops) == 0 || !validEvalAttrMatcherOps[ops[1]] || !strutil.ListContains(cc.opts.allowedOperations, ops[1]) </span><span class="cov0" title="0">{
                // attribute doesn't match any allowed $OP() constraint, build err message
                oplst := make([]string, 0, len(cc.opts.allowedOperations)+len(cc.opts.allowedRefs))
                for _, op := range cc.opts.allowedOperations </span><span class="cov0" title="0">{
                        oplst = append(oplst, fmt.Sprintf("$%s()", op))
                }</span>
                <span class="cov0" title="0">for _, ref := range cc.opts.allowedRefs </span><span class="cov0" title="0">{
                        oplst = append(oplst, fmt.Sprintf("$%s", ref))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot compile %q constraint %q: not a valid %s constraint", cc, s, strings.Join(oplst, "/"))</span>
        }
        <span class="cov0" title="0">op := ops[1]
        if ops[3] != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot compile %q constraint %q: $%s() constraint expects 1 argument", cc, s, op)
        }</span>
        <span class="cov0" title="0">matchAttr := reflect.DeepEqual
        if op == "SLOT_COMPAT" || op == "PLUG_COMPAT" </span><span class="cov0" title="0">{
                matchAttr = matchCompatLabels
        }</span>
        <span class="cov0" title="0">return evalAttrMatcher{
                op:        op,
                arg:       ops[2],
                matchAttr: matchAttr,
        }, nil</span>
}

func (matcher evalAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        return flabel == dollarAttrConstraintsFeature
}</span>

func (matcher evalAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        if ctx.helper == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q cannot be matched without context", ctx.attrWord, apath)
        }</span>
        <span class="cov0" title="0">var comp func(string) (any, error)
        switch matcher.op </span>{
        case "SLOT":<span class="cov0" title="0">
                comp = ctx.helper.SlotAttr</span>
        case "PLUG":<span class="cov0" title="0">
                comp = ctx.helper.PlugAttr</span>
        case "SLOT_COMPAT":<span class="cov0" title="0">
                if !ctx.helper.CompatLabelsEnabled() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s %q constraint $%s(%s) not evaluated: compatibility labels are disabled", ctx.attrWord, apath, matcher.op, matcher.arg)
                }</span>
                <span class="cov0" title="0">comp = ctx.helper.SlotAttr</span>
        case "PLUG_COMPAT":<span class="cov0" title="0">
                if !ctx.helper.CompatLabelsEnabled() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s %q constraint $%s(%s) not evaluated: compatibility labels are disabled", ctx.attrWord, apath, matcher.op, matcher.arg)
                }</span>
                <span class="cov0" title="0">comp = ctx.helper.PlugAttr</span>
        }
        <span class="cov0" title="0">v1, err := comp(matcher.arg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q constraint $%s(%s) cannot be evaluated: %v", ctx.attrWord, apath, matcher.op, matcher.arg, err)
        }</span>
        <span class="cov0" title="0">if !matcher.matchAttr(v, v1) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q does not match $%s(%s): %v != %v", ctx.attrWord, apath, matcher.op, matcher.arg, v, v1)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type refAttrMatcher struct {
        // supports $PLUG_PUBLISHER_ID and $SLOT_PUBLISHER_ID
        ref string
}

func (m refAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        return flabel == publisherIDConstraintsFeature
}</span>

func (m refAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        if ctx.helper == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q cannot be matched without context", ctx.attrWord, apath)
        }</span>

        <span class="cov0" title="0">var getRef func() string
        switch m.ref </span>{
        case "PLUG_PUBLISHER_ID":<span class="cov0" title="0">
                getRef = ctx.helper.PlugPublisherID</span>
        case "SLOT_PUBLISHER_ID":<span class="cov0" title="0">
                getRef = ctx.helper.SlotPublisherID</span>
        }

        <span class="cov0" title="0">attrVal, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q is not expected string type: %T", ctx.attrWord, apath, v)
        }</span>

        <span class="cov0" title="0">refVal := getRef()
        if attrVal != refVal </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q does not match $%s: %v != %v", ctx.attrWord, apath, m.ref, attrVal, refVal)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type regexpAttrMatcher struct {
        *regexp.Regexp
}

func compileRegexpAttrMatcher(cc compileContext, s string) (attrMatcher, error) <span class="cov0" title="0">{
        rx, err := regexp.Compile("^(" + s + ")$")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot compile %q constraint %q: %v", cc, s, err)
        }</span>
        <span class="cov0" title="0">return regexpAttrMatcher{rx}, nil</span>
}

func (matcher regexpAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        return false
}</span>

func (matcher regexpAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        var s string
        switch x := v.(type) </span>{
        case string:<span class="cov0" title="0">
                s = x</span>
        case bool:<span class="cov0" title="0">
                s = strconv.FormatBool(x)</span>
        case int64:<span class="cov0" title="0">
                s = strconv.FormatInt(x, 10)</span>
        case []any:<span class="cov0" title="0">
                return matchList(apath, matcher, x, ctx)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("%s %q must be a scalar or list", ctx.attrWord, apath)</span>
        }
        <span class="cov0" title="0">if !matcher.Regexp.MatchString(s) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %q value %q does not match %v", ctx.attrWord, apath, s, matcher.Regexp)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

type altAttrMatcher struct {
        alts []attrMatcher
}

func compileAltAttrMatcher(cc compileContext, l []any) (attrMatcher, error) <span class="cov0" title="0">{
        alts := make([]attrMatcher, len(l))
        for i, constraint := range l </span><span class="cov0" title="0">{
                matcher1, err := compileAttrMatcher(cc.alt(i), constraint)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">alts[i] = matcher1</span>
        }
        <span class="cov0" title="0">return altAttrMatcher{alts}, nil</span>

}

func (matcher altAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        if flabel == altAttrMatcherFeature </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, alt := range matcher.alts </span><span class="cov0" title="0">{
                if alt.feature(flabel) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (matcher altAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        // if the value is a list apply the alternative matcher to each element
        // like we do for other matchers
        switch x := v.(type) </span>{
        case []any:<span class="cov0" title="0">
                return matchList(apath, matcher, x, ctx)</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">var firstErr error
        for _, alt := range matcher.alts </span><span class="cov0" title="0">{
                err := alt.match(apath, v, ctx)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = err
                }</span>
        }
        <span class="cov0" title="0">apathDescr := ""
        if apath != "" </span><span class="cov0" title="0">{
                apathDescr = fmt.Sprintf(" for %s %q", ctx.attrWord, apath)
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("no alternative%s matches: %v", apathDescr, firstErr)</span>
}

// DeviceScopeConstraint specifies a constraint based on which brand
// store, brand or model the device belongs to.
type DeviceScopeConstraint struct {
        Store []string
        Brand []string
        // Model is a list of precise "&lt;brand&gt;/&lt;model&gt;" constraints
        Model []string
}

var (
        validStoreID         = regexp.MustCompile("^[-A-Z0-9a-z_]+$")
        validBrandSlashModel = regexp.MustCompile("^(" +
                strings.Trim(validAccountID.String(), "^$") +
                ")/(" +
                strings.Trim(validModel.String(), "^$") +
                ")$")
        deviceScopeConstraints = map[string]*regexp.Regexp{
                "on-store": validStoreID,
                "on-brand": validAccountID,
                // on-model constraints are of the form list of
                // &lt;brand&gt;/&lt;model&gt; strings where &lt;brand&gt; are account
                // IDs as they appear in the respective model assertion
                "on-model": validBrandSlashModel,
        }
)

func detectDeviceScopeConstraint(cMap map[string]any) bool <span class="cov0" title="0">{
        // for consistency and simplicity we support all of on-store,
        // on-brand, and on-model to appear together. The interpretation
        // layer will AND them as usual
        for field := range deviceScopeConstraints </span><span class="cov0" title="0">{
                if cMap[field] != nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// compileDeviceScopeConstraint compiles a DeviceScopeConstraint out of cMap,
// it returns nil and no error if there are no on-store/on-brand/on-model
// constraints in cMap
func compileDeviceScopeConstraint(cMap map[string]any, context string) (constr *DeviceScopeConstraint, err error) <span class="cov0" title="0">{
        if !detectDeviceScopeConstraint(cMap) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        // initial map size of 2: we expect usual cases to have just one of the
        // constraints or rarely 2
        <span class="cov0" title="0">deviceConstr := make(map[string][]string, 2)
        for field, validRegexp := range deviceScopeConstraints </span><span class="cov0" title="0">{
                vals, err := checkStringListInMap(cMap, field, fmt.Sprintf("%s in %s", field, context), validRegexp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">deviceConstr[field] = vals</span>
        }

        <span class="cov0" title="0">return &amp;DeviceScopeConstraint{
                Store: deviceConstr["on-store"],
                Brand: deviceConstr["on-brand"],
                Model: deviceConstr["on-model"],
        }, nil</span>
}

type DeviceScopeConstraintCheckOptions struct {
        UseFriendlyStores bool
}

// Check tests whether the model and the optional store match the constraints.
func (c *DeviceScopeConstraint) Check(model *Model, store *Store, opts *DeviceScopeConstraintCheckOptions) error <span class="cov0" title="0">{
        if model == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot match on-store/on-brand/on-model without model")
        }</span>
        <span class="cov0" title="0">if store != nil &amp;&amp; store.Store() != model.Store() </span><span class="cov0" title="0">{
                return fmt.Errorf("store assertion and model store must match")
        }</span>
        <span class="cov0" title="0">if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;DeviceScopeConstraintCheckOptions{}
        }</span>
        <span class="cov0" title="0">if len(c.Store) != 0 </span><span class="cov0" title="0">{
                if !strutil.ListContains(c.Store, model.Store()) </span><span class="cov0" title="0">{
                        mismatch := true
                        if store != nil &amp;&amp; opts.UseFriendlyStores </span><span class="cov0" title="0">{
                                for _, sto := range c.Store </span><span class="cov0" title="0">{
                                        if strutil.ListContains(store.FriendlyStores(), sto) </span><span class="cov0" title="0">{
                                                mismatch = false
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if mismatch </span><span class="cov0" title="0">{
                                return fmt.Errorf("on-store mismatch")
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(c.Brand) != 0 </span><span class="cov0" title="0">{
                if !strutil.ListContains(c.Brand, model.BrandID()) </span><span class="cov0" title="0">{
                        return fmt.Errorf("on-brand mismatch")
                }</span>
        }
        <span class="cov0" title="0">if len(c.Model) != 0 </span><span class="cov0" title="0">{
                brandModel := fmt.Sprintf("%s/%s", model.BrandID(), model.Model())
                if !strutil.ListContains(c.Model, brandModel) </span><span class="cov0" title="0">{
                        return fmt.Errorf("on-model mismatch")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "crypto"
        "crypto/rand"
        "crypto/rsa"

        // be explicit about supporting SHA256
        _ "crypto/sha256"

        // be explicit about needing SHA512
        _ "crypto/sha512"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "time"

        "golang.org/x/crypto/openpgp/packet"
        "golang.org/x/crypto/sha3"
)

const (
        maxEncodeLineLength = 76
        v1                  = 0x1
)

var (
        v1Header         = []byte{v1}
        v1FixedTimestamp = time.Date(2016, time.January, 1, 0, 0, 0, 0, time.UTC)
)

func encodeV1(data []byte) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        buf.Grow(base64.StdEncoding.EncodedLen(len(data) + 1))
        enc := base64.NewEncoder(base64.StdEncoding, buf)
        enc.Write(v1Header)
        enc.Write(data)
        enc.Close()
        flat := buf.Bytes()
        flatSize := len(flat)

        buf = new(bytes.Buffer)
        buf.Grow(flatSize + flatSize/maxEncodeLineLength + 1)
        off := 0
        for </span><span class="cov0" title="0">{
                endOff := off + maxEncodeLineLength
                if endOff &gt; flatSize </span><span class="cov0" title="0">{
                        endOff = flatSize
                }</span>
                <span class="cov0" title="0">buf.Write(flat[off:endOff])
                off = endOff
                if off &gt;= flatSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">buf.WriteByte('\n')</span>
        }

        <span class="cov0" title="0">return buf.Bytes()</span>
}

type keyEncoder interface {
        keyEncode(w io.Writer) error
}

func encodeKey(key keyEncoder, kind string) ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        err := key.keyEncode(buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot encode %s: %v", kind, err)
        }</span>
        <span class="cov0" title="0">return encodeV1(buf.Bytes()), nil</span>
}

type openpgpSigner interface {
        sign(content []byte) (*packet.Signature, error)
}

func signAndEncode(content []byte, privateKey PrivateKey) ([]byte, error) <span class="cov0" title="0">{
        sig, err := RawSignWithKey(content, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return encodeV1(sig), nil</span>
}

// RawSignWithKey signs the given data with the provided [PrivateKey]. The
// serialized signature returned.
//
// This is not intended to sign assertions. Rather, it might be used to
// explicitly sign data with a device key.
func RawSignWithKey(data []byte, pk PrivateKey) ([]byte, error) <span class="cov0" title="0">{
        signer, ok := pk.(openpgpSigner)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key does not support signing: %T", pk)
        }</span>

        <span class="cov0" title="0">sig, err := signer.sign(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf := bytes.NewBuffer(nil)
        err = sig.Serialize(buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// RawVerifyWithKey verifies that the given signature is valid for the provided
// data using the specified [PublicKey].
//
// This is not intended to verify assertions. Rather, it might be used to verify
// data signed with a device key.
func RawVerifyWithKey(data []byte, signature []byte, pk PublicKey) error <span class="cov0" title="0">{
        pkt, err := packet.Read(bytes.NewReader(signature))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot decode signature: %w", err)
        }</span>

        <span class="cov0" title="0">sig, ok := pkt.(*packet.Signature)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected signature, got instead: %T", pkt)
        }</span>

        <span class="cov0" title="0">verifier, ok := pk.(interface {
                verify([]byte, *packet.Signature) error
        })
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("public key does not support verification: %T", pk)
        }</span>

        <span class="cov0" title="0">return verifier.verify(data, sig)</span>
}

func decodeV1(b []byte, kind string) (packet.Packet, error) <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot decode %s: no data", kind)
        }</span>
        <span class="cov0" title="0">buf := make([]byte, base64.StdEncoding.DecodedLen(len(b)))
        n, err := base64.StdEncoding.Decode(buf, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot decode %s: %v", kind, err)
        }</span>
        <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot decode %s: base64 without data", kind)
        }</span>
        <span class="cov0" title="0">buf = buf[:n]
        if buf[0] != v1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported %s format version: %d", kind, buf[0])
        }</span>
        <span class="cov0" title="0">rd := bytes.NewReader(buf[1:])
        pkt, err := packet.Read(rd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot decode %s: %v", kind, err)
        }</span>
        <span class="cov0" title="0">if rd.Len() != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s has spurious trailing data", kind)
        }</span>
        <span class="cov0" title="0">return pkt, nil</span>
}

func decodeSignature(signature []byte) (*packet.Signature, error) <span class="cov0" title="0">{
        pkt, err := decodeV1(signature, "signature")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sig, ok := pkt.(*packet.Signature)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected signature, got instead: %T", pkt)
        }</span>
        <span class="cov0" title="0">return sig, nil</span>
}

// PublicKey is the public part of a cryptographic private/public key pair.
type PublicKey interface {
        // ID returns the id of the key used for lookup.
        ID() string

        // verify verifies signature is valid for content using the key.
        verify(content []byte, sig *packet.Signature) error

        keyEncoder
}

type openpgpPubKey struct {
        pubKey   *packet.PublicKey
        sha3_384 string
}

func (opgPubKey *openpgpPubKey) ID() string <span class="cov0" title="0">{
        return opgPubKey.sha3_384
}</span>

func (opgPubKey *openpgpPubKey) verify(content []byte, sig *packet.Signature) error <span class="cov0" title="0">{
        h := sig.Hash.New()
        h.Write(content)
        return opgPubKey.pubKey.VerifySignature(h, sig)
}</span>

func (opgPubKey openpgpPubKey) keyEncode(w io.Writer) error <span class="cov0" title="0">{
        return opgPubKey.pubKey.Serialize(w)
}</span>

func newOpenPGPPubKey(intPubKey *packet.PublicKey) *openpgpPubKey <span class="cov0" title="0">{
        h := sha3.New384()
        h.Write(v1Header)
        err := intPubKey.Serialize(h)
        if err != nil </span><span class="cov0" title="0">{
                panic("internal error: cannot compute public key sha3-384")</span>
        }
        <span class="cov0" title="0">sha3_384, err := EncodeDigest(crypto.SHA3_384, h.Sum(nil))
        if err != nil </span><span class="cov0" title="0">{
                panic("internal error: cannot compute public key sha3-384")</span>
        }
        <span class="cov0" title="0">return &amp;openpgpPubKey{pubKey: intPubKey, sha3_384: sha3_384}</span>
}

// RSAPublicKey returns a database useable public key out of rsa.PublicKey.
func RSAPublicKey(pubKey *rsa.PublicKey) PublicKey <span class="cov0" title="0">{
        intPubKey := packet.NewRSAPublicKey(v1FixedTimestamp, pubKey)
        return newOpenPGPPubKey(intPubKey)
}</span>

// DecodePublicKey deserializes a public key.
func DecodePublicKey(pubKey []byte) (PublicKey, error) <span class="cov0" title="0">{
        pkt, err := decodeV1(pubKey, "public key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">pubk, ok := pkt.(*packet.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected public key, got instead: %T", pkt)
        }</span>
        <span class="cov0" title="0">rsaPubKey, ok := pubk.PublicKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected RSA public key, got instead: %T", pubk.PublicKey)
        }</span>
        <span class="cov0" title="0">return RSAPublicKey(rsaPubKey), nil</span>
}

// EncodePublicKey serializes a public key, typically for embedding in an assertion.
func EncodePublicKey(pubKey PublicKey) ([]byte, error) <span class="cov0" title="0">{
        return encodeKey(pubKey, "public key")
}</span>

// PrivateKey is a cryptographic private/public key pair.
type PrivateKey interface {
        // PublicKey returns the public part of the pair.
        PublicKey() PublicKey

        keyEncoder
}

type openpgpPrivateKey struct {
        privk *packet.PrivateKey
}

func (opgPrivK openpgpPrivateKey) PublicKey() PublicKey <span class="cov0" title="0">{
        return newOpenPGPPubKey(&amp;opgPrivK.privk.PublicKey)
}</span>

func (opgPrivK openpgpPrivateKey) keyEncode(w io.Writer) error <span class="cov0" title="0">{
        return opgPrivK.privk.Serialize(w)
}</span>

var openpgpConfig = &amp;packet.Config{
        DefaultHash: crypto.SHA512,
}

func (opgPrivK openpgpPrivateKey) sign(content []byte) (*packet.Signature, error) <span class="cov0" title="0">{
        privk := opgPrivK.privk
        sig := new(packet.Signature)
        sig.PubKeyAlgo = privk.PubKeyAlgo
        sig.Hash = openpgpConfig.Hash()
        sig.CreationTime = time.Now()

        h := openpgpConfig.Hash().New()
        h.Write(content)

        err := sig.Sign(h, privk, openpgpConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}

func decodePrivateKey(privKey []byte) (PrivateKey, error) <span class="cov0" title="0">{
        pkt, err := decodeV1(privKey, "private key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">privk, ok := pkt.(*packet.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected private key, got instead: %T", pkt)
        }</span>
        <span class="cov0" title="0">if _, ok := privk.PrivateKey.(*rsa.PrivateKey); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected RSA private key, got instead: %T", privk.PrivateKey)
        }</span>
        <span class="cov0" title="0">return openpgpPrivateKey{privk}, nil</span>
}

// RSAPrivateKey returns a PrivateKey for database use out of a rsa.PrivateKey.
func RSAPrivateKey(privk *rsa.PrivateKey) PrivateKey <span class="cov8" title="1">{
        intPrivk := packet.NewRSAPrivateKey(v1FixedTimestamp, privk)
        return openpgpPrivateKey{intPrivk}
}</span>

// GenerateKey generates a private/public key pair.
func GenerateKey() (PrivateKey, error) <span class="cov0" title="0">{
        priv, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return RSAPrivateKey(priv), nil</span>
}

func encodePrivateKey(privKey PrivateKey) ([]byte, error) <span class="cov0" title="0">{
        return encodeKey(privKey, "private key")
}</span>

// externally held key pairs

type extPGPPrivateKey struct {
        pubKey     PublicKey
        from       string
        externalID string
        bitLen     int
        doSign     func(content []byte) (*packet.Signature, error)
}

func newExtPGPPrivateKey(exportedPubKeyStream io.Reader, from string, sign func(content []byte) (*packet.Signature, error)) (*extPGPPrivateKey, error) <span class="cov0" title="0">{
        var pubKey *packet.PublicKey

        rd := packet.NewReader(exportedPubKeyStream)
        for </span><span class="cov0" title="0">{
                pkt, err := rd.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot read exported public key: %v", err)
                }</span>
                <span class="cov0" title="0">cand, ok := pkt.(*packet.PublicKey)
                if ok </span><span class="cov0" title="0">{
                        if cand.IsSubkey </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if pubKey != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot select exported public key, found many")
                        }</span>
                        <span class="cov0" title="0">pubKey = cand</span>
                }
        }

        <span class="cov0" title="0">if pubKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read exported public key, found none (broken export)")

        }</span>

        <span class="cov0" title="0">rsaPubKey, ok := pubKey.PublicKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a RSA key")
        }</span>

        <span class="cov0" title="0">return &amp;extPGPPrivateKey{
                pubKey:     RSAPublicKey(rsaPubKey),
                from:       from,
                externalID: fmt.Sprintf("%X", pubKey.Fingerprint),
                bitLen:     rsaPubKey.N.BitLen(),
                doSign:     sign,
        }, nil</span>
}

func (expk *extPGPPrivateKey) PublicKey() PublicKey <span class="cov0" title="0">{
        return expk.pubKey
}</span>

func (expk *extPGPPrivateKey) keyEncode(w io.Writer) error <span class="cov0" title="0">{
        return fmt.Errorf("cannot access external private key to encode it")
}</span>

func (expk *extPGPPrivateKey) sign(content []byte) (*packet.Signature, error) <span class="cov0" title="0">{
        if expk.bitLen &lt; 4096 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("signing needs at least a 4096 bits key, got %d", expk.bitLen)
        }</span>

        <span class="cov0" title="0">sig, err := expk.doSign(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">badSig := fmt.Sprintf("bad %s produced signature: ", expk.from)

        if sig.Hash != crypto.SHA512 </span><span class="cov0" title="0">{
                return nil, errors.New(badSig + "expected SHA512 digest")
        }</span>

        <span class="cov0" title="0">err = expk.pubKey.verify(content, sig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%sit does not verify: %v", badSig, err)
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

// Package asserts implements snappy assertions and a database
// abstraction for managing and holding them.
package asserts

import (
        "errors"
        "fmt"
        "regexp"
        "time"
)

// NotFoundError is returned when an assertion can not be found.
type NotFoundError struct {
        Type    *AssertionType
        Headers map[string]string
}

func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        pk, err := PrimaryKeyFromHeaders(e.Type, e.Headers)
        if err != nil || len(e.Headers) != len(pk) </span><span class="cov0" title="0">{
                // TODO: worth conveying more information?
                return fmt.Sprintf("%s assertion not found", e.Type.Name)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%v not found", &amp;Ref{Type: e.Type, PrimaryKey: pk})</span>
}

func (e *NotFoundError) Is(err error) bool <span class="cov0" title="0">{
        _, ok := err.(*NotFoundError)
        return ok
}</span>

// A Backstore stores assertions. It can store and retrieve assertions
// by type under unique primary key headers (whose names are available
// from assertType.PrimaryKey). Plus it supports searching by headers.
// Lookups can be limited to a maximum allowed format.
type Backstore interface {
        // Put stores an assertion.
        // It is responsible for checking that assert is newer than a
        // previously stored revision with the same primary key headers.
        Put(assertType *AssertionType, assert Assertion) error
        // Get returns the assertion with the given unique key for its
        // primary key headers.
        // A suffix of optional primary keys can be left out from key
        // in which case their default values are implied.
        // If the assertion is not present it returns a
        // NotFoundError, usually with omitted Headers.
        Get(assertType *AssertionType, key []string, maxFormat int) (Assertion, error)
        // Search returns assertions matching the given headers.
        // It invokes foundCb for each found assertion.
        Search(assertType *AssertionType, headers map[string]string, foundCb func(Assertion), maxFormat int) error
        // SequenceMemberAfter returns for a sequence-forming assertType the
        // first assertion in the sequence under the given sequenceKey
        // with sequence number larger than after. If after==-1 it
        // returns the assertion with largest sequence number. If none
        // exists it returns a NotFoundError, usually with omitted
        // Headers. If assertType is not sequence-forming it can
        // panic.
        SequenceMemberAfter(assertType *AssertionType, sequenceKey []string, after, maxFormat int) (SequenceMember, error)
}

type nullBackstore struct{}

func (nbs nullBackstore) Put(t *AssertionType, a Assertion) error <span class="cov0" title="0">{
        return fmt.Errorf("cannot store assertions without setting a proper assertion backstore implementation")
}</span>

func (nbs nullBackstore) Get(t *AssertionType, k []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        return nil, &amp;NotFoundError{Type: t}
}</span>

func (nbs nullBackstore) Search(t *AssertionType, h map[string]string, f func(Assertion), maxFormat int) error <span class="cov0" title="0">{
        return nil
}</span>

func (nbs nullBackstore) SequenceMemberAfter(t *AssertionType, kp []string, after, maxFormat int) (SequenceMember, error) <span class="cov0" title="0">{
        return nil, &amp;NotFoundError{Type: t}
}</span>

// keyNotFoundError is returned when the key with a given ID cannot be found.
type keyNotFoundError struct {
        msg string
}

func (e *keyNotFoundError) Error() string <span class="cov0" title="0">{ return e.msg }</span>

func (e *keyNotFoundError) Is(target error) bool <span class="cov0" title="0">{
        _, ok := target.(*keyNotFoundError)
        return ok
}</span>

// IsKeyNotFound returns true when the error indicates that a given key was not
// found.
func IsKeyNotFound(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, &amp;keyNotFoundError{})
}</span>

// A KeypairManager is a manager and backstore for private/public key pairs.
type KeypairManager interface {
        // Put stores the given private/public key pair,
        // making sure it can be later retrieved by its unique key id with Get.
        // Trying to store a key with an already present key id should
        // result in an error.
        Put(privKey PrivateKey) error
        // Get returns the private/public key pair with the given key id. The
        // error can be tested with IsKeyNotFound to check whether the given key
        // was not found, or other error occurred.
        Get(keyID string) (PrivateKey, error)
        // Delete deletes the private/public key pair with the given key id.
        Delete(keyID string) error
}

// DatabaseConfig for an assertion database.
type DatabaseConfig struct {
        // trusted set of assertions (account and account-key supported),
        // used to establish root keys and trusted authorities
        Trusted []Assertion
        // predefined assertions but that do not establish foundational trust
        OtherPredefined []Assertion
        // backstore for assertions, left unset storing assertions will error
        Backstore Backstore
        // manager/backstore for keypairs, defaults to in-memory implementation
        KeypairManager KeypairManager
        // assertion checkers used by Database.Check, left unset DefaultCheckers will be used which is recommended
        Checkers []Checker
}

// RevisionError indicates a revision improperly used for an operation.
type RevisionError struct {
        Used, Current int
}

func (e *RevisionError) Error() string <span class="cov0" title="0">{
        if e.Used &lt; 0 || e.Current &lt; 0 </span><span class="cov0" title="0">{
                // TODO: message may need tweaking once there's a use.
                return "assertion revision is unknown"
        }</span>
        <span class="cov0" title="0">if e.Used == e.Current </span><span class="cov0" title="0">{
                return fmt.Sprintf("revision %d is already the current revision", e.Used)
        }</span>
        <span class="cov0" title="0">if e.Used &lt; e.Current </span><span class="cov0" title="0">{
                return fmt.Sprintf("revision %d is older than current revision %d", e.Used, e.Current)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("revision %d is more recent than current revision %d", e.Used, e.Current)</span>
}

// UnsupportedFormatError indicates an assertion with a format iteration not yet supported by the present version of asserts.
type UnsupportedFormatError struct {
        Ref    *Ref
        Format int
        // Update marks there was already a current revision of the assertion and it has been kept.
        Update bool
}

func (e *UnsupportedFormatError) Error() string <span class="cov0" title="0">{
        postfx := ""
        if e.Update </span><span class="cov0" title="0">{
                postfx = " (current not updated)"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("proposed %q assertion has format %d but %d is latest supported%s", e.Ref.Type.Name, e.Format, e.Ref.Type.MaxSupportedFormat(), postfx)</span>
}

// IsUnaccceptedUpdate returns whether the error indicates that an
// assertion revision was already present and has been kept because
// the update was not accepted.
func IsUnaccceptedUpdate(err error) bool <span class="cov0" title="0">{
        switch x := err.(type) </span>{
        case *UnsupportedFormatError:<span class="cov0" title="0">
                return x.Update</span>
        case *RevisionError:<span class="cov0" title="0">
                return x.Used &lt;= x.Current</span>
        }
        <span class="cov0" title="0">return false</span>
}

// A RODatabase exposes read-only access to an assertion database.
type RODatabase interface {
        // IsTrustedAccount returns whether the account is part of the trusted set.
        IsTrustedAccount(accountID string) bool
        // WithStackedBackstore returns a database view that layers the provided
        // backstore on top of the current one while preserving read-only access to
        // existing assertions.
        WithStackedBackstore(backstore Backstore) *Database
        // Find an assertion based on arbitrary headers.
        // Provided headers must contain the primary key for the assertion type.
        // Optional primary key headers can be omitted in which case
        // their default values will be used.
        // It returns a NotFoundError if the assertion cannot be found.
        Find(assertionType *AssertionType, headers map[string]string) (Assertion, error)
        // FindPredefined finds an assertion in the predefined sets
        // (trusted or not) based on arbitrary headers.  Provided
        // headers must contain the primary key for the assertion
        // type.
        // Optional primary key headers can be omitted in which case
        // their default values will be used.
        // It returns a NotFoundError if the assertion cannot
        // be found.
        FindPredefined(assertionType *AssertionType, headers map[string]string) (Assertion, error)
        // FindTrusted finds an assertion in the trusted set based on
        // arbitrary headers.  Provided headers must contain the
        // primary key for the assertion type.
        // Optional primary key headers can be omitted in which case
        // their default values will be used.
        // It returns a NotFoundError if the assertion cannot be
        // found.
        FindTrusted(assertionType *AssertionType, headers map[string]string) (Assertion, error)
        // FindMany finds assertions based on arbitrary headers.
        // It returns a NotFoundError if no assertion can be found.
        FindMany(assertionType *AssertionType, headers map[string]string) ([]Assertion, error)
        // FindManyPredefined finds assertions in the predefined sets
        // (trusted or not) based on arbitrary headers.  It returns a
        // NotFoundError if no assertion can be found.
        FindManyPredefined(assertionType *AssertionType, headers map[string]string) ([]Assertion, error)
        // FindSequence finds an assertion for the given headers and after for
        // a sequence-forming type.
        // The provided headers must contain a sequence key, i.e. a prefix of
        // the primary key for the assertion type except for the sequence
        // number header.
        // The assertion is the first in the sequence under the sequence key
        // with sequence number &gt; after.
        // If after is -1 it returns instead the assertion with the largest
        // sequence number.
        // It will constraint itself to assertions with format &lt;= maxFormat
        // unless maxFormat is -1.
        // It returns a NotFoundError if the assertion cannot be found.
        FindSequence(assertType *AssertionType, sequenceHeaders map[string]string, after, maxFormat int) (SequenceMember, error)
        // Check tests whether the assertion is properly signed and consistent with all the stored knowledge.
        Check(assert Assertion) error
}

// A Checker defines a check on an assertion considering aspects such as
// the signing key, and consistency with other
// assertions in the database.
type Checker func(assert Assertion, signingKey *AccountKey, roDB RODatabase, checkTimeEarliest, checkTimeLatest time.Time) error

// Database holds assertions and can be used to sign or check
// further assertions.
type Database struct {
        bs         Backstore
        keypairMgr KeypairManager

        trusted    Backstore
        predefined Backstore
        // all backstores to consider for find
        backstores []Backstore
        // backstores of dbs this was built on by stacking
        stackedOn []Backstore

        checkers     []Checker
        earliestTime time.Time
}

// OpenDatabase opens the assertion database based on the configuration.
func OpenDatabase(cfg *DatabaseConfig) (*Database, error) <span class="cov0" title="0">{
        bs := cfg.Backstore
        keypairMgr := cfg.KeypairManager

        if bs == nil </span><span class="cov0" title="0">{
                bs = nullBackstore{}
        }</span>
        <span class="cov0" title="0">if keypairMgr == nil </span><span class="cov0" title="0">{
                keypairMgr = NewMemoryKeypairManager()
        }</span>

        <span class="cov0" title="0">trustedBackstore := NewMemoryBackstore()

        for _, a := range cfg.Trusted </span><span class="cov0" title="0">{
                switch accepted := a.(type) </span>{
                case *AccountKey:<span class="cov0" title="0">
                        accKey := accepted
                        err := trustedBackstore.Put(AccountKeyType, accKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot predefine trusted account key %q for %q: %v", accKey.PublicKeyID(), accKey.AccountID(), err)
                        }</span>

                case *Account:<span class="cov0" title="0">
                        acct := accepted
                        err := trustedBackstore.Put(AccountType, acct)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot predefine trusted account %q: %v", acct.DisplayName(), err)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("cannot predefine trusted assertions that are not account-key or account: %s", a.Type().Name)</span>
                }
        }

        <span class="cov0" title="0">otherPredefinedBackstore := NewMemoryBackstore()

        for _, a := range cfg.OtherPredefined </span><span class="cov0" title="0">{
                err := otherPredefinedBackstore.Put(a.Type(), a)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot predefine assertion %v: %v", a.Ref(), err)
                }</span>
        }

        <span class="cov0" title="0">checkers := cfg.Checkers
        if len(checkers) == 0 </span><span class="cov0" title="0">{
                checkers = DefaultCheckers
        }</span>
        <span class="cov0" title="0">dbCheckers := make([]Checker, len(checkers))
        copy(dbCheckers, checkers)

        return &amp;Database{
                bs:         bs,
                keypairMgr: keypairMgr,
                trusted:    trustedBackstore,
                predefined: otherPredefinedBackstore,
                // order here is relevant, Find* precedence and
                // findAccountKey depend on it, trusted should win over the
                // general backstore!
                backstores: []Backstore{trustedBackstore, otherPredefinedBackstore, bs},
                checkers:   dbCheckers,
        }, nil</span>
}

// WithStackedBackstore returns a new database that adds to the given backstore
// only but finds in backstore and the base database backstores and
// cross-checks against all of them.
// This is useful to cross-check a set of assertions without adding
// them to the database.
func (db *Database) WithStackedBackstore(backstore Backstore) *Database <span class="cov0" title="0">{
        // original bs goes in front of stacked-on ones
        stackedOn := []Backstore{db.bs}
        stackedOn = append(stackedOn, db.stackedOn...)
        // find order: trusted, predefined, new backstore, stacked-on ones
        backstores := []Backstore{db.trusted, db.predefined}
        backstores = append(backstores, backstore)
        backstores = append(backstores, stackedOn...)
        return &amp;Database{
                bs:         backstore,
                keypairMgr: db.keypairMgr,
                trusted:    db.trusted,
                predefined: db.predefined,
                backstores: backstores,
                stackedOn:  stackedOn,
                checkers:   db.checkers,
        }
}</span>

// ImportKey stores the given private/public key pair.
func (db *Database) ImportKey(privKey PrivateKey) error <span class="cov0" title="0">{
        return db.keypairMgr.Put(privKey)
}</span>

var (
        // for validity checking of base64 hash strings
        base64HashLike = regexp.MustCompile("^[[:alnum:]_-]*$")
)

func (db *Database) safeGetPrivateKey(keyID string) (PrivateKey, error) <span class="cov0" title="0">{
        if keyID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key id is empty")
        }</span>
        <span class="cov0" title="0">if !base64HashLike.MatchString(keyID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key id contains unexpected chars: %q", keyID)
        }</span>
        <span class="cov0" title="0">return db.keypairMgr.Get(keyID)</span>
}

// PublicKey returns the public key part of the key pair that has the given key id.
func (db *Database) PublicKey(keyID string) (PublicKey, error) <span class="cov0" title="0">{
        privKey, err := db.safeGetPrivateKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return privKey.PublicKey(), nil</span>
}

// Sign assembles an assertion with the provided information and signs it
// with the private key from `headers["authority-id"]` that has the provided key id.
func (db *Database) Sign(assertType *AssertionType, headers map[string]any, body []byte, keyID string) (Assertion, error) <span class="cov0" title="0">{
        privKey, err := db.safeGetPrivateKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return assembleAndSign(assertType, headers, body, privKey)</span>
}

// findAccountKey finds an AccountKey exactly with account id and key id.
func (db *Database) findAccountKey(authorityID, keyID string) (*AccountKey, error) <span class="cov0" title="0">{
        key := []string{keyID}
        // consider trusted account keys then disk stored account keys
        for _, bs := range db.backstores </span><span class="cov0" title="0">{
                a, err := bs.Get(AccountKeyType, key, AccountKeyType.MaxSupportedFormat())
                if err == nil </span><span class="cov0" title="0">{
                        hit := a.(*AccountKey)
                        if hit.AccountID() != authorityID </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("found public key %q from %q but expected it from: %s", keyID, hit.AccountID(), authorityID)
                        }</span>
                        <span class="cov0" title="0">return hit, nil</span>
                }
                <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nil, &amp;NotFoundError{Type: AccountKeyType}</span>
}

// IsTrustedAccount returns whether the account is part of the trusted set.
func (db *Database) IsTrustedAccount(accountID string) bool <span class="cov0" title="0">{
        if accountID == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, err := db.trusted.Get(AccountType, []string{accountID}, AccountType.MaxSupportedFormat())
        return err == nil</span>
}

var timeNow = time.Now

// SetEarliestTime affects how key expiration is checked.
// Instead of considering current system time, only assume that current time
// is &gt;= earliest. If earliest is zero reset to considering current system time.
func (db *Database) SetEarliestTime(earliest time.Time) <span class="cov0" title="0">{
        db.earliestTime = earliest
}</span>

// Check tests whether the assertion is properly signed and consistent with all the stored knowledge.
func (db *Database) Check(assert Assertion) error <span class="cov0" title="0">{
        if !assert.SupportedFormat() </span><span class="cov0" title="0">{
                return &amp;UnsupportedFormatError{Ref: assert.Ref(), Format: assert.Format()}
        }</span>

        <span class="cov0" title="0">typ := assert.Type()
        // assume current time is &gt;= earliestTime and &lt;= latestTime
        earliestTime := db.earliestTime
        var latestTime time.Time
        if earliestTime.IsZero() </span><span class="cov0" title="0">{
                // use the current system time by setting both to it
                earliestTime = timeNow()
                latestTime = earliestTime
        }</span>

        <span class="cov0" title="0">var accKey *AccountKey
        var err error
        if typ.flags&amp;noAuthority == 0 </span><span class="cov0" title="0">{
                // TODO: later may need to consider type of assert to find candidate keys
                accKey, err = db.findAccountKey(assert.AuthorityID(), assert.SignKeyID())
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return fmt.Errorf("no matching public key %q for signature by %q", assert.SignKeyID(), assert.AuthorityID())
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error finding matching public key for signature: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if assert.AuthorityID() != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: %q assertion cannot have authority-id set", typ.Name)
                }</span>
        }

        <span class="cov0" title="0">for _, checker := range db.checkers </span><span class="cov0" title="0">{
                err := checker(assert, accKey, db, earliestTime, latestTime)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Add persists the assertion after ensuring it is properly signed and consistent with all the stored knowledge.
// It will return an error when trying to add an older revision of the assertion than the one currently stored.
func (db *Database) Add(assert Assertion) error <span class="cov0" title="0">{
        ref := assert.Ref()

        if len(ref.PrimaryKey) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: assertion type %q has no primary key", ref.Type.Name)
        }</span>

        <span class="cov0" title="0">err := db.Check(assert)
        if err != nil </span><span class="cov0" title="0">{
                if ufe, ok := err.(*UnsupportedFormatError); ok </span><span class="cov0" title="0">{
                        _, err := ref.Resolve(db.Find)
                        if err != nil &amp;&amp; !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return &amp;UnsupportedFormatError{Ref: ufe.Ref, Format: ufe.Format, Update: err == nil}</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">for i, keyVal := range ref.PrimaryKey </span><span class="cov0" title="0">{
                if keyVal == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing or non-string primary key header: %v", ref.Type.PrimaryKey[i])
                }</span>
        }

        // assuming trusted account keys/assertions will be managed
        // through the os snap this seems the safest policy until we
        // know more/better
        <span class="cov0" title="0">_, err = db.trusted.Get(ref.Type, ref.PrimaryKey, ref.Type.MaxSupportedFormat())
        if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot add %q assertion with primary key clashing with a trusted assertion: %v", ref.Type.Name, ref.PrimaryKey)
        }</span>

        <span class="cov0" title="0">_, err = db.predefined.Get(ref.Type, ref.PrimaryKey, ref.Type.MaxSupportedFormat())
        if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot add %q assertion with primary key clashing with a predefined assertion: %v", ref.Type.Name, ref.PrimaryKey)
        }</span>

        // this is non empty only in the stacked case
        <span class="cov0" title="0">if len(db.stackedOn) != 0 </span><span class="cov0" title="0">{
                headers, err := HeadersFromPrimaryKey(ref.Type, ref.PrimaryKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: HeadersFromPrimaryKey for %q failed on prechecked data: %s", ref.Type.Name, ref.PrimaryKey)
                }</span>
                <span class="cov0" title="0">cur, err := find(db.stackedOn, ref.Type, headers, -1)
                if err == nil </span><span class="cov0" title="0">{
                        curRev := cur.Revision()
                        rev := assert.Revision()
                        if curRev &gt;= rev </span><span class="cov0" title="0">{
                                return &amp;RevisionError{Current: curRev, Used: rev}
                        }</span>
                } else<span class="cov0" title="0"> if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return db.bs.Put(ref.Type, assert)</span>
}

func searchMatch(assert Assertion, expectedHeaders map[string]string) bool <span class="cov0" title="0">{
        // check non-primary-key headers as well
        for expectedKey, expectedValue := range expectedHeaders </span><span class="cov0" title="0">{
                if assert.Header(expectedKey) != expectedValue </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func find(backstores []Backstore, assertionType *AssertionType, headers map[string]string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        err := checkAssertType(assertionType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">maxSupp := assertionType.MaxSupportedFormat()
        if maxFormat == -1 </span><span class="cov0" title="0">{
                maxFormat = maxSupp
        }</span> else<span class="cov0" title="0"> {
                if maxFormat &gt; maxSupp </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find %q assertions for format %d higher than supported format %d", assertionType.Name, maxFormat, maxSupp)
                }</span>
        }

        <span class="cov0" title="0">keyValues, err := PrimaryKeyFromHeaders(assertionType, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var assert Assertion
        for _, bs := range backstores </span><span class="cov0" title="0">{
                a, err := bs.Get(assertionType, keyValues, maxFormat)
                if err == nil </span><span class="cov0" title="0">{
                        assert = a
                        break</span>
                }
                <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if assert == nil || !searchMatch(assert, headers) </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{Type: assertionType, Headers: headers}
        }</span>

        <span class="cov0" title="0">return assert, nil</span>
}

// Find an assertion based on arbitrary headers.
// Provided headers must contain the primary key for the assertion type.
// Optional primary key headers can be omitted in which case
// their default values will be used.
// It returns a NotFoundError if the assertion cannot be found.
func (db *Database) Find(assertionType *AssertionType, headers map[string]string) (Assertion, error) <span class="cov0" title="0">{
        return find(db.backstores, assertionType, headers, -1)
}</span>

// FindMaxFormat finds an assertion like Find but such that its
// format is &lt;= maxFormat by passing maxFormat along to the backend.
// It returns a NotFoundError if such an assertion cannot be found.
func (db *Database) FindMaxFormat(assertionType *AssertionType, headers map[string]string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        return find(db.backstores, assertionType, headers, maxFormat)
}</span>

// FindPredefined finds an assertion in the predefined sets (trusted
// or not) based on arbitrary headers.  Provided headers must contain
// the primary key for the assertion type.
// Optional primary key headers can be omitted in which case
// their default values will be used.
// It returns a NotFoundError if the assertion cannot be found.
func (db *Database) FindPredefined(assertionType *AssertionType, headers map[string]string) (Assertion, error) <span class="cov0" title="0">{
        return find([]Backstore{db.trusted, db.predefined}, assertionType, headers, -1)
}</span>

// FindTrusted finds an assertion in the trusted set based on arbitrary headers.
// Provided headers must contain the primary key for the assertion type.
// Optional primary key headers can be omitted in which case
// their default values will be used.
// It returns a NotFoundError if the assertion cannot be found.
func (db *Database) FindTrusted(assertionType *AssertionType, headers map[string]string) (Assertion, error) <span class="cov0" title="0">{
        return find([]Backstore{db.trusted}, assertionType, headers, -1)
}</span>

func (db *Database) findMany(backstores []Backstore, assertionType *AssertionType, headers map[string]string) ([]Assertion, error) <span class="cov0" title="0">{
        err := checkAssertType(assertionType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">res := []Assertion{}

        foundCb := func(assert Assertion) </span><span class="cov0" title="0">{
                res = append(res, assert)
        }</span>

        // TODO: Find variant taking this
        <span class="cov0" title="0">maxFormat := assertionType.MaxSupportedFormat()
        for _, bs := range backstores </span><span class="cov0" title="0">{
                err = bs.Search(assertionType, headers, foundCb, maxFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if len(res) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{Type: assertionType, Headers: headers}
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

// FindMany finds assertions based on arbitrary headers.
// It returns a NotFoundError if no assertion can be found.
func (db *Database) FindMany(assertionType *AssertionType, headers map[string]string) ([]Assertion, error) <span class="cov0" title="0">{
        return db.findMany(db.backstores, assertionType, headers)
}</span>

// FindManyPrefined finds assertions in the predefined sets (trusted
// or not) based on arbitrary headers.  It returns a NotFoundError if
// no assertion can be found.
func (db *Database) FindManyPredefined(assertionType *AssertionType, headers map[string]string) ([]Assertion, error) <span class="cov0" title="0">{
        return db.findMany([]Backstore{db.trusted, db.predefined}, assertionType, headers)
}</span>

// FindSequence finds an assertion for the given headers and after for
// a sequence-forming type.
// The provided headers must contain a sequence key, i.e. a prefix of
// the primary key for the assertion type except for the sequence
// number header.
// The assertion is the first in the sequence under the sequence key
// with sequence number &gt; after.
// If after is -1 it returns instead the assertion with the largest
// sequence number.
// It will constraint itself to assertions with format &lt;= maxFormat
// unless maxFormat is -1.
// It returns a NotFoundError if the assertion cannot be found.
func (db *Database) FindSequence(assertType *AssertionType, sequenceHeaders map[string]string, after, maxFormat int) (SequenceMember, error) <span class="cov0" title="0">{
        err := checkAssertType(assertType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !assertType.SequenceForming() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot use FindSequence with non sequence-forming assertion type %q", assertType.Name)
        }</span>
        <span class="cov0" title="0">maxSupp := assertType.MaxSupportedFormat()
        if maxFormat == -1 </span><span class="cov0" title="0">{
                maxFormat = maxSupp
        }</span> else<span class="cov0" title="0"> {
                if maxFormat &gt; maxSupp </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find %q assertions for format %d higher than supported format %d", assertType.Name, maxFormat, maxSupp)
                }</span>
        }

        // form the sequence key using all keys but the last one which
        // is the sequence number
        <span class="cov0" title="0">seqKey, err := keysFromHeaders(assertType.PrimaryKey[:len(assertType.PrimaryKey)-1], sequenceHeaders, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // find the better result across backstores' results
        <span class="cov0" title="0">better := func(cur, a SequenceMember) SequenceMember </span><span class="cov0" title="0">{
                if cur == nil </span><span class="cov0" title="0">{
                        return a
                }</span>
                <span class="cov0" title="0">curSeq := cur.Sequence()
                aSeq := a.Sequence()
                if after == -1 </span><span class="cov0" title="0">{
                        if aSeq &gt; curSeq </span><span class="cov0" title="0">{
                                return a
                        }</span>
                } else<span class="cov0" title="0"> {
                        if aSeq &lt; curSeq </span><span class="cov0" title="0">{
                                return a
                        }</span>
                }
                <span class="cov0" title="0">return cur</span>
        }

        <span class="cov0" title="0">var assert SequenceMember
        for _, bs := range db.backstores </span><span class="cov0" title="0">{
                a, err := bs.SequenceMemberAfter(assertType, seqKey, after, maxFormat)
                if err == nil </span><span class="cov0" title="0">{
                        assert = better(assert, a)
                        continue</span>
                }
                <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if assert != nil </span><span class="cov0" title="0">{
                return assert, nil
        }</span>

        <span class="cov0" title="0">return nil, &amp;NotFoundError{Type: assertType, Headers: sequenceHeaders}</span>
}

// assertion checkers

// CheckSigningKeyIsNotExpired checks that the signing key is not expired.
func CheckSigningKeyIsNotExpired(assert Assertion, signingKey *AccountKey, roDB RODatabase, checkTimeEarliest, checkTimeLatest time.Time) error <span class="cov0" title="0">{
        if signingKey == nil </span><span class="cov0" title="0">{
                // assert isn't signed with an account-key key, CheckSignature
                // will fail anyway unless we teach it more stuff,
                // Also this check isn't so relevant for self-signed asserts
                // (e.g. account-key-request)
                return nil
        }</span>
        <span class="cov0" title="0">if !signingKey.isValidAssumingCurTimeWithin(checkTimeEarliest, checkTimeLatest) </span><span class="cov0" title="0">{
                mismatchReason := timeMismatchMsg(checkTimeEarliest, checkTimeLatest, signingKey.since, signingKey.until)
                return fmt.Errorf("assertion is signed with expired public key %q from %q: %s", assert.SignKeyID(), assert.AuthorityID(), mismatchReason)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func timeMismatchMsg(earliest, latest, keySince, keyUntil time.Time) string <span class="cov0" title="0">{
        var msg string

        validFrom := earliest.Format(time.RFC3339)
        if !latest.IsZero() &amp;&amp; !latest.Equal(earliest) </span><span class="cov0" title="0">{
                validTo := latest.Format(time.RFC3339)
                msg = fmt.Sprintf("current time range is [%s, %s]", validFrom, validTo)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf("current time is %s", validFrom)
        }</span>

        <span class="cov0" title="0">keyFrom := keySince.Format(time.RFC3339)
        if !keyUntil.IsZero() </span><span class="cov0" title="0">{
                keyTo := keyUntil.Format(time.RFC3339)
                return msg + fmt.Sprintf(" but key is valid during [%s, %s)", keyFrom, keyTo)
        }</span>

        <span class="cov0" title="0">return msg + fmt.Sprintf(" but key is valid from %s", keyFrom)</span>
}

// CheckSignature checks that the signature is valid.
func CheckSignature(assert Assertion, signingKey *AccountKey, roDB RODatabase, checkTimeEarliest, checkTimeLatest time.Time) (err error) <span class="cov0" title="0">{
        var pubKey PublicKey
        if signingKey != nil </span><span class="cov0" title="0">{
                pubKey = signingKey.publicKey()
                if assert.AuthorityID() != signingKey.AccountID() </span><span class="cov0" title="0">{
                        return fmt.Errorf("assertion authority %q does not match public key from %q", assert.AuthorityID(), signingKey.AccountID())
                }</span>
                <span class="cov0" title="0">if !signingKey.canSign(assert) </span><span class="cov0" title="0">{
                        return fmt.Errorf("assertion does not match signing constraints for public key %q from %q", assert.SignKeyID(), assert.AuthorityID())
                }</span>
        } else<span class="cov0" title="0"> {
                custom, ok := assert.(customSigner)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot check no-authority assertion type %q", assert.Type().Name)
                }</span>

                <span class="cov0" title="0">pubKey, err = custom.signKey(roDB)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot check no-authority assertion type %q: %w", assert.Type().Name, err)
                }</span>
        }

        <span class="cov0" title="0">content, encSig := assert.Signature()
        signature, err := decodeSignature(encSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = pubKey.verify(content, signature)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed signature verification: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type timestamped interface {
        Timestamp() time.Time
}

// CheckTimestampVsSigningKeyValidity verifies that the timestamp of
// the assertion is within the signing key validity.
func CheckTimestampVsSigningKeyValidity(assert Assertion, signingKey *AccountKey, roDB RODatabase, checkTimeEarliest, checkTimeLatest time.Time) error <span class="cov0" title="0">{
        if signingKey == nil </span><span class="cov0" title="0">{
                // assert isn't signed with an account-key key, CheckSignature
                // will fail anyway unless we teach it more stuff.
                // Also this check isn't so relevant for self-signed asserts
                // (e.g. account-key-request)
                return nil
        }</span>
        <span class="cov0" title="0">if tstamped, ok := assert.(timestamped); ok </span><span class="cov0" title="0">{
                checkTime := tstamped.Timestamp()
                if !signingKey.isValidAt(checkTime) </span><span class="cov0" title="0">{
                        until := ""
                        if !signingKey.Until().IsZero() </span><span class="cov0" title="0">{
                                until = fmt.Sprintf(" until %q", signingKey.Until())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("%s assertion timestamp %q outside of signing key validity (key valid since %q%s)",
                                assert.Type().Name, checkTime, signingKey.Since(), until)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// A consistencyChecker performs further checks based on the full
// assertion database knowledge and its own signing key.
type consistencyChecker interface {
        checkConsistency(roDB RODatabase, signingKey *AccountKey) error
}

// CheckCrossConsistency verifies that the assertion is consistent with the other statements in the database.
func CheckCrossConsistency(assert Assertion, signingKey *AccountKey, roDB RODatabase, checkTimeEarliest, checkTimeLatest time.Time) error <span class="cov0" title="0">{
        // see if the assertion requires further checks
        if checker, ok := assert.(consistencyChecker); ok </span><span class="cov0" title="0">{
                return checker.checkConsistency(roDB, signingKey)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DefaultCheckers lists the default and recommended assertion
// checkers used by Database if none are specified in the
// DatabaseConfig.Checkers.
var DefaultCheckers = []Checker{
        CheckSigningKeyIsNotExpired,
        CheckSignature,
        CheckTimestampVsSigningKeyValidity,
        CheckCrossConsistency,
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "crypto"
        "encoding/base64"
        "fmt"
)

// EncodeDigest encodes the digest from hash algorithm to be put in an assertion header.
func EncodeDigest(hash crypto.Hash, hashDigest []byte) (string, error) <span class="cov8" title="1">{
        algo := ""
        switch hash </span>{
        case crypto.SHA512:<span class="cov0" title="0">
                algo = "sha512"</span>
        case crypto.SHA3_384:<span class="cov8" title="1">
                algo = "sha3-384"</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported hash")</span>
        }
        <span class="cov8" title="1">if len(hashDigest) != hash.Size() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("hash digest by %s should be %d bytes", algo, hash.Size())
        }</span>
        <span class="cov8" title="1">return base64.RawURLEncoding.EncodeToString(hashDigest), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2021 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "crypto"
        "crypto/rsa"
        "crypto/x509"
        "encoding/json"
        "fmt"
        "io"
        "os/exec"

        "golang.org/x/crypto/openpgp/packet"

        "github.com/snapcore/snapd/strutil"
)

type ExternalKeyInfo struct {
        Name string
        ID   string
}

// ExternalKeypairManager is key pair manager implemented via an external program interface.
// TODO: points to interface docs
type ExternalKeypairManager struct {
        keyMgrPath string
        nameToID   map[string]string
        cache      map[string]*cachedExtKey
}

// NewExternalKeypairManager creates a new ExternalKeypairManager using the program at keyMgrPath.
func NewExternalKeypairManager(keyMgrPath string) (*ExternalKeypairManager, error) <span class="cov0" title="0">{
        em := &amp;ExternalKeypairManager{
                keyMgrPath: keyMgrPath,
                nameToID:   make(map[string]string),
                cache:      make(map[string]*cachedExtKey),
        }
        if err := em.checkFeatures(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return em, nil</span>
}

func (em *ExternalKeypairManager) keyMgr(op string, args []string, in []byte, out any) error <span class="cov0" title="0">{
        args = append([]string{op}, args...)
        cmd := exec.Command(em.keyMgrPath, args...)
        var outBuf bytes.Buffer
        var errBuf bytes.Buffer

        if len(in) != 0 </span><span class="cov0" title="0">{
                cmd.Stdin = bytes.NewBuffer(in)
        }</span>
        <span class="cov0" title="0">cmd.Stdout = &amp;outBuf
        cmd.Stderr = &amp;errBuf

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("external keypair manager %q %v failed: %v (%q)", em.keyMgrPath, args, err, errBuf.Bytes())

        }</span>
        <span class="cov0" title="0">switch o := out.(type) </span>{
        case *[]byte:<span class="cov0" title="0">
                *o = outBuf.Bytes()</span>
        default:<span class="cov0" title="0">
                if err := json.Unmarshal(outBuf.Bytes(), out); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot decode external keypair manager %q %v output: %v", em.keyMgrPath, args, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (em *ExternalKeypairManager) checkFeatures() error <span class="cov0" title="0">{
        var feats struct {
                Signing    []string `json:"signing"`
                PublicKeys []string `json:"public-keys"`
        }
        if err := em.keyMgr("features", nil, nil, &amp;feats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !strutil.ListContains(feats.Signing, "RSA-PKCS") </span><span class="cov0" title="0">{
                return fmt.Errorf("external keypair manager %q missing support for RSA-PKCS signing", em.keyMgrPath)
        }</span>
        <span class="cov0" title="0">if !strutil.ListContains(feats.PublicKeys, "DER") </span><span class="cov0" title="0">{
                return fmt.Errorf("external keypair manager %q missing support for public key DER output format", em.keyMgrPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (em *ExternalKeypairManager) keyNames() ([]string, error) <span class="cov0" title="0">{
        var knames struct {
                Names []string `json:"key-names"`
        }
        if err := em.keyMgr("key-names", nil, nil, &amp;knames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get all external keypair manager key names: %v", err)
        }</span>
        <span class="cov0" title="0">return knames.Names, nil</span>
}

func (em *ExternalKeypairManager) findByName(name string) (PublicKey, *rsa.PublicKey, error) <span class="cov0" title="0">{
        var k []byte
        err := em.keyMgr("get-public-key", []string{"-f", "DER", "-k", name}, nil, &amp;k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;keyNotFoundError{msg: fmt.Sprintf("cannot find external key pair: %v", err)}
        }</span>
        <span class="cov0" title="0">pubk, err := x509.ParsePKIXPublicKey(k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("cannot decode external key %q: %v", name, err)
        }</span>
        <span class="cov0" title="0">rsaPub, ok := pubk.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("expected RSA public key, got instead: %T", pubk)
        }</span>
        <span class="cov0" title="0">pubKey := RSAPublicKey(rsaPub)
        return pubKey, rsaPub, nil</span>
}

func (em *ExternalKeypairManager) Export(keyName string) ([]byte, error) <span class="cov0" title="0">{
        pubKey, _, err := em.findByName(keyName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return EncodePublicKey(pubKey)</span>
}

func (em *ExternalKeypairManager) loadKey(name string) (*cachedExtKey, error) <span class="cov0" title="0">{
        id, ok := em.nameToID[name]
        if ok </span><span class="cov0" title="0">{
                return em.cache[id], nil
        }</span>
        <span class="cov0" title="0">pubKey, rsaPub, err := em.findByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">id = pubKey.ID()
        em.nameToID[name] = id
        cachedKey := &amp;cachedExtKey{
                pubKey: pubKey,
                signer: &amp;extSigner{
                        keyName: name,
                        rsaPub:  rsaPub,
                        // signWith is filled later
                },
        }
        em.cache[id] = cachedKey
        return cachedKey, nil</span>
}

func (em *ExternalKeypairManager) privateKey(cachedKey *cachedExtKey) PrivateKey <span class="cov0" title="0">{
        if cachedKey.privKey == nil </span><span class="cov0" title="0">{
                extSigner := cachedKey.signer
                // fill signWith
                extSigner.signWith = em.signWith
                signer := packet.NewSignerPrivateKey(v1FixedTimestamp, extSigner)
                signk := openpgpPrivateKey{privk: signer}
                extKey := &amp;extPGPPrivateKey{
                        pubKey:     cachedKey.pubKey,
                        from:       fmt.Sprintf("external keypair manager %q", em.keyMgrPath),
                        externalID: extSigner.keyName,
                        bitLen:     extSigner.rsaPub.N.BitLen(),
                        doSign:     signk.sign,
                }
                cachedKey.privKey = extKey
        }</span>
        <span class="cov0" title="0">return cachedKey.privKey</span>
}

func (em *ExternalKeypairManager) GetByName(keyName string) (PrivateKey, error) <span class="cov0" title="0">{
        cachedKey, err := em.loadKey(keyName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return em.privateKey(cachedKey), nil</span>
}

// ExternalUnsupportedOpError represents the error situation of operations
// that are not supported/mediated via ExternalKeypairManager.
type ExternalUnsupportedOpError struct {
        msg string
}

func (euoe *ExternalUnsupportedOpError) Error() string <span class="cov0" title="0">{
        return euoe.msg
}</span>

func (em *ExternalKeypairManager) Put(privKey PrivateKey) error <span class="cov0" title="0">{
        return &amp;ExternalUnsupportedOpError{"cannot import private key into external keypair manager"}
}</span>

func (em *ExternalKeypairManager) Delete(keyID string) error <span class="cov0" title="0">{
        return &amp;ExternalUnsupportedOpError{"no support to delete external keypair manager keys"}
}</span>

func (em *ExternalKeypairManager) DeleteByName(keyName string) error <span class="cov0" title="0">{
        return &amp;ExternalUnsupportedOpError{"no support to delete external keypair manager keys"}
}</span>

func (em *ExternalKeypairManager) Generate(keyName string) error <span class="cov0" title="0">{
        return &amp;ExternalUnsupportedOpError{"no support to mediate generating an external keypair manager key"}
}</span>

func (em *ExternalKeypairManager) loadAllKeys() ([]string, error) <span class="cov0" title="0">{
        names, err := em.keyNames()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, name := range names </span><span class="cov0" title="0">{
                if _, err := em.loadKey(name); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return names, nil</span>
}

func (em *ExternalKeypairManager) Get(keyID string) (PrivateKey, error) <span class="cov0" title="0">{
        cachedKey, ok := em.cache[keyID]
        if !ok </span><span class="cov0" title="0">{
                // try to load all keys
                if _, err := em.loadAllKeys(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cachedKey, ok = em.cache[keyID]
                if !ok </span><span class="cov0" title="0">{
                        return nil, &amp;keyNotFoundError{msg: "cannot find external key pair"}
                }</span>
        }
        <span class="cov0" title="0">return em.privateKey(cachedKey), nil</span>
}

func (em *ExternalKeypairManager) List() ([]ExternalKeyInfo, error) <span class="cov0" title="0">{
        names, err := em.loadAllKeys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">res := make([]ExternalKeyInfo, len(names))
        for i, name := range names </span><span class="cov0" title="0">{
                res[i].Name = name
                res[i].ID = em.cache[em.nameToID[name]].pubKey.ID()
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

// see https://datatracker.ietf.org/doc/html/rfc2313 and more recently
// and more precisely about SHA-512:
// https://datatracker.ietf.org/doc/html/rfc3447#section-9.2 Notes 1.
var digestInfoSHA512Prefix = []byte{0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40}

func (em *ExternalKeypairManager) signWith(keyName string, digest []byte) (signature []byte, err error) <span class="cov0" title="0">{
        // wrap the digest into the needed DigestInfo, the RSA-PKCS
        // mechanism or equivalent is expected not to do this on its
        // own
        toSign := &amp;bytes.Buffer{}
        toSign.Write(digestInfoSHA512Prefix)
        toSign.Write(digest)

        err = em.keyMgr("sign", []string{"-m", "RSA-PKCS", "-k", keyName}, toSign.Bytes(), &amp;signature)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return signature, nil</span>
}

type cachedExtKey struct {
        pubKey  PublicKey
        signer  *extSigner
        privKey PrivateKey
}

type extSigner struct {
        keyName  string
        rsaPub   *rsa.PublicKey
        signWith func(keyName string, digest []byte) (signature []byte, err error)
}

func (es *extSigner) Public() crypto.PublicKey <span class="cov0" title="0">{
        return es.rsaPub
}</span>

func (es *extSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) (signature []byte, err error) <span class="cov0" title="0">{
        if opts.HashFunc() != crypto.SHA512 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected pgp signature digest")
        }</span>

        <span class="cov0" title="0">return es.signWith(es.keyName, digest)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
)

type fetchProgress int

const (
        fetchNotSeen fetchProgress = iota
        fetchRetrieved
        fetchSaved
)

// To allow us to mock prerequisites of an assertion for testing.
var assertionPrereqs = func(a Assertion) []*Ref <span class="cov0" title="0">{
        return a.Prerequisites()
}</span>

// A Fetcher helps fetching assertions and their prerequisites.
type Fetcher interface {
        // Fetch retrieves the assertion indicated by ref then its prerequisites
        // recursively, along the way saving prerequisites before dependent assertions.
        Fetch(*Ref) error
        // Save retrieves the prerequisites of the assertion recursively,
        // along the way saving them, and finally saves the assertion.
        Save(Assertion) error
}

type fetcher struct {
        db          RODatabase
        retrieve    func(*Ref) (Assertion, error)
        retrieveSeq func(*AtSequence) (Assertion, error)
        save        func(Assertion) error

        fetched map[string]fetchProgress
}

// NewFetcher creates a Fetcher which will use trustedDB to determine trusted assertions,
// will fetch assertions following prerequisites using retrieve, and then will pass
// them to save, saving prerequisites before dependent assertions.
func NewFetcher(trustedDB RODatabase, retrieve func(*Ref) (Assertion, error), save func(Assertion) error) Fetcher <span class="cov0" title="0">{
        return &amp;fetcher{
                db:       trustedDB,
                retrieve: retrieve,
                save:     save,
                fetched:  make(map[string]fetchProgress),
        }
}</span>

// SequenceFormingFetcher is a Fetcher with special support for fetching sequence-forming assertions through FetchSequence.
type SequenceFormingFetcher interface {
        // SequenceFormingFetcher must also implement the interface of the Fetcher.
        Fetcher

        // FetchSequence retrieves the assertion as indicated the given sequence reference. Retrieving multiple
        // sequence points of the same assertion is currently unsupported. The first sequence fetched through this
        // will be the one passed to the save callback. Any subsequent sequences fetched will not have any
        // effect and will be treated as if they've already been fetched.
        FetchSequence(*AtSequence) error
}

// NewSequenceFormingFetcher creates a SequenceFormingFetcher which will use trustedDB to determine trusted assertions,
// will fetch assertions following prerequisites using retrieve and sequence-forming assertions using retrieveSeq, and then will pass
// them to save, saving prerequisites before dependent assertions.
func NewSequenceFormingFetcher(trustedDB RODatabase, retrieve func(*Ref) (Assertion, error), retrieveSeq func(*AtSequence) (Assertion, error), save func(Assertion) error) SequenceFormingFetcher <span class="cov0" title="0">{
        return &amp;fetcher{
                db:          trustedDB,
                retrieve:    retrieve,
                retrieveSeq: retrieveSeq,
                save:        save,
                fetched:     make(map[string]fetchProgress),
        }
}</span>

func (f *fetcher) wasFetched(ref *Ref) (bool, error) <span class="cov0" title="0">{
        switch f.fetched[ref.Unique()] </span>{
        case fetchSaved:<span class="cov0" title="0">
                return true, nil</span> // nothing to do
        case fetchRetrieved:<span class="cov0" title="0">
                return false, fmt.Errorf("circular assertions are not expected: %s", ref)</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (f *fetcher) fetchPrerequisitesAndSave(key string, a Assertion) error <span class="cov0" title="0">{
        f.fetched[key] = fetchRetrieved
        for _, preref := range assertionPrereqs(a) </span><span class="cov0" title="0">{
                if err := f.Fetch(preref); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err := f.fetchAccountKey(a.SignKeyID()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := f.save(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.fetched[key] = fetchSaved
        return nil</span>
}

func (f *fetcher) chase(ref *Ref, a Assertion) error <span class="cov0" title="0">{
        // check if ref points to predefined assertion, in which case
        // there is nothing to do
        _, err := ref.Resolve(f.db.FindPredefined)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok, err := f.wasFetched(ref); err != nil || ok </span><span class="cov0" title="0">{
                // if ok is true, then the assertion was fetched and err is nil
                return err
        }</span>
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                retrieved, err := f.retrieve(ref)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a = retrieved</span>
        }
        <span class="cov0" title="0">return f.fetchPrerequisitesAndSave(ref.Unique(), a)</span>
}

// Fetch retrieves the assertion indicated by ref then its prerequisites
// recursively, along the way saving prerequisites before dependent assertions.
func (f *fetcher) Fetch(ref *Ref) error <span class="cov0" title="0">{
        return f.chase(ref, nil)
}</span>

func (f *fetcher) wasSeqFetched(seq *AtSequence) (bool, error) <span class="cov0" title="0">{
        switch f.fetched[seq.Unique()] </span>{
        case fetchSaved:<span class="cov0" title="0">
                return true, nil</span> // nothing to do
        case fetchRetrieved:<span class="cov0" title="0">
                return false, fmt.Errorf("circular assertions are not expected: %s", seq)</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (f *fetcher) fetchSequence(seq *AtSequence) error <span class="cov0" title="0">{
        // sequence forming assertions are never predefined, so we don't check for it.
        if ok, err := f.wasSeqFetched(seq); err != nil || ok </span><span class="cov0" title="0">{
                // if ok is true, then the assertion was fetched and err is nil
                return err
        }</span>
        <span class="cov0" title="0">a, err := f.retrieveSeq(seq)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return f.fetchPrerequisitesAndSave(seq.Unique(), a)</span>
}

// FetchSequence retrieves the assertion as indicated by its sequence reference.
func (f *fetcher) FetchSequence(seq *AtSequence) error <span class="cov0" title="0">{
        if f.retrieveSeq == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot fetch assertion sequence point, fetcher must be created using NewSequenceFormingFetcher")
        }</span>
        <span class="cov0" title="0">return f.fetchSequence(seq)</span>
}

// fetchAccountKey behaves like Fetch for the account-key with the given key id.
func (f *fetcher) fetchAccountKey(keyID string) error <span class="cov0" title="0">{
        keyRef := &amp;Ref{
                Type:       AccountKeyType,
                PrimaryKey: []string{keyID},
        }
        return f.Fetch(keyRef)
}</span>

// Save retrieves the prerequisites of the assertion recursively,
// along the way saving them, and finally saves the assertion.
func (f *fetcher) Save(a Assertion) error <span class="cov0" title="0">{
        return f.chase(a.Ref(), a)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
)

/*
findWildcard invokes foundCb once for each parent directory of regular files matching:

&lt;top&gt;/&lt;descendantWithWildcard[0]&gt;/&lt;descendantWithWildcard[1]&gt;...

where each descendantWithWildcard component can contain the * wildcard.

One of the descendantWithWildcard components except the last
can be "#&gt;" or "#&lt;", in which case that level is assumed to have names
that can be parsed as positive integers, which will be enumerated in
ascending (#&gt;) or descending order respectively (#&lt;); if seqnum != -1
then only the values &gt;seqnum or respectively &lt;seqnum will be
considered.

foundCb is invoked with the paths of the found regular files relative to top (that means top/ is excluded).

Unlike filepath.Glob any I/O operation error stops the walking and bottoms out, so does a foundCb invocation that returns an error.
*/
func findWildcard(top string, descendantWithWildcard []string, seqnum int, foundCb func(relpath []string) error) error <span class="cov0" title="0">{
        return findWildcardDescend(top, top, descendantWithWildcard, seqnum, foundCb)
}</span>

func findWildcardBottom(top, current string, pat string, names []string, foundCb func(relpath []string) error) error <span class="cov0" title="0">{
        var hits []string
        for _, name := range names </span><span class="cov0" title="0">{
                ok, err := filepath.Match(pat, name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("findWildcard: invoked with malformed wildcard: %v", err)
                }</span>
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fn := filepath.Join(current, name)
                finfo, err := os.Stat(fn)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !finfo.Mode().IsRegular() </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected a regular file: %v", fn)
                }</span>
                <span class="cov0" title="0">relpath, err := filepath.Rel(top, fn)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("findWildcard: unexpected to fail at computing rel path of descendant")
                }</span>
                <span class="cov0" title="0">hits = append(hits, relpath)</span>
        }
        <span class="cov0" title="0">if len(hits) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return foundCb(hits)</span>
}

func findWildcardDescend(top, current string, descendantWithWildcard []string, seqnum int, foundCb func(relpath []string) error) error <span class="cov0" title="0">{
        k := descendantWithWildcard[0]
        if k == "#&gt;" || k == "#&lt;" </span><span class="cov0" title="0">{
                if len(descendantWithWildcard) == 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("findWildcard: sequence wildcard (#&gt;|&lt;#) cannot be the last component")
                }</span>
                <span class="cov0" title="0">return findWildcardSequence(top, current, k, descendantWithWildcard[1:], seqnum, foundCb)</span>
        }
        <span class="cov0" title="0">if len(descendantWithWildcard) &gt; 1 &amp;&amp; strings.IndexByte(k, '*') == -1 </span><span class="cov0" title="0">{
                return findWildcardDescend(top, filepath.Join(current, k), descendantWithWildcard[1:], seqnum, foundCb)
        }</span>

        <span class="cov0" title="0">d, err := os.Open(current)
        // ignore missing directory, higher level will produce
        // NotFoundError as needed
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer d.Close()
        names, err := d.Readdirnames(-1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(descendantWithWildcard) == 1 </span><span class="cov0" title="0">{
                return findWildcardBottom(top, current, k, names, foundCb)
        }</span>
        <span class="cov0" title="0">for _, name := range names </span><span class="cov0" title="0">{
                ok, err := filepath.Match(k, name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("findWildcard: invoked with malformed wildcard: %v", err)
                }</span>
                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                        err = findWildcardDescend(top, filepath.Join(current, name), descendantWithWildcard[1:], seqnum, foundCb)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func findWildcardSequence(top, current, seqWildcard string, descendantWithWildcard []string, seqnum int, foundCb func(relpath []string) error) error <span class="cov0" title="0">{
        filter := func(i int) bool </span><span class="cov0" title="0">{ return true }</span>
        <span class="cov0" title="0">if seqnum != -1 </span><span class="cov0" title="0">{
                if seqWildcard == "#&gt;" </span><span class="cov0" title="0">{
                        filter = func(i int) bool </span><span class="cov0" title="0">{ return i &gt; seqnum }</span>
                } else<span class="cov0" title="0"> { // "#&lt;", guaranteed by the caller
                        filter = func(i int) bool </span><span class="cov0" title="0">{ return i &lt; seqnum }</span>
                }
        }

        <span class="cov0" title="0">d, err := os.Open(current)
        // ignore missing directory, higher level will produce
        // NotFoundError as needed
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer d.Close()
        var seq []int
        for </span><span class="cov0" title="0">{
                names, err := d.Readdirnames(100)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, n := range names </span><span class="cov0" title="0">{
                        sqn, err := strconv.Atoi(n)
                        if err != nil || sqn &lt; 0 || prefixZeros(n) </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot parse %q name as a valid sequence number", filepath.Join(current, n))
                        }</span>
                        <span class="cov0" title="0">if filter(sqn) </span><span class="cov0" title="0">{
                                seq = append(seq, sqn)
                        }</span>
                }
        }
        <span class="cov0" title="0">sort.Ints(seq)

        var start, direction int
        if seqWildcard == "#&gt;" </span><span class="cov0" title="0">{
                start = 0
                direction = 1
        }</span> else<span class="cov0" title="0"> {
                start = len(seq) - 1
                direction = -1
        }</span>
        <span class="cov0" title="0">for i := start; i &gt;= 0 &amp;&amp; i &lt; len(seq); i += direction </span><span class="cov0" title="0">{
                err = findWildcardDescend(top, filepath.Join(current, strconv.Itoa(seq[i])), descendantWithWildcard, -1, foundCb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
)

// the default filesystem based backstore for assertions

const (
        assertionsLayoutVersion = "v0"
        assertionsRoot          = "asserts-" + assertionsLayoutVersion
)

type filesystemBackstore struct {
        top string
        mu  sync.RWMutex
}

// OpenFSBackstore opens a filesystem backed assertions backstore under path.
func OpenFSBackstore(path string) (Backstore, error) <span class="cov0" title="0">{
        top := filepath.Join(path, assertionsRoot)
        err := ensureTop(top)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;filesystemBackstore{top: top}, nil</span>
}

// guarantees that result assertion is of the expected type (both in the AssertionType and go type sense)
func (fsbs *filesystemBackstore) readAssertion(assertType *AssertionType, diskPrimaryPath string) (Assertion, error) <span class="cov0" title="0">{
        encoded, err := readEntry(fsbs.top, assertType.Name, diskPrimaryPath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("broken assertion storage, cannot read assertion: %v", err)
        }</span>
        <span class="cov0" title="0">assert, err := Decode(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("broken assertion storage, cannot decode assertion: %v", err)
        }</span>
        <span class="cov0" title="0">if assert.Type() != assertType </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assertion that is not of type %q under their storage tree", assertType.Name)
        }</span>
        // because of Decode() construction assert has also the expected go type
        <span class="cov0" title="0">return assert, nil</span>
}

func (fsbs *filesystemBackstore) pickLatestAssertion(assertType *AssertionType, diskPrimaryPaths []string, maxFormat int) (a Assertion, er error) <span class="cov0" title="0">{
        for _, diskPrimaryPath := range diskPrimaryPaths </span><span class="cov0" title="0">{
                fn := filepath.Base(diskPrimaryPath)
                parts := strings.SplitN(fn, ".", 2)
                formatnum := 0
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        var err error
                        formatnum, err = strconv.Atoi(parts[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid active assertion filename: %q", fn)
                        }</span>
                }
                <span class="cov0" title="0">if formatnum &lt;= maxFormat </span><span class="cov0" title="0">{
                        a1, err := fsbs.readAssertion(assertType, diskPrimaryPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if a == nil || a1.Revision() &gt; a.Revision() </span><span class="cov0" title="0">{
                                a = a1
                        }</span>
                }
        }
        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>
        <span class="cov0" title="0">return a, nil</span>
}

// diskPrimaryPathComps computes the components of the path for an assertion.
// The path will look like this: (all &lt;comp&gt; are query escaped)
// &lt;primaryPath0&gt;/&lt;primaryPath1&gt;...[/0:&lt;optPrimaryPath0&gt;[/1:&lt;optPrimaryPath1&gt;]...]/&lt;active&gt;
// The components #:&lt;value&gt; for the optional primary path values
// appear only if their value is not the default.
// This makes it so that assertions with default values have the same
// paths as for snapd versions without those optional primary keys
// yet.
func diskPrimaryPathComps(assertType *AssertionType, primaryPath []string, active string) []string <span class="cov0" title="0">{
        n := len(primaryPath)
        comps := make([]string, 0, n+1)
        // safety against '/' etc
        noptional := -1
        for i, comp := range primaryPath </span><span class="cov0" title="0">{
                defl := assertType.OptionalPrimaryKeyDefaults[assertType.PrimaryKey[i]]
                qvalue := url.QueryEscape(comp)
                if defl != "" </span><span class="cov0" title="0">{
                        noptional++
                        if comp == defl </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">qvalue = fmt.Sprintf("%d:%s", noptional, qvalue)</span>
                }
                <span class="cov0" title="0">comps = append(comps, qvalue)</span>
        }
        <span class="cov0" title="0">comps = append(comps, active)
        return comps</span>
}

func (fsbs *filesystemBackstore) currentAssertion(assertType *AssertionType, primaryPath []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        var a Assertion
        namesCb := func(relpaths []string) error </span><span class="cov0" title="0">{
                var err error
                a, err = fsbs.pickLatestAssertion(assertType, relpaths, maxFormat)
                if err == errNotFound </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">comps := diskPrimaryPathComps(assertType, primaryPath, "active*")
        assertTypeTop := filepath.Join(fsbs.top, assertType.Name)
        err := findWildcard(assertTypeTop, comps, 0, namesCb)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("broken assertion storage, looking for %s: %v", assertType.Name, err)
        }</span>

        <span class="cov0" title="0">if a == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}

func (fsbs *filesystemBackstore) Put(assertType *AssertionType, assert Assertion) error <span class="cov0" title="0">{
        fsbs.mu.Lock()
        defer fsbs.mu.Unlock()

        primaryPath := assert.Ref().PrimaryKey

        curAssert, err := fsbs.currentAssertion(assertType, primaryPath, assertType.MaxSupportedFormat())
        if err == nil </span><span class="cov0" title="0">{
                curRev := curAssert.Revision()
                rev := assert.Revision()
                if curRev &gt;= rev </span><span class="cov0" title="0">{
                        return &amp;RevisionError{Current: curRev, Used: rev}
                }</span>
        } else<span class="cov0" title="0"> if err != errNotFound </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">formatnum := assert.Format()
        activeFn := "active"
        if formatnum &gt; 0 </span><span class="cov0" title="0">{
                activeFn = fmt.Sprintf("active.%d", formatnum)
        }</span>
        <span class="cov0" title="0">diskPrimaryPath := filepath.Join(diskPrimaryPathComps(assertType, primaryPath, activeFn)...)
        err = atomicWriteEntry(Encode(assert), false, fsbs.top, assertType.Name, diskPrimaryPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("broken assertion storage, cannot write assertion: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (fsbs *filesystemBackstore) Get(assertType *AssertionType, key []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        fsbs.mu.RLock()
        defer fsbs.mu.RUnlock()

        if len(key) &gt; len(assertType.PrimaryKey) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: Backstore.Get given a key longer than expected for %q: %v", assertType.Name, key)
        }</span>

        <span class="cov0" title="0">a, err := fsbs.currentAssertion(assertType, key, maxFormat)
        if err == errNotFound </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{Type: assertType}
        }</span>
        <span class="cov0" title="0">return a, err</span>
}

func (fsbs *filesystemBackstore) search(assertType *AssertionType, diskPattern []string, foundCb func(Assertion), maxFormat int) error <span class="cov0" title="0">{
        assertTypeTop := filepath.Join(fsbs.top, assertType.Name)
        candCb := func(diskPrimaryPaths []string) error </span><span class="cov0" title="0">{
                a, err := fsbs.pickLatestAssertion(assertType, diskPrimaryPaths, maxFormat)
                if err == errNotFound </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">foundCb(a)
                return nil</span>
        }
        <span class="cov0" title="0">err := findWildcard(assertTypeTop, diskPattern, 0, candCb)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("broken assertion storage, searching for %s: %v", assertType.Name, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (fsbs *filesystemBackstore) searchOptional(assertType *AssertionType, kopt, pattPos, firstOpt int, diskPattern []string, headers map[string]string, foundCb func(Assertion), maxFormat int) error <span class="cov0" title="0">{
        if kopt == len(assertType.PrimaryKey) </span><span class="cov0" title="0">{
                candCb := func(a Assertion) </span><span class="cov0" title="0">{
                        if searchMatch(a, headers) </span><span class="cov0" title="0">{
                                foundCb(a)
                        }</span>
                }

                <span class="cov0" title="0">diskPattern[pattPos] = "active*"
                return fsbs.search(assertType, diskPattern[:pattPos+1], candCb, maxFormat)</span>
        }
        <span class="cov0" title="0">k := assertType.PrimaryKey[kopt]
        keyVal := headers[k]
        switch keyVal </span>{
        case "":<span class="cov0" title="0">
                diskPattern[pattPos] = fmt.Sprintf("%d:*", kopt-firstOpt)
                if err := fsbs.searchOptional(assertType, kopt+1, pattPos+1, firstOpt, diskPattern, headers, foundCb, maxFormat); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case assertType.OptionalPrimaryKeyDefaults[k]:<span class="cov0" title="0">
                return fsbs.searchOptional(assertType, kopt+1, pattPos, firstOpt, diskPattern, headers, foundCb, maxFormat)</span>
        default:<span class="cov0" title="0">
                diskPattern[pattPos] = fmt.Sprintf("%d:%s", kopt-firstOpt, url.QueryEscape(keyVal))
                return fsbs.searchOptional(assertType, kopt+1, pattPos+1, firstOpt, diskPattern, headers, foundCb, maxFormat)</span>
        }
}

func (fsbs *filesystemBackstore) Search(assertType *AssertionType, headers map[string]string, foundCb func(Assertion), maxFormat int) error <span class="cov0" title="0">{
        fsbs.mu.RLock()
        defer fsbs.mu.RUnlock()

        n := len(assertType.PrimaryKey)
        nopt := len(assertType.OptionalPrimaryKeyDefaults)
        diskPattern := make([]string, n+1)
        for i, k := range assertType.PrimaryKey[:n-nopt] </span><span class="cov0" title="0">{
                keyVal := headers[k]
                if keyVal == "" </span><span class="cov0" title="0">{
                        diskPattern[i] = "*"
                }</span> else<span class="cov0" title="0"> {
                        diskPattern[i] = url.QueryEscape(keyVal)
                }</span>
        }
        <span class="cov0" title="0">pattPos := n - nopt

        return fsbs.searchOptional(assertType, pattPos, pattPos, pattPos, diskPattern, headers, foundCb, maxFormat)</span>
}

// errFound marks the case an assertion was found
var errFound = errors.New("found")

func (fsbs *filesystemBackstore) SequenceMemberAfter(assertType *AssertionType, sequenceKey []string, after, maxFormat int) (SequenceMember, error) <span class="cov0" title="0">{
        if !assertType.SequenceForming() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("internal error: SequenceMemberAfter on non sequence-forming assertion type %s", assertType.Name))</span>
        }
        <span class="cov0" title="0">if len(sequenceKey) != len(assertType.PrimaryKey)-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: SequenceMemberAfter's sequence key argument length must be exactly 1 less than the assertion type primary key")
        }</span>

        <span class="cov0" title="0">fsbs.mu.RLock()
        defer fsbs.mu.RUnlock()

        n := len(assertType.PrimaryKey)
        diskPattern := make([]string, n+1)
        for i, k := range sequenceKey </span><span class="cov0" title="0">{
                diskPattern[i] = url.QueryEscape(k)
        }</span>
        <span class="cov0" title="0">seqWildcard := "#&gt;" // ascending sequence wildcard
        if after == -1 </span><span class="cov0" title="0">{
                // find the latest in sequence
                // use descending sequence wildcard
                seqWildcard = "#&lt;"
        }</span>
        <span class="cov0" title="0">diskPattern[n-1] = seqWildcard
        diskPattern[n] = "active*"

        var a Assertion
        candCb := func(diskPrimaryPaths []string) error </span><span class="cov0" title="0">{
                var err error
                a, err = fsbs.pickLatestAssertion(assertType, diskPrimaryPaths, maxFormat)
                if err == errNotFound </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return errFound</span>
        }

        <span class="cov0" title="0">assertTypeTop := filepath.Join(fsbs.top, assertType.Name)
        err := findWildcard(assertTypeTop, diskPattern, after, candCb)
        if err == errFound </span><span class="cov0" title="0">{
                return a.(SequenceMember), nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("broken assertion storage, searching for %s: %v", assertType.Name, err)
        }</span>

        <span class="cov0" title="0">return nil, &amp;NotFoundError{Type: assertType}</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/snapcore/snapd/osutil"
)

// utilities to read/write fs entries

func ensureTop(path string) error <span class="cov0" title="0">{
        err := os.MkdirAll(path, 0775)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create assert storage root: %v", err)
        }</span>
        <span class="cov0" title="0">info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create assert storage root: %v", err)
        }</span>
        <span class="cov0" title="0">if info.Mode().Perm()&amp;0002 != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("assert storage root unexpectedly world-writable: %v", path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func atomicWriteEntry(data []byte, secret bool, top string, subpath ...string) error <span class="cov0" title="0">{
        fpath := filepath.Join(top, filepath.Join(subpath...))
        dir := filepath.Dir(fpath)
        err := os.MkdirAll(dir, 0775)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fperm := 0664
        if secret </span><span class="cov0" title="0">{
                fperm = 0600
        }</span>
        <span class="cov0" title="0">return osutil.AtomicWriteFile(fpath, data, os.FileMode(fperm), 0)</span>
}

func entryExists(top string, subpath ...string) bool <span class="cov0" title="0">{
        fpath := filepath.Join(top, filepath.Join(subpath...))
        return osutil.FileExists(fpath)
}</span>

func readEntry(top string, subpath ...string) ([]byte, error) <span class="cov0" title="0">{
        fpath := filepath.Join(top, filepath.Join(subpath...))
        return os.ReadFile(fpath)
}</span>

func removeEntry(top string, subpath ...string) error <span class="cov0" title="0">{
        fpath := filepath.Join(top, filepath.Join(subpath...))
        return os.Remove(fpath)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

// the default simple filesystem based keypair manager/backstore

const (
        privateKeysLayoutVersion = "v1"
        privateKeysRoot          = "private-keys-" + privateKeysLayoutVersion
)

type filesystemKeypairManager struct {
        top string
        mu  sync.RWMutex
}

// OpenFSKeypairManager opens a filesystem backed assertions backstore under path.
func OpenFSKeypairManager(path string) (KeypairManager, error) <span class="cov0" title="0">{
        top := filepath.Join(path, privateKeysRoot)
        err := ensureTop(top)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;filesystemKeypairManager{top: top}, nil</span>
}

var errKeypairAlreadyExists = errors.New("key pair with given key id already exists")

func (fskm *filesystemKeypairManager) Put(privKey PrivateKey) error <span class="cov0" title="0">{
        keyID := privKey.PublicKey().ID()
        if entryExists(fskm.top, keyID) </span><span class="cov0" title="0">{
                return errKeypairAlreadyExists
        }</span>
        <span class="cov0" title="0">encoded, err := encodePrivateKey(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot store private key: %v", err)
        }</span>

        <span class="cov0" title="0">fskm.mu.Lock()
        defer fskm.mu.Unlock()

        err = atomicWriteEntry(encoded, true, fskm.top, keyID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot store private key: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var errKeypairNotFound = &amp;keyNotFoundError{msg: "cannot find key pair"}

func (fskm *filesystemKeypairManager) Get(keyID string) (PrivateKey, error) <span class="cov0" title="0">{
        fskm.mu.RLock()
        defer fskm.mu.RUnlock()

        encoded, err := readEntry(fskm.top, keyID)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, errKeypairNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot read key pair: %v", err)
        }</span>
        <span class="cov0" title="0">privKey, err := decodePrivateKey(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot decode key pair: %v", err)
        }</span>
        <span class="cov0" title="0">return privKey, nil</span>
}

func (fskm *filesystemKeypairManager) Delete(keyID string) error <span class="cov0" title="0">{
        fskm.mu.RLock()
        defer fskm.mu.RUnlock()

        err := removeEntry(fskm.top, keyID)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return errKeypairNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2021 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "golang.org/x/crypto/openpgp/packet"

        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/strutil"
)

func ensureGPGHomeDirectory() (string, error) <span class="cov0" title="0">{
        real, err := osutil.UserMaybeSudoUser()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">uid, gid, err := osutil.UidGid(real)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">homedir := os.Getenv("SNAP_GNUPG_HOME")
        if homedir == "" </span><span class="cov0" title="0">{
                homedir = filepath.Join(real.HomeDir, ".snap", "gnupg")
        }</span>

        <span class="cov0" title="0">if err := osutil.MkdirAllChown(homedir, 0700, uid, gid); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return homedir, nil</span>
}

// findGPGCommand returns the path to a suitable GnuPG binary to use.
// GnuPG 2 is mainly intended for desktop use, and is hard for us to use
// here: in particular, it's extremely difficult to use it to delete a
// secret key without a pinentry prompt (which would be necessary in our
// test suite).  GnuPG 1 is still supported so it's reasonable to continue
// using that for now.
func findGPGCommand() (string, error) <span class="cov0" title="0">{
        if path := os.Getenv("SNAP_GNUPG_CMD"); path != "" </span><span class="cov0" title="0">{
                return path, nil
        }</span>

        <span class="cov0" title="0">path, err := exec.LookPath("gpg1")
        if err != nil </span><span class="cov0" title="0">{
                path, err = exec.LookPath("gpg")
        }</span>
        <span class="cov0" title="0">return path, err</span>
}

var gpgBatchYes = false

func runGPGImpl(input []byte, args ...string) ([]byte, error) <span class="cov0" title="0">{
        homedir, err := ensureGPGHomeDirectory()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure the gpg-agent knows what tty to talk to to ask for
        // the passphrase. This is needed because we drive gpg over
        // a pipe and if the agent is not already started it will
        // fail to be able to ask for a password.
        <span class="cov0" title="0">if os.Getenv("GPG_TTY") == "" </span><span class="cov0" title="0">{
                tty, err := os.Readlink("/proc/self/fd/0")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">os.Setenv("GPG_TTY", tty)</span>
        }

        <span class="cov0" title="0">general := []string{"--homedir", homedir, "-q", "--no-auto-check-trustdb"}
        if gpgBatchYes &amp;&amp; strutil.ListContains(args, "--batch") </span><span class="cov0" title="0">{
                general = append(general, "--yes")
        }</span>
        <span class="cov0" title="0">allArgs := append(general, args...)

        path, err := findGPGCommand()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cmd := exec.Command(path, allArgs...)
        var outBuf bytes.Buffer
        var errBuf bytes.Buffer

        if len(input) != 0 </span><span class="cov0" title="0">{
                cmd.Stdin = bytes.NewBuffer(input)
        }</span>

        <span class="cov0" title="0">cmd.Stdout = &amp;outBuf
        cmd.Stderr = &amp;errBuf

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s %s failed: %v (%q)", path, strings.Join(args, " "), err, errBuf.Bytes())
        }</span>

        <span class="cov0" title="0">return outBuf.Bytes(), nil</span>
}

var runGPG = runGPGImpl

// A key pair manager backed by a local GnuPG setup.
type GPGKeypairManager struct{}

func (gkm *GPGKeypairManager) gpg(input []byte, args ...string) ([]byte, error) <span class="cov0" title="0">{
        return runGPG(input, args...)
}</span>

// NewGPGKeypairManager creates a new key pair manager backed by a local GnuPG setup.
// Importing keys through the keypair manager interface is not
// suppored.
// Main purpose is allowing signing using keys from a GPG setup.
func NewGPGKeypairManager() *GPGKeypairManager <span class="cov0" title="0">{
        return &amp;GPGKeypairManager{}
}</span>

func (gkm *GPGKeypairManager) retrieve(fpr string) (PrivateKey, error) <span class="cov0" title="0">{
        out, err := gkm.gpg(nil, "--batch", "--export", "--export-options", "export-minimal,export-clean,no-export-attributes", "0x"+fpr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(out) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot retrieve key with fingerprint %q in GPG keyring", fpr)
        }</span>

        <span class="cov0" title="0">pubKeyBuf := bytes.NewBuffer(out)
        privKey, err := newExtPGPPrivateKey(pubKeyBuf, "GPG", func(content []byte) (*packet.Signature, error) </span><span class="cov0" title="0">{
                return gkm.sign(fpr, content)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot load GPG public key with fingerprint %q: %v", fpr, err)
        }</span>
        <span class="cov0" title="0">gotFingerprint := privKey.externalID
        if gotFingerprint != fpr </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("got wrong public key from GPG, expected fingerprint %q: %s", fpr, gotFingerprint)
        }</span>
        <span class="cov0" title="0">return privKey, nil</span>
}

// Walk iterates over all the RSA private keys in the local GPG setup calling the provided callback until this returns an error
func (gkm *GPGKeypairManager) Walk(consider func(privk PrivateKey, fingerprint string, uid string) error) error <span class="cov0" title="0">{
        // see GPG source doc/DETAILS
        out, err := gkm.gpg(nil, "--batch", "--list-secret-keys", "--fingerprint", "--with-colons", "--fixed-list-mode")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">lines := strings.Split(string(out), "\n")
        n := len(lines)
        if n &gt; 0 &amp;&amp; lines[n-1] == "" </span><span class="cov0" title="0">{
                n--
        }</span>
        <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">lines = lines[:n]
        for j := 0; j &lt; n; j++ </span><span class="cov0" title="0">{
                // sec: line
                line := lines[j]
                if !strings.HasPrefix(line, "sec:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">secFields := strings.Split(line, ":")
                if len(secFields) &lt; 5 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if secFields[3] != "1" </span><span class="cov0" title="0">{ // not RSA
                        continue</span>
                }
                <span class="cov0" title="0">keyID := secFields[4]
                uid := ""
                fpr := ""
                var privKey PrivateKey
                // look for fpr:, uid: lines, order may vary and gpg2.1
                // may springle additional lines in (like gpr:)
        Loop:
                for k := j + 1; k &lt; n &amp;&amp; !strings.HasPrefix(lines[k], "sec:"); k++ </span><span class="cov0" title="0">{
                        switch </span>{
                        case strings.HasPrefix(lines[k], "fpr:"):<span class="cov0" title="0">
                                fprFields := strings.Split(lines[k], ":")
                                // extract "Field 10 - User-ID"
                                // A FPR record stores the fingerprint here.
                                if len(fprFields) &lt; 10 </span><span class="cov0" title="0">{
                                        break Loop</span>
                                }
                                <span class="cov0" title="0">fpr = fprFields[9]
                                if !strings.HasSuffix(fpr, keyID) </span><span class="cov0" title="0">{
                                        break</span> // strange, skip
                                }
                                <span class="cov0" title="0">privKey, err = gkm.retrieve(fpr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case strings.HasPrefix(lines[k], "uid:"):<span class="cov0" title="0">
                                uidFields := strings.Split(lines[k], ":")
                                // extract "*** Field 10 - User-ID"
                                if len(uidFields) &lt; 10 </span><span class="cov0" title="0">{
                                        break Loop</span>
                                }
                                <span class="cov0" title="0">uid = uidFields[9]</span>
                        }
                }
                // validity checking
                <span class="cov0" title="0">if privKey == nil || uid == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // collected it all
                <span class="cov0" title="0">err = consider(privKey, fpr, uid)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (gkm *GPGKeypairManager) Put(privKey PrivateKey) error <span class="cov0" title="0">{
        // NOTE: we don't need this initially at least and this keypair mgr is not for general arbitrary usage
        return fmt.Errorf("cannot import private key into GPG keyring")
}</span>

type gpgKeypairInfo struct {
        privKey     PrivateKey
        fingerprint string
}

var errKeypairNotFoundInGPGKeyring = &amp;keyNotFoundError{msg: "cannot find key pair in GPG keyring"}

func (gkm *GPGKeypairManager) findByID(keyID string) (*gpgKeypairInfo, error) <span class="cov0" title="0">{
        stop := errors.New("stop marker")
        var hit *gpgKeypairInfo
        match := func(privk PrivateKey, fpr string, uid string) error </span><span class="cov0" title="0">{
                if privk.PublicKey().ID() == keyID </span><span class="cov0" title="0">{
                        hit = &amp;gpgKeypairInfo{
                                privKey:     privk,
                                fingerprint: fpr,
                        }
                        return stop
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">err := gkm.Walk(match)
        if err == stop </span><span class="cov0" title="0">{
                return hit, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, errKeypairNotFoundInGPGKeyring</span>
}

func (gkm *GPGKeypairManager) Get(keyID string) (PrivateKey, error) <span class="cov0" title="0">{
        keyInfo, err := gkm.findByID(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return keyInfo.privKey, nil</span>
}

func (gkm *GPGKeypairManager) Delete(keyID string) error <span class="cov0" title="0">{
        keyInfo, err := gkm.findByID(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = gkm.gpg(nil, "--batch", "--delete-secret-and-public-key", "0x"+keyInfo.fingerprint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (gkm *GPGKeypairManager) sign(fingerprint string, content []byte) (*packet.Signature, error) <span class="cov0" title="0">{
        out, err := gkm.gpg(content, "--personal-digest-preferences", "SHA512", "--default-key", "0x"+fingerprint, "--detach-sign")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot sign using GPG: %v", err)
        }</span>

        <span class="cov0" title="0">const badSig = "bad GPG produced signature: "
        sigpkt, err := packet.Read(bytes.NewBuffer(out))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(badSig+"%v", err)
        }</span>

        <span class="cov0" title="0">sig, ok := sigpkt.(*packet.Signature)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(badSig+"got %T", sigpkt)
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}

func (gkm *GPGKeypairManager) findByName(name string) (*gpgKeypairInfo, error) <span class="cov0" title="0">{
        stop := errors.New("stop marker")
        var hit *gpgKeypairInfo
        match := func(privk PrivateKey, fpr string, uid string) error </span><span class="cov0" title="0">{
                if uid == name </span><span class="cov0" title="0">{
                        hit = &amp;gpgKeypairInfo{
                                privKey:     privk,
                                fingerprint: fpr,
                        }
                        return stop
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">err := gkm.Walk(match)
        if err == stop </span><span class="cov0" title="0">{
                return hit, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, errKeypairNotFoundInGPGKeyring</span>
}

// GetByName looks up a private key by name and returns it.
func (gkm *GPGKeypairManager) GetByName(name string) (PrivateKey, error) <span class="cov0" title="0">{
        keyInfo, err := gkm.findByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return keyInfo.privKey, nil</span>
}

var generateTemplate = `
Key-Type: RSA
Key-Length: 4096
Name-Real: %s
Creation-Date: seconds=%d
Preferences: SHA512
`

func (gkm *GPGKeypairManager) parametersForGenerate(passphrase string, name string) string <span class="cov0" title="0">{
        fixedCreationTime := v1FixedTimestamp.Unix()
        generateParams := fmt.Sprintf(generateTemplate, name, fixedCreationTime)
        if passphrase != "" </span><span class="cov0" title="0">{
                generateParams += "Passphrase: " + passphrase + "\n"
        }</span>
        <span class="cov0" title="0">return generateParams</span>
}

// Generate creates a new key with the given passphrase and name.
func (gkm *GPGKeypairManager) Generate(passphrase string, name string) error <span class="cov0" title="0">{
        _, err := gkm.findByName(name)
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("key named %q already exists in GPG keyring", name)
        }</span>
        <span class="cov0" title="0">generateParams := gkm.parametersForGenerate(passphrase, name)
        _, err = gkm.gpg([]byte(generateParams), "--batch", "--gen-key")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Export returns the encoded text of the named public key.
func (gkm *GPGKeypairManager) Export(name string) ([]byte, error) <span class="cov0" title="0">{
        keyInfo, err := gkm.findByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return EncodePublicKey(keyInfo.privKey.PublicKey())</span>
}

// DeleteByName removes the named key pair from GnuPG's storage.
func (gkm *GPGKeypairManager) DeleteByName(name string) error <span class="cov0" title="0">{
        keyInfo, err := gkm.findByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = gkm.gpg(nil, "--batch", "--delete-secret-and-public-key", "0x"+keyInfo.fingerprint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (gkm *GPGKeypairManager) List() (res []ExternalKeyInfo, err error) <span class="cov0" title="0">{
        collect := func(privk PrivateKey, fpr string, uid string) error </span><span class="cov0" title="0">{
                key := ExternalKeyInfo{
                        Name: uid,
                        ID:   privk.PublicKey().ID(),
                }
                res = append(res, key)
                return nil
        }</span>
        <span class="cov0" title="0">if err := gkm.Walk(collect); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2025 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "crypto"
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rsa"
        "crypto/x509"
        "encoding/asn1"
        "encoding/pem"
        "errors"
        "fmt"
        "math/big"

        "golang.org/x/crypto/sha3"
)

// HardwareIdentity holds a hardware identity assertion, which is a statement
// that verifies that identity of a physical piece of hardware
type HardwareIdentity struct {
        assertionBase

        hardwareIDKeySha3384 string
        hardwareKey          crypto.PublicKey
}

// IssuerID returns the Snap Store account of the issuer and signer of the voucher.
// This can be used to ensure the voucher has originated from a suitable source
// (e.g. the manufacturer or brand).
func (h *HardwareIdentity) IssuerID() string <span class="cov8" title="1">{
        return h.HeaderString("issuer-id")
}</span>

// Manufacturer returns the name of the device manufacturer.
func (h *HardwareIdentity) Manufacturer() string <span class="cov8" title="1">{
        return h.HeaderString("manufacturer")
}</span>

// HardwareName returns the designation of the hardware device model.
func (h *HardwareIdentity) HardwareName() string <span class="cov8" title="1">{
        return h.HeaderString("hardware-name")
}</span>

// HardwareID returns the identification of the individual hardware device.
// It is not called a serial number as there is no strict requirement that
// this value is the same as the serial number in a resulting serial assertion on the device.
func (h *HardwareIdentity) HardwareID() string <span class="cov8" title="1">{
        return h.HeaderString("hardware-id")
}</span>

// HardwareIDKey returns hardware identity public key,
// same as the body of a parsable form (PEM) as defined by RFC746813.
func (h *HardwareIdentity) HardwareIDKey() crypto.PublicKey <span class="cov8" title="1">{
        return h.hardwareKey
}</span>

// HardwareIDKeySha3384 returns the hash of the public key binary data encoded in the hardware-id-key header.
// This is included as it is used as part of the primary key for the assertion.
func (h *HardwareIdentity) HardwareIDKeySha3384() string <span class="cov8" title="1">{
        return h.hardwareIDKeySha3384
}</span>

func assembleHardwareIdentity(assert assertionBase) (Assertion, error) <span class="cov8" title="1">{
        issuerID, err := checkStringMatches(assert.headers, "issuer-id", validAccountID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if issuerID != assert.HeaderString("authority-id") </span><span class="cov8" title="1">{
                return nil, errors.New("issuer id must match authority id")
        }</span>

        <span class="cov8" title="1">_, err = checkNotEmptyString(assert.headers, "manufacturer")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = checkStringMatches(assert.headers, "hardware-name", validModel)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = checkNotEmptyString(assert.headers, "hardware-id")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hardwareIDKey, err := checkNotEmptyString(assert.headers, "hardware-id-key")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pubKey, err := checkStringIsPEM([]byte(hardwareIDKey))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hardwareIDKeySha3384 := assert.HeaderString("hardware-id-key-sha3-384")

        hash := sha3.New384()
        hash.Write([]byte(hardwareIDKey))
        hashed := hash.Sum(nil)

        // no error can be returned because the hash is initialized beforehand
        hashedHardwareIDKey, _ := EncodeDigest(crypto.SHA3_384, hashed)

        if hardwareIDKeySha3384 != hashedHardwareIDKey </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("hardware id key does not match provided hash")
        }</span>

        <span class="cov8" title="1">return &amp;HardwareIdentity{
                assertionBase:        assert,
                hardwareIDKeySha3384: hardwareIDKeySha3384,
                hardwareKey:          pubKey,
        }, nil</span>
}

// checkStringIsPEM checks if string is the body of a parsable form (PEM).
// It assumes the BEGIN and END lines are omitted. The function returns a
// a non-nil error if the strings fails to be a PEM.
func checkStringIsPEM(data []byte) (crypto.PublicKey, error) <span class="cov8" title="1">{
        // add begin and end lines to PEM body
        var bb bytes.Buffer
        bb.WriteString("-----BEGIN PUBLIC KEY-----\n")
        bb.Write(data)
        bb.WriteString("\n-----END PUBLIC KEY-----\n")

        // the PEM block can never be nil as we added begin and end lines
        block, _ := pem.Decode(bb.Bytes())
        if block == nil </span><span class="cov8" title="1">{
                return nil, errors.New("no PEM block was found")
        }</span>

        <span class="cov8" title="1">pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot parse public key: %v", err)
        }</span>

        <span class="cov8" title="1">return pubKey, nil</span>
}

// VerifyNonceSignature checks the signature of a given nonce against the hardware id key.
// It is used by the model service to verify the request-id.
// It currently supports key with algorithms RSA, ECDSA, and ED25519.
// The hash algorithm used is also specified as a parameter.
func (h *HardwareIdentity) VerifyNonceSignature(nonce, signature []byte, hashAlg crypto.Hash) error <span class="cov8" title="1">{
        if !hashAlg.Available() </span><span class="cov8" title="1">{
                return fmt.Errorf("unsupported hash type: %s", hashAlg.String())
        }</span>

        <span class="cov8" title="1">hash := hashAlg.New()

        hash.Write(nonce)
        hashed := hash.Sum(nil)

        switch keyType := h.hardwareKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov8" title="1">
                return verifySignatureWithRSAKey(hashed, signature, h.hardwareKey.(*rsa.PublicKey), hashAlg)</span>
        case *ecdsa.PublicKey:<span class="cov8" title="1">
                return verifySignatureWithECDSAKey(hashed, signature, h.hardwareKey.(*ecdsa.PublicKey))</span>
        case ed25519.PublicKey:<span class="cov8" title="1">
                return verifySignatureWithED25519Key(hashed, signature, h.hardwareKey.(ed25519.PublicKey))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported algorithm type: %s", keyType)</span>
        }
}

func verifySignatureWithRSAKey(hashed, signature []byte, pubKey *rsa.PublicKey, hashAlg crypto.Hash) error <span class="cov8" title="1">{
        return rsa.VerifyPKCS1v15(pubKey, hashAlg, hashed, signature)
}</span>

func verifySignatureWithECDSAKey(hashed, signature []byte, pubKey *ecdsa.PublicKey) error <span class="cov8" title="1">{
        // DsaSignature struct defines ASN.1 layout of ECDSA signature
        type EcdsaSignature struct {
                R, S *big.Int
        }

        var sig EcdsaSignature
        rest, err := asn1.Unmarshal(signature, &amp;sig)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Ensure all bytes were consumed
        <span class="cov8" title="1">if len(rest) &gt; 0 </span><span class="cov8" title="1">{
                return errors.New("signature invalid: trailing bytes")
        }</span>

        <span class="cov8" title="1">if !ecdsa.Verify(pubKey, hashed, sig.R, sig.S) </span><span class="cov8" title="1">{
                return errors.New("signature invalid")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func verifySignatureWithED25519Key(hashed, signature []byte, pubKey ed25519.PublicKey) error <span class="cov8" title="1">{
        if !ed25519.Verify(pubKey, hashed, signature) </span><span class="cov8" title="1">{
                return errors.New("signature invalid")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "crypto"
        "encoding/base64"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// common checks used when decoding/assembling assertions

func checkExistsString(headers map[string]any, name string) (string, error) <span class="cov0" title="0">{
        return checkExistsStringWhat(headers, name, "header")
}</span>

func checkExistsStringWhat(m map[string]any, name, what string) (string, error) <span class="cov8" title="1">{
        value, ok := m[name]
        if !ok </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%q %s is mandatory", name, what)
        }</span>
        <span class="cov8" title="1">s, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q %s must be a string", name, what)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func checkNotEmptyString(headers map[string]any, name string) (string, error) <span class="cov8" title="1">{
        return checkNotEmptyStringWhat(headers, name, "header")
}</span>

func checkNotEmptyStringWhat(m map[string]any, name, what string) (string, error) <span class="cov8" title="1">{
        s, err := checkExistsStringWhat(m, name, what)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%q %s should not be empty", name, what)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func checkOptionalStringWhat(headers map[string]any, name, what string) (string, error) <span class="cov0" title="0">{
        value, ok := headers[name]
        if !ok </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">s, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q %s must be a string", name, what)
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

func checkOptionalString(headers map[string]any, name string) (string, error) <span class="cov0" title="0">{
        return checkOptionalStringWhat(headers, name, "header")
}</span>

func checkPrimaryKey(headers map[string]any, primKey string) (string, error) <span class="cov8" title="1">{
        value, err := checkNotEmptyString(headers, primKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if strings.Contains(value, "/") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q primary key header cannot contain '/'", primKey)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

func checkAssertType(assertType *AssertionType) error <span class="cov0" title="0">{
        if assertType == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: assertion type cannot be nil")
        }</span>
        // validity check against known canonical
        <span class="cov0" title="0">validity := typeRegistry[assertType.Name]
        switch validity </span>{
        case assertType:<span class="cov0" title="0">
                // fine, matches canonical
                return nil</span>
        case nil:<span class="cov0" title="0">
                return fmt.Errorf("internal error: unknown assertion type: %q", assertType.Name)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("internal error: unpredefined assertion type for name %q used (unexpected address %p)", assertType.Name, assertType)</span>
        }
}

// use 'defl' default if missing
func checkIntWithDefault(headers map[string]any, name string, defl int) (int, error) <span class="cov8" title="1">{
        value, ok := headers[name]
        if !ok </span><span class="cov8" title="1">{
                return defl, nil
        }</span>
        <span class="cov0" title="0">s, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("%q header is not an integer: %v", name, value)
        }</span>
        <span class="cov0" title="0">m, err := atoi(s, "%q %s", name, "header")
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func checkInt(headers map[string]any, name string) (int, error) <span class="cov0" title="0">{
        return checkIntWhat(headers, name, "header")
}</span>

func checkIntWhat(headers map[string]any, name, what string) (int, error) <span class="cov0" title="0">{
        valueStr, err := checkNotEmptyStringWhat(headers, name, what)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">value, err := atoi(valueStr, "%q %s", name, what)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

type intSyntaxError string

func (e intSyntaxError) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>

func atoi(valueStr, whichFmt string, whichArgs ...any) (int, error) <span class="cov0" title="0">{
        value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                which := fmt.Sprintf(whichFmt, whichArgs...)
                if ne, ok := err.(*strconv.NumError); ok &amp;&amp; ne.Err == strconv.ErrRange </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("%s is out of range: %v", which, valueStr)
                }</span>
                <span class="cov0" title="0">return -1, intSyntaxError(fmt.Sprintf("%s is not an integer: %v", which, valueStr))</span>
        }
        <span class="cov0" title="0">if prefixZeros(valueStr) </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("%s has invalid prefix zeros: %s", fmt.Sprintf(whichFmt, whichArgs...), valueStr)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func prefixZeros(s string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(s, "0") &amp;&amp; s != "0"
}</span>

func checkRFC3339Date(headers map[string]any, name string) (time.Time, error) <span class="cov0" title="0">{
        return checkRFC3339DateWhat(headers, name, "header")
}</span>

func checkRFC3339DateWhat(m map[string]any, name, what string) (time.Time, error) <span class="cov0" title="0">{
        dateStr, err := checkNotEmptyStringWhat(m, name, what)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">date, err := time.Parse(time.RFC3339, dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("%q %s is not a RFC3339 date: %v", name, what, err)
        }</span>
        <span class="cov0" title="0">return date, nil</span>
}

func checkRFC3339DateWithDefaultWhat(m map[string]any, name, what string, defl time.Time) (time.Time, error) <span class="cov0" title="0">{
        value, ok := m[name]
        if !ok </span><span class="cov0" title="0">{
                return defl, nil
        }</span>
        <span class="cov0" title="0">dateStr, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("%q %s must be a string", name, what)
        }</span>
        <span class="cov0" title="0">date, err := time.Parse(time.RFC3339, dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("%q %s is not a RFC3339 date: %v", name, what, err)
        }</span>
        <span class="cov0" title="0">return date, nil</span>
}

func checkUint(headers map[string]any, name string, bitSize int) (uint64, error) <span class="cov0" title="0">{
        return checkUintWhat(headers, name, bitSize, "header")
}</span>

func checkUintWhat(headers map[string]any, name string, bitSize int, what string) (uint64, error) <span class="cov0" title="0">{
        valueStr, err := checkNotEmptyStringWhat(headers, name, what)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">value, err := strconv.ParseUint(valueStr, 10, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                if ne, ok := err.(*strconv.NumError); ok &amp;&amp; ne.Err == strconv.ErrRange </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("%q %s is out of range: %v", name, what, valueStr)
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("%q %s is not an unsigned integer: %v", name, what, valueStr)</span>
        }
        <span class="cov0" title="0">if prefixZeros(valueStr) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%q %s has invalid prefix zeros: %s", name, what, valueStr)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func checkDigest(headers map[string]any, name string, h crypto.Hash) (string, error) <span class="cov8" title="1">{
        return checkDigestDecWhat(headers, name, h, base64.RawURLEncoding.DecodeString, "header")
}</span>

func checkDigestDecWhat(headers map[string]any, name string, h crypto.Hash, decode func(string) ([]byte, error), what string) (string, error) <span class="cov8" title="1">{
        digestStr, err := checkNotEmptyStringWhat(headers, name, what)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">b, err := decode(digestStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q %s cannot be decoded: %v", name, what, err)
        }</span>
        <span class="cov8" title="1">if len(b) != h.Size() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q %s does not have the expected bit length: %d", name, what, len(b)*8)
        }</span>

        <span class="cov8" title="1">return digestStr, nil</span>
}

// checkStringListInMap returns the `name` entry in the `m` map as a (possibly nil) `[]string`
// if `m` has an entry for `name` and it isn't a `[]string`, an error is returned
// if pattern is not nil, all the strings must match that pattern, otherwise an error is returned
// `what` is a descriptor, used for error messages
func checkStringListInMap(m map[string]any, name, what string, pattern *regexp.Regexp) ([]string, error) <span class="cov0" title="0">{
        value, ok := m[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">lst, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s must be a list of strings", what)
        }</span>
        <span class="cov0" title="0">if len(lst) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res := make([]string, len(lst))
        for i, v := range lst </span><span class="cov0" title="0">{
                s, ok := v.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s must be a list of strings", what)
                }</span>
                <span class="cov0" title="0">if pattern != nil &amp;&amp; !pattern.MatchString(s) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s contains an invalid element: %q", what, s)
                }</span>
                <span class="cov0" title="0">res[i] = s</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func checkStringList(headers map[string]any, name string) ([]string, error) <span class="cov0" title="0">{
        return checkStringListMatches(headers, name, nil)
}</span>

func checkStringListMatches(headers map[string]any, name string, pattern *regexp.Regexp) ([]string, error) <span class="cov0" title="0">{
        return checkStringListInMap(headers, name, fmt.Sprintf("%q header", name), pattern)
}</span>

func checkStringMatches(headers map[string]any, name string, pattern *regexp.Regexp) (string, error) <span class="cov8" title="1">{
        return checkStringMatchesWhat(headers, name, "header", pattern)
}</span>

func checkStringMatchesWhat(headers map[string]any, name, what string, pattern *regexp.Regexp) (string, error) <span class="cov8" title="1">{
        s, err := checkNotEmptyStringWhat(headers, name, what)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if !pattern.MatchString(s) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%q %s contains invalid characters: %q", name, what, s)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

func checkOptionalBool(headers map[string]any, name string) (bool, error) <span class="cov0" title="0">{
        return checkOptionalBoolWhat(headers, name, "header")
}</span>

func checkOptionalBoolWhat(headers map[string]any, name, what string) (bool, error) <span class="cov0" title="0">{
        value, ok := headers[name]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">s, ok := value.(string)
        if !ok || (s != "true" &amp;&amp; s != "false") </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%q %s must be 'true' or 'false'", name, what)
        }</span>
        <span class="cov0" title="0">return s == "true", nil</span>
}

func checkMap(headers map[string]any, name string) (map[string]any, error) <span class="cov0" title="0">{
        return checkMapWhat(headers, name, "header")
}</span>

func checkMapWhat(m map[string]any, name, what string) (map[string]any, error) <span class="cov0" title="0">{
        value, ok := m[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">mv, ok := value.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q %s must be a map", name, what)
        }</span>
        <span class="cov0" title="0">return mv, nil</span>
}

func checkList(headers map[string]any, name string) ([]any, error) <span class="cov0" title="0">{
        return checkListWhat(headers, name, "header")
}</span>

func checkListWhat(m map[string]any, name, what string) ([]any, error) <span class="cov0" title="0">{
        value, ok := m[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">list, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q %s must be a list", name, what)
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "fmt"
        "regexp"
        "sort"
        "strings"
        "unicode/utf8"
)

var (
        nl   = []byte("\n")
        nlnl = []byte("\n\n")

        // for basic validity checking of header names
        headerNameValidity = regexp.MustCompile("^[a-z](?:-?[a-z0-9])*$")
)

func parseHeaders(head []byte) (map[string]any, error) <span class="cov8" title="1">{
        if !utf8.Valid(head) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("header is not utf8")
        }</span>
        <span class="cov8" title="1">headers := make(map[string]any)
        lines := strings.Split(string(head), "\n")
        for i := 0; i &lt; len(lines); </span><span class="cov8" title="1">{
                entry := lines[i]
                nameValueSplit := strings.Index(entry, ":")
                if nameValueSplit == -1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("header entry missing ':' separator: %q", entry)
                }</span>
                <span class="cov8" title="1">name := entry[:nameValueSplit]
                if !headerNameValidity.MatchString(name) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid header name: %q", name)
                }</span>

                <span class="cov8" title="1">consumed := nameValueSplit + 1
                var value any
                var err error
                value, i, err = parseEntry(consumed, i, lines, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if _, ok := headers[name]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("repeated header: %q", name)
                }</span>

                <span class="cov8" title="1">headers[name] = value</span>
        }
        <span class="cov8" title="1">return headers, nil</span>
}

const (
        commonPrefix    = "  "
        multilinePrefix = "    "
        listChar        = "-"
        listPrefix      = commonPrefix + listChar
)

func nestingPrefix(baseIndent int, prefix string) string <span class="cov0" title="0">{
        return strings.Repeat(" ", baseIndent) + prefix
}</span>

func parseEntry(consumedByIntro int, first int, lines []string, baseIndent int) (value any, firstAfter int, err error) <span class="cov8" title="1">{
        entry := lines[first]
        i := first + 1
        if consumedByIntro == len(entry) </span><span class="cov0" title="0">{
                // multiline values
                basePrefix := nestingPrefix(baseIndent, commonPrefix)
                if i &lt; len(lines) &amp;&amp; strings.HasPrefix(lines[i], basePrefix) </span><span class="cov0" title="0">{
                        rest := lines[i][len(basePrefix):]
                        if strings.HasPrefix(rest, listChar) </span><span class="cov0" title="0">{
                                // list
                                return parseList(i, lines, baseIndent)
                        }</span>
                        <span class="cov0" title="0">if len(rest) &gt; 0 &amp;&amp; rest[0] != ' ' </span><span class="cov0" title="0">{
                                // map
                                return parseMap(i, lines, baseIndent)
                        }</span>
                }

                <span class="cov0" title="0">return parseMultilineText(i, lines, baseIndent)</span>
        }

        // simple one-line value
        <span class="cov8" title="1">if entry[consumedByIntro] != ' ' </span><span class="cov0" title="0">{
                return nil, -1, fmt.Errorf("header entry should have a space or newline (for multiline) before value: %q", entry)
        }</span>

        <span class="cov8" title="1">return entry[consumedByIntro+1:], i, nil</span>
}

func parseMultilineText(first int, lines []string, baseIndent int) (value any, firstAfter int, err error) <span class="cov0" title="0">{
        size := 0
        i := first
        j := i
        prefix := nestingPrefix(baseIndent, multilinePrefix)
        for j &lt; len(lines) </span><span class="cov0" title="0">{
                iline := lines[j]
                if !strings.HasPrefix(iline, prefix) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">size += len(iline) - len(prefix) + 1
                j++</span>
        }
        <span class="cov0" title="0">if j == i </span><span class="cov0" title="0">{
                var cur string
                if i == len(lines) </span><span class="cov0" title="0">{
                        cur = "EOF"
                }</span> else<span class="cov0" title="0"> {
                        cur = fmt.Sprintf("%q", lines[i])
                }</span>
                <span class="cov0" title="0">return nil, -1, fmt.Errorf("expected %d chars nesting prefix after multiline introduction %q: %s", len(prefix), lines[i-1], cur)</span>
        }

        <span class="cov0" title="0">valueBuf := bytes.NewBuffer(make([]byte, 0, size-1))
        valueBuf.WriteString(lines[i][len(prefix):])
        i++
        for i &lt; j </span><span class="cov0" title="0">{
                valueBuf.WriteByte('\n')
                valueBuf.WriteString(lines[i][len(prefix):])
                i++
        }</span>

        <span class="cov0" title="0">return valueBuf.String(), i, nil</span>
}

func parseList(first int, lines []string, baseIndent int) (value any, firstAfter int, err error) <span class="cov0" title="0">{
        lst := []any(nil)
        j := first
        prefix := nestingPrefix(baseIndent, listPrefix)
        for j &lt; len(lines) </span><span class="cov0" title="0">{
                if !strings.HasPrefix(lines[j], prefix) </span><span class="cov0" title="0">{
                        return lst, j, nil
                }</span>
                <span class="cov0" title="0">var v any
                var err error
                v, j, err = parseEntry(len(prefix), j, lines, baseIndent+len(listPrefix)-1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, -1, err
                }</span>
                <span class="cov0" title="0">lst = append(lst, v)</span>
        }
        <span class="cov0" title="0">return lst, j, nil</span>
}

func parseMap(first int, lines []string, baseIndent int) (value any, firstAfter int, err error) <span class="cov0" title="0">{
        m := make(map[string]any)
        j := first
        prefix := nestingPrefix(baseIndent, commonPrefix)
        for j &lt; len(lines) </span><span class="cov0" title="0">{
                if !strings.HasPrefix(lines[j], prefix) </span><span class="cov0" title="0">{
                        return m, j, nil
                }</span>

                <span class="cov0" title="0">entry := lines[j][len(prefix):]
                keyValueSplit := strings.Index(entry, ":")
                if keyValueSplit == -1 </span><span class="cov0" title="0">{
                        return nil, -1, fmt.Errorf("map entry missing ':' separator: %q", entry)
                }</span>
                <span class="cov0" title="0">key := entry[:keyValueSplit]
                if !headerNameValidity.MatchString(key) </span><span class="cov0" title="0">{
                        return nil, -1, fmt.Errorf("invalid map entry key: %q", key)
                }</span>

                <span class="cov0" title="0">consumed := keyValueSplit + 1
                var value any
                var err error
                value, j, err = parseEntry(len(prefix)+consumed, j, lines, len(prefix))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, -1, err
                }</span>

                <span class="cov0" title="0">if _, ok := m[key]; ok </span><span class="cov0" title="0">{
                        return nil, -1, fmt.Errorf("repeated map entry: %q", key)
                }</span>

                <span class="cov0" title="0">m[key] = value</span>
        }
        <span class="cov0" title="0">return m, j, nil</span>
}

// checkHeader checks that the header values are strings, or nested lists or maps with strings as the only scalars
func checkHeader(v any) error <span class="cov0" title="0">{
        switch x := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return nil</span>
        case []any:<span class="cov0" title="0">
                for _, elem := range x </span><span class="cov0" title="0">{
                        err := checkHeader(elem)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        case map[string]any:<span class="cov0" title="0">
                for _, elem := range x </span><span class="cov0" title="0">{
                        err := checkHeader(elem)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("header values must be strings or nested lists or maps with strings as the only scalars: %v", v)</span>
        }
}

// checkHeaders checks that headers are of expected types
func checkHeaders(headers map[string]any) error <span class="cov0" title="0">{
        for name, value := range headers </span><span class="cov0" title="0">{
                err := checkHeader(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("header %q: %v", name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// copyHeader helps deep copying header values to defend against external mutations
func copyHeader(v any) any <span class="cov0" title="0">{
        switch x := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return x</span>
        case []any:<span class="cov0" title="0">
                res := make([]any, len(x))
                for i, elem := range x </span><span class="cov0" title="0">{
                        res[i] = copyHeader(elem)
                }</span>
                <span class="cov0" title="0">return res</span>
        case map[string]any:<span class="cov0" title="0">
                res := make(map[string]any, len(x))
                for name, value := range x </span><span class="cov0" title="0">{
                        if value == nil </span><span class="cov0" title="0">{
                                continue</span> // normalize nils out
                        }
                        <span class="cov0" title="0">res[name] = copyHeader(value)</span>
                }
                <span class="cov0" title="0">return res</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("internal error: encountered unexpected value type copying headers: %v", v))</span>
        }
}

// copyHeader helps deep copying headers to defend against external mutations
func copyHeaders(headers map[string]any) map[string]any <span class="cov0" title="0">{
        return copyHeader(headers).(map[string]any)
}</span>

func appendEntry(buf *bytes.Buffer, intro string, v any, baseIndent int) <span class="cov0" title="0">{
        switch x := v.(type) </span>{
        case nil:<span class="cov0" title="0">
                return</span> // omit
        case string:<span class="cov0" title="0">
                buf.WriteByte('\n')
                buf.WriteString(intro)
                if strings.ContainsRune(x, '\n') </span><span class="cov0" title="0">{
                        // multiline value =&gt; quote by 4-space indenting
                        buf.WriteByte('\n')
                        pfx := nestingPrefix(baseIndent, multilinePrefix)
                        buf.WriteString(pfx)
                        x = strings.Replace(x, "\n", "\n"+pfx, -1)
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteByte(' ')
                }</span>
                <span class="cov0" title="0">buf.WriteString(x)</span>
        case []any:<span class="cov0" title="0">
                if len(x) == 0 </span><span class="cov0" title="0">{
                        return // simply omit
                }</span>
                <span class="cov0" title="0">buf.WriteByte('\n')
                buf.WriteString(intro)
                pfx := nestingPrefix(baseIndent, listPrefix)
                for _, elem := range x </span><span class="cov0" title="0">{
                        appendEntry(buf, pfx, elem, baseIndent+len(listPrefix)-1)
                }</span>
        case map[string]any:<span class="cov0" title="0">
                if len(x) == 0 </span><span class="cov0" title="0">{
                        return // simply omit
                }</span>
                <span class="cov0" title="0">buf.WriteByte('\n')
                buf.WriteString(intro)
                // emit entries sorted by key
                keys := make([]string, len(x))
                i := 0
                for key := range x </span><span class="cov0" title="0">{
                        keys[i] = key
                        i++
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                pfx := nestingPrefix(baseIndent, commonPrefix)
                for _, key := range keys </span><span class="cov0" title="0">{
                        appendEntry(buf, pfx+key+":", x[key], len(pfx))
                }</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("internal error: encountered unexpected value type formatting headers: %v", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "regexp"
        "strings"
        "unicode"

        "github.com/snapcore/snapd/snap/naming"
)

// AttrMatchContext has contextual helpers for evaluating attribute constraints.
type AttrMatchContext interface {
        PlugAttr(arg string) (any, error)
        SlotAttr(arg string) (any, error)
        PlugPublisherID() string
        SlotPublisherID() string
        // This should be removed when the ContentCompatLabel feature is enabled by default.
        CompatLabelsEnabled() bool
}

const (
        // feature label for on-store/on-brand/on-model
        deviceScopeConstraintsFeature = "device-scope-constraints"
        // feature label for plug-names/slot-names constraints
        nameConstraintsFeature = "name-constraints"
)

// AttributeConstraints implements a set of constraints on the attributes of a slot or plug.
type AttributeConstraints struct {
        matcher attrMatcher
}

func (ac *AttributeConstraints) feature(flabel string) bool <span class="cov0" title="0">{
        return ac.matcher.feature(flabel)
}</span>

// compileAttributeConstraints checks and compiles a mapping or list
// from the assertion format into AttributeConstraints.
func compileAttributeConstraints(constraints any) (*AttributeConstraints, error) <span class="cov0" title="0">{
        cc := compileContext{
                opts: &amp;compileAttrMatcherOptions{
                        allowedOperations: []string{"SLOT", "PLUG", "SLOT_COMPAT", "PLUG_COMPAT"},
                        allowedRefs:       []string{"PLUG_PUBLISHER_ID", "SLOT_PUBLISHER_ID"},
                },
        }
        matcher, err := compileAttrMatcher(cc, constraints)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;AttributeConstraints{matcher: matcher}, nil</span>
}

type fixedAttrMatcher struct {
        result error
}

func (matcher fixedAttrMatcher) feature(flabel string) bool <span class="cov0" title="0">{
        return false
}</span>

func (matcher fixedAttrMatcher) match(apath string, v any, ctx *attrMatchingContext) error <span class="cov0" title="0">{
        return matcher.result
}</span>

var (
        AlwaysMatchAttributes = &amp;AttributeConstraints{matcher: fixedAttrMatcher{nil}}
        NeverMatchAttributes  = &amp;AttributeConstraints{matcher: fixedAttrMatcher{errors.New("not allowed")}}
)

// Attrer reflects part of the Attrer interface (see interfaces.Attrer).
type Attrer interface {
        Lookup(path string) (any, bool)
}

// Check checks whether attrs don't match the constraints.
func (c *AttributeConstraints) Check(attrer Attrer, helper AttrMatchContext) error <span class="cov0" title="0">{
        return c.matcher.match("", attrer, &amp;attrMatchingContext{
                attrWord: "attribute",
                helper:   helper,
        })
}</span>

// SideArityConstraint specifies a constraint for the overall arity of
// the set of connected slots for a given plug or the set of
// connected plugs for a given slot.
// It is used to express parsed slots-per-plug and plugs-per-slot
// constraints.
// See https://forum.snapcraft.io/t/plug-slot-declaration-rules-greedy-plugs/12438
type SideArityConstraint struct {
        // N can be:
        // =&gt;1
        // 0 means default and is used only internally during rule
        // compilation or on deny- rules where these constraints are
        // not applicable
        // -1 represents *, that means any (number of)
        N int
}

// Any returns whether this represents the * (any number of) constraint.
func (ac SideArityConstraint) Any() bool <span class="cov0" title="0">{
        return ac.N == -1
}</span>

func compileSideArityConstraint(context *subruleContext, which string, v any) (SideArityConstraint, error) <span class="cov0" title="0">{
        var a SideArityConstraint
        if context.installation() || !context.allow() </span><span class="cov0" title="0">{
                return a, fmt.Errorf("%s cannot specify a %s constraint, they apply only to allow-*connection", context, which)
        }</span>
        <span class="cov0" title="0">x, ok := v.(string)
        if !ok || len(x) == 0 </span><span class="cov0" title="0">{
                return a, fmt.Errorf("%s in %s must be an integer &gt;=1 or *", which, context)
        }</span>
        <span class="cov0" title="0">if x == "*" </span><span class="cov0" title="0">{
                return SideArityConstraint{N: -1}, nil
        }</span>
        <span class="cov0" title="0">n, err := atoi(x, "%s in %s", which, context)
        switch _, syntax := err.(intSyntaxError); </span>{
        case err == nil &amp;&amp; n &lt; 1:<span class="cov0" title="0">
                fallthrough</span>
        case syntax:<span class="cov0" title="0">
                return a, fmt.Errorf("%s in %s must be an integer &gt;=1 or *", which, context)</span>
        case err != nil:<span class="cov0" title="0">
                return a, err</span>
        }
        <span class="cov0" title="0">return SideArityConstraint{N: n}, nil</span>
}

type sideArityConstraintsHolder interface {
        setSlotsPerPlug(SideArityConstraint)
        setPlugsPerSlot(SideArityConstraint)

        slotsPerPlug() SideArityConstraint
        plugsPerSlot() SideArityConstraint
}

func normalizeSideArityConstraints(context *subruleContext, c sideArityConstraintsHolder) <span class="cov0" title="0">{
        if !context.allow() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">any := SideArityConstraint{N: -1}
        // normalized plugs-per-slot is always *
        c.setPlugsPerSlot(any)
        slotsPerPlug := c.slotsPerPlug()
        if context.autoConnection() </span><span class="cov0" title="0">{
                // auto-connection slots-per-plug can be any or 1
                if !slotsPerPlug.Any() </span><span class="cov0" title="0">{
                        c.setSlotsPerPlug(SideArityConstraint{N: 1})
                }</span>
        } else<span class="cov0" title="0"> {
                // connection slots-per-plug can be only any
                c.setSlotsPerPlug(any)
        }</span>
}

var (
        sideArityConstraints        = []string{"slots-per-plug", "plugs-per-slot"}
        sideArityConstraintsSetters = map[string]func(sideArityConstraintsHolder, SideArityConstraint){
                "slots-per-plug": sideArityConstraintsHolder.setSlotsPerPlug,
                "plugs-per-slot": sideArityConstraintsHolder.setPlugsPerSlot,
        }
)

// OnClassicConstraint specifies a constraint based whether the system is classic and optional specific distros' sets.
type OnClassicConstraint struct {
        Classic   bool
        SystemIDs []string
}

// OnCoreDesktopConstraint specifies a constraint based whether the system is core desktop.
type OnCoreDesktopConstraint struct {
        CoreDesktop bool
}

type nameMatcher interface {
        match(name string, special map[string]string) error
}

var (
        // validates special name constraints like $INTERFACE
        validSpecialNameConstraint = regexp.MustCompile(`^\$[A-Z][A-Z0-9_]*$`)
)

func compileNameMatcher(whichName string, v any) (nameMatcher, error) <span class="cov0" title="0">{
        s, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s constraint entry must be a regexp or special $ value", whichName)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(s, "$") </span><span class="cov0" title="0">{
                if !validSpecialNameConstraint.MatchString(s) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s constraint entry special value %q is invalid", whichName, s)
                }</span>
                <span class="cov0" title="0">return specialNameMatcher{special: s}, nil</span>
        }
        <span class="cov0" title="0">if strings.IndexFunc(s, unicode.IsSpace) != -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s constraint entry regexp contains unexpected spaces", whichName)
        }</span>
        <span class="cov0" title="0">rx, err := regexp.Compile("^(" + s + ")$")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot compile %s constraint entry %q: %v", whichName, s, err)
        }</span>
        <span class="cov0" title="0">return regexpNameMatcher{rx}, nil</span>
}

type regexpNameMatcher struct {
        *regexp.Regexp
}

func (matcher regexpNameMatcher) match(name string, special map[string]string) error <span class="cov0" title="0">{
        if !matcher.Regexp.MatchString(name) </span><span class="cov0" title="0">{
                return fmt.Errorf("%q does not match %v", name, matcher.Regexp)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type specialNameMatcher struct {
        special string
}

func (matcher specialNameMatcher) match(name string, special map[string]string) error <span class="cov0" title="0">{
        expected := special[matcher.special]
        if expected == "" || expected != name </span><span class="cov0" title="0">{
                return fmt.Errorf("%q does not match %v", name, matcher.special)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NameConstraints implements a set of constraints on the names of slots or plugs.
// See https://forum.snapcraft.io/t/plug-slot-rules-plug-names-slot-names-constraints/12439
type NameConstraints struct {
        matchers []nameMatcher
}

func compileNameConstraints(whichName string, constraints any) (*NameConstraints, error) <span class="cov0" title="0">{
        l, ok := constraints.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s constraints must be a list of regexps and special $ values", whichName)
        }</span>
        <span class="cov0" title="0">matchers := make([]nameMatcher, 0, len(l))
        for _, nm := range l </span><span class="cov0" title="0">{
                matcher, err := compileNameMatcher(whichName, nm)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">matchers = append(matchers, matcher)</span>
        }
        <span class="cov0" title="0">return &amp;NameConstraints{matchers: matchers}, nil</span>
}

// Check checks whether name doesn't match the constraints.
func (nc *NameConstraints) Check(whichName, name string, special map[string]string) error <span class="cov0" title="0">{
        for _, m := range nc.matchers </span><span class="cov0" title="0">{
                if err := m.match(name, special); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("%s %q does not match constraints", whichName, name)</span>
}

// rules

var (
        validSnapType  = regexp.MustCompile(`^(?:core|kernel|gadget|app)$`)
        validDistro    = regexp.MustCompile(`^[-0-9a-z._]+$`)
        validPublisher = regexp.MustCompile(`^(?:[a-z0-9A-Z]{32}|[-a-z0-9]{2,28}|\$[A-Z][A-Z0-9_]*)$`) // account ids look like snap-ids or are nice identifiers, support our own special markers $MARKER

        validIDConstraints = map[string]*regexp.Regexp{
                "slot-snap-type":    validSnapType,
                "slot-snap-id":      naming.ValidSnapID,
                "slot-publisher-id": validPublisher,
                "plug-snap-type":    validSnapType,
                "plug-snap-id":      naming.ValidSnapID,
                "plug-publisher-id": validPublisher,
        }
)

func checkMapOrShortcut(v any) (m map[string]any, invert bool, err error) <span class="cov0" title="0">{
        switch x := v.(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                return x, false, nil</span>
        case string:<span class="cov0" title="0">
                switch x </span>{
                case "true":<span class="cov0" title="0">
                        return nil, false, nil</span>
                case "false":<span class="cov0" title="0">
                        return nil, true, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, false, errors.New("unexpected type")</span>
}

type constraintsHolder interface {
        setNameConstraints(field string, cstrs *NameConstraints)
        setAttributeConstraints(field string, cstrs *AttributeConstraints)
        setIDConstraints(field string, cstrs []string)
        setOnClassicConstraint(onClassic *OnClassicConstraint)
        setOnCoreDesktopConstraint(onCoreDesktop *OnCoreDesktopConstraint)
        setDeviceScopeConstraint(deviceScope *DeviceScopeConstraint)
}

func baseCompileConstraints(context *subruleContext, cDef constraintsDef, target constraintsHolder, nameConstraints, attrConstraints, idConstraints []string) error <span class="cov0" title="0">{
        cMap := cDef.cMap
        if cMap == nil </span><span class="cov0" title="0">{
                fixed := AlwaysMatchAttributes // "true"
                if cDef.invert </span><span class="cov0" title="0">{               // "false"
                        fixed = NeverMatchAttributes
                }</span>
                <span class="cov0" title="0">for _, field := range attrConstraints </span><span class="cov0" title="0">{
                        target.setAttributeConstraints(field, fixed)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">defaultUsed := 0
        for _, field := range nameConstraints </span><span class="cov0" title="0">{
                v := cMap[field]
                if v != nil </span><span class="cov0" title="0">{
                        nc, err := compileNameConstraints(field, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">target.setNameConstraints(field, nc)</span>
                } else<span class="cov0" title="0"> {
                        defaultUsed++
                }</span>
        }
        <span class="cov0" title="0">for _, field := range attrConstraints </span><span class="cov0" title="0">{
                cstrs := AlwaysMatchAttributes
                v := cMap[field]
                if v != nil </span><span class="cov0" title="0">{
                        var err error
                        cstrs, err = compileAttributeConstraints(cMap[field])
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot compile %s in %s: %v", field, context, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        defaultUsed++
                }</span>
                <span class="cov0" title="0">target.setAttributeConstraints(field, cstrs)</span>
        }
        <span class="cov0" title="0">for _, field := range idConstraints </span><span class="cov0" title="0">{
                lst, err := checkStringListInMap(cMap, field, fmt.Sprintf("%s in %s", field, context), validIDConstraints[field])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if lst == nil </span><span class="cov0" title="0">{
                        defaultUsed++
                }</span>
                <span class="cov0" title="0">target.setIDConstraints(field, lst)</span>
        }
        <span class="cov0" title="0">for _, field := range sideArityConstraints </span><span class="cov0" title="0">{
                v := cMap[field]
                if v != nil </span><span class="cov0" title="0">{
                        c, err := compileSideArityConstraint(context, field, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">h, ok := target.(sideArityConstraintsHolder)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("internal error: side arity constraint compiled for unexpected subrule %T", target)
                        }</span>
                        <span class="cov0" title="0">sideArityConstraintsSetters[field](h, c)</span>
                } else<span class="cov0" title="0"> {
                        defaultUsed++
                }</span>
        }
        <span class="cov0" title="0">onClassic := cMap["on-classic"]
        if onClassic == nil </span><span class="cov0" title="0">{
                defaultUsed++
        }</span> else<span class="cov0" title="0"> {
                var c *OnClassicConstraint
                switch x := onClassic.(type) </span>{
                case string:<span class="cov0" title="0">
                        switch x </span>{
                        case "true":<span class="cov0" title="0">
                                c = &amp;OnClassicConstraint{Classic: true}</span>
                        case "false":<span class="cov0" title="0">
                                c = &amp;OnClassicConstraint{Classic: false}</span>
                        }
                case []any:<span class="cov0" title="0">
                        lst, err := checkStringListInMap(cMap, "on-classic", fmt.Sprintf("on-classic in %s", context), validDistro)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">c = &amp;OnClassicConstraint{Classic: true, SystemIDs: lst}</span>
                }
                <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("on-classic in %s must be 'true', 'false' or a list of operating system IDs", context)
                }</span>
                <span class="cov0" title="0">target.setOnClassicConstraint(c)</span>
        }
        <span class="cov0" title="0">onCoreDesktop := cMap["on-core-desktop"]
        if onCoreDesktop == nil </span><span class="cov0" title="0">{
                defaultUsed++
        }</span> else<span class="cov0" title="0"> {
                var c *OnCoreDesktopConstraint
                switch x := onCoreDesktop.(type) </span>{
                case string:<span class="cov0" title="0">
                        switch x </span>{
                        case "true":<span class="cov0" title="0">
                                c = &amp;OnCoreDesktopConstraint{CoreDesktop: true}</span>
                        case "false":<span class="cov0" title="0">
                                c = &amp;OnCoreDesktopConstraint{CoreDesktop: false}</span>
                        }
                }
                <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("on-core-desktop in %s must be 'true' or 'false'", context)
                }</span>
                <span class="cov0" title="0">target.setOnCoreDesktopConstraint(c)</span>
        }
        <span class="cov0" title="0">dsc, err := compileDeviceScopeConstraint(cMap, context.String())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if dsc == nil </span><span class="cov0" title="0">{
                defaultUsed++
        }</span> else<span class="cov0" title="0"> {
                target.setDeviceScopeConstraint(dsc)
        }</span>
        // checks whether defaults have been used for everything, which is not
        // well-formed
        // +1+1+1 accounts for defaults for missing on-classic, on-core-desktop plus missing
        // on-store/on-brand/on-model
        <span class="cov0" title="0">if defaultUsed == len(nameConstraints)+len(attributeConstraints)+len(idConstraints)+len(sideArityConstraints)+1+1+1 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s must specify at least one of %s, %s, %s, %s, on-classic, on-core-desktop, on-store, on-brand, on-model", context, strings.Join(nameConstraints, ", "), strings.Join(attrConstraints, ", "), strings.Join(idConstraints, ", "), strings.Join(sideArityConstraints, ", "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type rule interface {
        setConstraints(field string, cstrs []constraintsHolder)
}

type constraintsDef struct {
        cMap   map[string]any
        invert bool
}

// subruleContext carries queryable context information about one the
// {allow,deny}-* subrules that end up compiled as
// Plug|Slot*Constraints.  The information includes the parent rule,
// the introductory subrule key ({allow,deny}-*) and which alternative
// it corresponds to if any.
// The information is useful for constraints compilation now that we
// have constraints with different behavior depending on the kind of
// subrule that hosts them (e.g. slots-per-plug, plugs-per-slot).
type subruleContext struct {
        // rule is the parent rule context description
        rule string
        // subrule is the subrule key
        subrule string
        // alt is which alternative this is (if &gt; 0)
        alt int
}

func (c *subruleContext) String() string <span class="cov0" title="0">{
        subctxt := fmt.Sprintf("%s in %s", c.subrule, c.rule)
        if c.alt != 0 </span><span class="cov0" title="0">{
                subctxt = fmt.Sprintf("alternative %d of %s", c.alt, subctxt)
        }</span>
        <span class="cov0" title="0">return subctxt</span>
}

// allow returns whether the subrule is an allow-* subrule.
func (c *subruleContext) allow() bool <span class="cov0" title="0">{
        return strings.HasPrefix(c.subrule, "allow-")
}</span>

// installation returns whether the subrule is an *-installation subrule.
func (c *subruleContext) installation() bool <span class="cov0" title="0">{
        return strings.HasSuffix(c.subrule, "-installation")
}</span>

// autoConnection returns whether the subrule is an *-auto-connection subrule.
func (c *subruleContext) autoConnection() bool <span class="cov0" title="0">{
        return strings.HasSuffix(c.subrule, "-auto-connection")
}</span>

type subruleCompiler func(context *subruleContext, def constraintsDef) (constraintsHolder, error)

func baseCompileRule(context string, rule any, target rule, subrules []string, compilers map[string]subruleCompiler, defaultOutcome, invertedOutcome map[string]any) error <span class="cov0" title="0">{
        rMap, invert, err := checkMapOrShortcut(rule)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s must be a map or one of the shortcuts 'true' or 'false'", context)
        }</span>
        <span class="cov0" title="0">if rMap == nil </span><span class="cov0" title="0">{
                rMap = defaultOutcome // "true"
                if invert </span><span class="cov0" title="0">{
                        rMap = invertedOutcome // "false"
                }</span>
        }
        <span class="cov0" title="0">defaultUsed := 0
        // compile and set subrules
        for _, subrule := range subrules </span><span class="cov0" title="0">{
                v := rMap[subrule]
                var lst []any
                alternatives := false
                switch x := v.(type) </span>{
                case nil:<span class="cov0" title="0">
                        v = defaultOutcome[subrule]
                        defaultUsed++</span>
                case []any:<span class="cov0" title="0">
                        alternatives = true
                        lst = x</span>
                }
                <span class="cov0" title="0">if lst == nil </span><span class="cov0" title="0">{ // v is map or a string, checked below
                        lst = []any{v}
                }</span>
                <span class="cov0" title="0">compiler := compilers[subrule]
                if compiler == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("no compiler for %s in %s", subrule, context))</span>
                }
                <span class="cov0" title="0">alts := make([]constraintsHolder, len(lst))
                for i, alt := range lst </span><span class="cov0" title="0">{
                        subctxt := &amp;subruleContext{
                                rule:    context,
                                subrule: subrule,
                        }
                        if alternatives </span><span class="cov0" title="0">{
                                subctxt.alt = i + 1
                        }</span>
                        <span class="cov0" title="0">cMap, invert, err := checkMapOrShortcut(alt)
                        if err != nil || (cMap == nil &amp;&amp; alternatives) </span><span class="cov0" title="0">{
                                efmt := "%s must be a map"
                                if !alternatives </span><span class="cov0" title="0">{
                                        efmt = "%s must be a map or one of the shortcuts 'true' or 'false'"
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf(efmt, subctxt)</span>
                        }

                        <span class="cov0" title="0">cstrs, err := compiler(subctxt, constraintsDef{
                                cMap:   cMap,
                                invert: invert,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">alts[i] = cstrs</span>
                }
                <span class="cov0" title="0">target.setConstraints(subrule, alts)</span>
        }
        <span class="cov0" title="0">if defaultUsed == len(subrules) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s must specify at least one of %s", context, strings.Join(subrules, ", "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PlugRule holds the rule of what is allowed, wrt installation and
// connection, for a plug of a specific interface for a snap.
type PlugRule struct {
        Interface string

        AllowInstallation []*PlugInstallationConstraints
        DenyInstallation  []*PlugInstallationConstraints

        AllowConnection []*PlugConnectionConstraints
        DenyConnection  []*PlugConnectionConstraints

        AllowAutoConnection []*PlugConnectionConstraints
        DenyAutoConnection  []*PlugConnectionConstraints
}

func (r *PlugRule) feature(flabel string) bool <span class="cov0" title="0">{
        for _, cs := range [][]*PlugInstallationConstraints{r.AllowInstallation, r.DenyInstallation} </span><span class="cov0" title="0">{
                for _, c := range cs </span><span class="cov0" title="0">{
                        if c.feature(flabel) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, cs := range [][]*PlugConnectionConstraints{r.AllowConnection, r.DenyConnection, r.AllowAutoConnection, r.DenyAutoConnection} </span><span class="cov0" title="0">{
                for _, c := range cs </span><span class="cov0" title="0">{
                        if c.feature(flabel) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func castPlugInstallationConstraints(cstrs []constraintsHolder) (res []*PlugInstallationConstraints) <span class="cov0" title="0">{
        res = make([]*PlugInstallationConstraints, len(cstrs))
        for i, cstr := range cstrs </span><span class="cov0" title="0">{
                res[i] = cstr.(*PlugInstallationConstraints)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func castPlugConnectionConstraints(cstrs []constraintsHolder) (res []*PlugConnectionConstraints) <span class="cov0" title="0">{
        res = make([]*PlugConnectionConstraints, len(cstrs))
        for i, cstr := range cstrs </span><span class="cov0" title="0">{
                res[i] = cstr.(*PlugConnectionConstraints)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (r *PlugRule) setConstraints(field string, cstrs []constraintsHolder) <span class="cov0" title="0">{
        if len(cstrs) == 0 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("cannot set PlugRule field %q to empty", field))</span>
        }
        <span class="cov0" title="0">switch cstrs[0].(type) </span>{
        case *PlugInstallationConstraints:<span class="cov0" title="0">
                switch field </span>{
                case "allow-installation":<span class="cov0" title="0">
                        r.AllowInstallation = castPlugInstallationConstraints(cstrs)
                        return</span>
                case "deny-installation":<span class="cov0" title="0">
                        r.DenyInstallation = castPlugInstallationConstraints(cstrs)
                        return</span>
                }
        case *PlugConnectionConstraints:<span class="cov0" title="0">
                switch field </span>{
                case "allow-connection":<span class="cov0" title="0">
                        r.AllowConnection = castPlugConnectionConstraints(cstrs)
                        return</span>
                case "deny-connection":<span class="cov0" title="0">
                        r.DenyConnection = castPlugConnectionConstraints(cstrs)
                        return</span>
                case "allow-auto-connection":<span class="cov0" title="0">
                        r.AllowAutoConnection = castPlugConnectionConstraints(cstrs)
                        return</span>
                case "deny-auto-connection":<span class="cov0" title="0">
                        r.DenyAutoConnection = castPlugConnectionConstraints(cstrs)
                        return</span>
                }
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("cannot set PlugRule field %q with %T elements", field, cstrs[0]))</span>
}

// PlugInstallationConstraints specifies a set of constraints on an interface plug relevant to the installation of snap.
type PlugInstallationConstraints struct {
        PlugSnapTypes []string
        PlugSnapIDs   []string

        PlugNames *NameConstraints

        PlugAttributes *AttributeConstraints

        OnClassic     *OnClassicConstraint
        OnCoreDesktop *OnCoreDesktopConstraint

        DeviceScope *DeviceScopeConstraint
}

func (c *PlugInstallationConstraints) feature(flabel string) bool <span class="cov0" title="0">{
        if flabel == deviceScopeConstraintsFeature </span><span class="cov0" title="0">{
                return c.DeviceScope != nil
        }</span>
        <span class="cov0" title="0">if flabel == nameConstraintsFeature </span><span class="cov0" title="0">{
                return c.PlugNames != nil
        }</span>
        <span class="cov0" title="0">return c.PlugAttributes.feature(flabel)</span>
}

func (c *PlugInstallationConstraints) setNameConstraints(field string, cstrs *NameConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-names":<span class="cov0" title="0">
                c.PlugNames = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugInstallationConstraints field " + field)</span>
        }
}

func (c *PlugInstallationConstraints) setAttributeConstraints(field string, cstrs *AttributeConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-attributes":<span class="cov0" title="0">
                c.PlugAttributes = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugInstallationConstraints field " + field)</span>
        }
}

func (c *PlugInstallationConstraints) setIDConstraints(field string, cstrs []string) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-snap-type":<span class="cov0" title="0">
                c.PlugSnapTypes = cstrs</span>
        case "plug-snap-id":<span class="cov0" title="0">
                c.PlugSnapIDs = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugInstallationConstraints field " + field)</span>
        }
}

func (c *PlugInstallationConstraints) setOnClassicConstraint(onClassic *OnClassicConstraint) <span class="cov0" title="0">{
        c.OnClassic = onClassic
}</span>

func (c *PlugInstallationConstraints) setOnCoreDesktopConstraint(onCoreDesktop *OnCoreDesktopConstraint) <span class="cov0" title="0">{
        c.OnCoreDesktop = onCoreDesktop
}</span>

func (c *PlugInstallationConstraints) setDeviceScopeConstraint(deviceScope *DeviceScopeConstraint) <span class="cov0" title="0">{
        c.DeviceScope = deviceScope
}</span>

func compilePlugInstallationConstraints(context *subruleContext, cDef constraintsDef) (constraintsHolder, error) <span class="cov0" title="0">{
        plugInstCstrs := &amp;PlugInstallationConstraints{}
        // plug-snap-id is supported here mainly for symmetry with the slot case
        // see discussion there
        err := baseCompileConstraints(context, cDef, plugInstCstrs, []string{"plug-names"}, []string{"plug-attributes"}, []string{"plug-snap-type", "plug-snap-id"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return plugInstCstrs, nil</span>
}

// PlugConnectionConstraints specfies a set of constraints on an
// interface plug for a snap relevant to its connection or
// auto-connection.
type PlugConnectionConstraints struct {
        SlotSnapTypes    []string
        SlotSnapIDs      []string
        SlotPublisherIDs []string

        PlugNames *NameConstraints
        SlotNames *NameConstraints

        PlugAttributes *AttributeConstraints
        SlotAttributes *AttributeConstraints

        // SlotsPerPlug defaults to 1 for auto-connection, can be * (any)
        SlotsPerPlug SideArityConstraint
        // PlugsPerSlot is always * (any) (for now)
        PlugsPerSlot SideArityConstraint

        OnClassic     *OnClassicConstraint
        OnCoreDesktop *OnCoreDesktopConstraint

        DeviceScope *DeviceScopeConstraint
}

func (c *PlugConnectionConstraints) feature(flabel string) bool <span class="cov0" title="0">{
        if flabel == deviceScopeConstraintsFeature </span><span class="cov0" title="0">{
                return c.DeviceScope != nil
        }</span>
        <span class="cov0" title="0">if flabel == nameConstraintsFeature </span><span class="cov0" title="0">{
                return c.PlugNames != nil || c.SlotNames != nil
        }</span>
        <span class="cov0" title="0">return c.PlugAttributes.feature(flabel) || c.SlotAttributes.feature(flabel)</span>
}

func (c *PlugConnectionConstraints) setNameConstraints(field string, cstrs *NameConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-names":<span class="cov0" title="0">
                c.PlugNames = cstrs</span>
        case "slot-names":<span class="cov0" title="0">
                c.SlotNames = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugConnectionConstraints field " + field)</span>
        }
}

func (c *PlugConnectionConstraints) setAttributeConstraints(field string, cstrs *AttributeConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-attributes":<span class="cov0" title="0">
                c.PlugAttributes = cstrs</span>
        case "slot-attributes":<span class="cov0" title="0">
                c.SlotAttributes = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugConnectionConstraints field " + field)</span>
        }
}

func (c *PlugConnectionConstraints) setIDConstraints(field string, cstrs []string) <span class="cov0" title="0">{
        switch field </span>{
        case "slot-snap-type":<span class="cov0" title="0">
                c.SlotSnapTypes = cstrs</span>
        case "slot-snap-id":<span class="cov0" title="0">
                c.SlotSnapIDs = cstrs</span>
        case "slot-publisher-id":<span class="cov0" title="0">
                c.SlotPublisherIDs = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown PlugConnectionConstraints field " + field)</span>
        }
}

func (c *PlugConnectionConstraints) setSlotsPerPlug(a SideArityConstraint) <span class="cov0" title="0">{
        c.SlotsPerPlug = a
}</span>

func (c *PlugConnectionConstraints) setPlugsPerSlot(a SideArityConstraint) <span class="cov0" title="0">{
        c.PlugsPerSlot = a
}</span>

func (c *PlugConnectionConstraints) slotsPerPlug() SideArityConstraint <span class="cov0" title="0">{
        return c.SlotsPerPlug
}</span>

func (c *PlugConnectionConstraints) plugsPerSlot() SideArityConstraint <span class="cov0" title="0">{
        return c.PlugsPerSlot
}</span>

func (c *PlugConnectionConstraints) setOnClassicConstraint(onClassic *OnClassicConstraint) <span class="cov0" title="0">{
        c.OnClassic = onClassic
}</span>

func (c *PlugConnectionConstraints) setOnCoreDesktopConstraint(onCoreDesktop *OnCoreDesktopConstraint) <span class="cov0" title="0">{
        c.OnCoreDesktop = onCoreDesktop
}</span>

func (c *PlugConnectionConstraints) setDeviceScopeConstraint(deviceScope *DeviceScopeConstraint) <span class="cov0" title="0">{
        c.DeviceScope = deviceScope
}</span>

var (
        nameConstraints      = []string{"plug-names", "slot-names"}
        attributeConstraints = []string{"plug-attributes", "slot-attributes"}
        plugIDConstraints    = []string{"slot-snap-type", "slot-publisher-id", "slot-snap-id"}
)

func compilePlugConnectionConstraints(context *subruleContext, cDef constraintsDef) (constraintsHolder, error) <span class="cov0" title="0">{
        plugConnCstrs := &amp;PlugConnectionConstraints{}
        err := baseCompileConstraints(context, cDef, plugConnCstrs, nameConstraints, attributeConstraints, plugIDConstraints)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">normalizeSideArityConstraints(context, plugConnCstrs)
        return plugConnCstrs, nil</span>
}

var (
        defaultOutcome = map[string]any{
                "allow-installation":    "true",
                "allow-connection":      "true",
                "allow-auto-connection": "true",
                "deny-installation":     "false",
                "deny-connection":       "false",
                "deny-auto-connection":  "false",
        }

        invertedOutcome = map[string]any{
                "allow-installation":    "false",
                "allow-connection":      "false",
                "allow-auto-connection": "false",
                "deny-installation":     "true",
                "deny-connection":       "true",
                "deny-auto-connection":  "true",
        }

        ruleSubrules = []string{"allow-installation", "deny-installation", "allow-connection", "deny-connection", "allow-auto-connection", "deny-auto-connection"}
)

var plugRuleCompilers = map[string]subruleCompiler{
        "allow-installation":    compilePlugInstallationConstraints,
        "deny-installation":     compilePlugInstallationConstraints,
        "allow-connection":      compilePlugConnectionConstraints,
        "deny-connection":       compilePlugConnectionConstraints,
        "allow-auto-connection": compilePlugConnectionConstraints,
        "deny-auto-connection":  compilePlugConnectionConstraints,
}

func compilePlugRule(interfaceName string, rule any) (*PlugRule, error) <span class="cov0" title="0">{
        context := fmt.Sprintf("plug rule for interface %q", interfaceName)
        plugRule := &amp;PlugRule{
                Interface: interfaceName,
        }
        err := baseCompileRule(context, rule, plugRule, ruleSubrules, plugRuleCompilers, defaultOutcome, invertedOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return plugRule, nil</span>
}

// SlotRule holds the rule of what is allowed, wrt installation and
// connection, for a slot of a specific interface for a snap.
type SlotRule struct {
        Interface string

        AllowInstallation []*SlotInstallationConstraints
        DenyInstallation  []*SlotInstallationConstraints

        AllowConnection []*SlotConnectionConstraints
        DenyConnection  []*SlotConnectionConstraints

        AllowAutoConnection []*SlotConnectionConstraints
        DenyAutoConnection  []*SlotConnectionConstraints
}

func castSlotInstallationConstraints(cstrs []constraintsHolder) (res []*SlotInstallationConstraints) <span class="cov0" title="0">{
        res = make([]*SlotInstallationConstraints, len(cstrs))
        for i, cstr := range cstrs </span><span class="cov0" title="0">{
                res[i] = cstr.(*SlotInstallationConstraints)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (r *SlotRule) feature(flabel string) bool <span class="cov0" title="0">{
        for _, cs := range [][]*SlotInstallationConstraints{r.AllowInstallation, r.DenyInstallation} </span><span class="cov0" title="0">{
                for _, c := range cs </span><span class="cov0" title="0">{
                        if c.feature(flabel) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, cs := range [][]*SlotConnectionConstraints{r.AllowConnection, r.DenyConnection, r.AllowAutoConnection, r.DenyAutoConnection} </span><span class="cov0" title="0">{
                for _, c := range cs </span><span class="cov0" title="0">{
                        if c.feature(flabel) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func castSlotConnectionConstraints(cstrs []constraintsHolder) (res []*SlotConnectionConstraints) <span class="cov0" title="0">{
        res = make([]*SlotConnectionConstraints, len(cstrs))
        for i, cstr := range cstrs </span><span class="cov0" title="0">{
                res[i] = cstr.(*SlotConnectionConstraints)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (r *SlotRule) setConstraints(field string, cstrs []constraintsHolder) <span class="cov0" title="0">{
        if len(cstrs) == 0 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("cannot set SlotRule field %q to empty", field))</span>
        }
        <span class="cov0" title="0">switch cstrs[0].(type) </span>{
        case *SlotInstallationConstraints:<span class="cov0" title="0">
                switch field </span>{
                case "allow-installation":<span class="cov0" title="0">
                        r.AllowInstallation = castSlotInstallationConstraints(cstrs)
                        return</span>
                case "deny-installation":<span class="cov0" title="0">
                        r.DenyInstallation = castSlotInstallationConstraints(cstrs)
                        return</span>
                }
        case *SlotConnectionConstraints:<span class="cov0" title="0">
                switch field </span>{
                case "allow-connection":<span class="cov0" title="0">
                        r.AllowConnection = castSlotConnectionConstraints(cstrs)
                        return</span>
                case "deny-connection":<span class="cov0" title="0">
                        r.DenyConnection = castSlotConnectionConstraints(cstrs)
                        return</span>
                case "allow-auto-connection":<span class="cov0" title="0">
                        r.AllowAutoConnection = castSlotConnectionConstraints(cstrs)
                        return</span>
                case "deny-auto-connection":<span class="cov0" title="0">
                        r.DenyAutoConnection = castSlotConnectionConstraints(cstrs)
                        return</span>
                }
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("cannot set SlotRule field %q with %T elements", field, cstrs[0]))</span>
}

// SlotInstallationConstraints specifies a set of constraints on an
// interface slot relevant to the installation of snap.
type SlotInstallationConstraints struct {
        SlotSnapTypes []string
        SlotSnapIDs   []string

        SlotNames *NameConstraints

        SlotAttributes *AttributeConstraints

        OnClassic     *OnClassicConstraint
        OnCoreDesktop *OnCoreDesktopConstraint

        DeviceScope *DeviceScopeConstraint
}

func (c *SlotInstallationConstraints) feature(flabel string) bool <span class="cov0" title="0">{
        if flabel == deviceScopeConstraintsFeature </span><span class="cov0" title="0">{
                return c.DeviceScope != nil
        }</span>
        <span class="cov0" title="0">if flabel == nameConstraintsFeature </span><span class="cov0" title="0">{
                return c.SlotNames != nil
        }</span>
        <span class="cov0" title="0">return c.SlotAttributes.feature(flabel)</span>
}

func (c *SlotInstallationConstraints) setNameConstraints(field string, cstrs *NameConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "slot-names":<span class="cov0" title="0">
                c.SlotNames = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotInstallationConstraints field " + field)</span>
        }
}

func (c *SlotInstallationConstraints) setAttributeConstraints(field string, cstrs *AttributeConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "slot-attributes":<span class="cov0" title="0">
                c.SlotAttributes = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotInstallationConstraints field " + field)</span>
        }
}

func (c *SlotInstallationConstraints) setIDConstraints(field string, cstrs []string) <span class="cov0" title="0">{
        switch field </span>{
        case "slot-snap-type":<span class="cov0" title="0">
                c.SlotSnapTypes = cstrs</span>
        case "slot-snap-id":<span class="cov0" title="0">
                c.SlotSnapIDs = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotInstallationConstraints field " + field)</span>
        }
}

func (c *SlotInstallationConstraints) setOnClassicConstraint(onClassic *OnClassicConstraint) <span class="cov0" title="0">{
        c.OnClassic = onClassic
}</span>

func (c *SlotInstallationConstraints) setOnCoreDesktopConstraint(onCoreDesktop *OnCoreDesktopConstraint) <span class="cov0" title="0">{
        c.OnCoreDesktop = onCoreDesktop
}</span>

func (c *SlotInstallationConstraints) setDeviceScopeConstraint(deviceScope *DeviceScopeConstraint) <span class="cov0" title="0">{
        c.DeviceScope = deviceScope
}</span>

func compileSlotInstallationConstraints(context *subruleContext, cDef constraintsDef) (constraintsHolder, error) <span class="cov0" title="0">{
        slotInstCstrs := &amp;SlotInstallationConstraints{}
        // slot-snap-id here is mostly useful to restrict a relaxed
        // base-declaration slot-snap-type constraint because the latter is used
        // also for --dangerous installations. So in rare complex situations
        // slot-snap-type might constraint to core and app
        // but the intention is really that only system snaps should have the
        // slot without a snap-declaration rule, slot-snap-id then can
        // be used to limit to the known system snap snap-ids.
        // This means we want app-slots to be super-privileged but we have
        // slots for the interface on the system snaps as well.
        // An example of this is shared-memory.
        err := baseCompileConstraints(context, cDef, slotInstCstrs, []string{"slot-names"}, []string{"slot-attributes"}, []string{"slot-snap-type", "slot-snap-id"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return slotInstCstrs, nil</span>
}

// SlotConnectionConstraints specfies a set of constraints on an
// interface slot for a snap relevant to its connection or
// auto-connection.
type SlotConnectionConstraints struct {
        // SlotSnapTypes constraints on the slot side for connections
        // are only useful in the base-declaration,
        // as the snap-declaration is for one given snap with its type.
        // So there is no (new) format iteration to cover this.
        SlotSnapTypes []string

        PlugSnapTypes    []string
        PlugSnapIDs      []string
        PlugPublisherIDs []string

        SlotNames *NameConstraints
        PlugNames *NameConstraints

        SlotAttributes *AttributeConstraints
        PlugAttributes *AttributeConstraints

        // SlotsPerPlug defaults to 1 for auto-connection, can be * (any)
        SlotsPerPlug SideArityConstraint
        // PlugsPerSlot is always * (any) (for now)
        PlugsPerSlot SideArityConstraint

        OnClassic     *OnClassicConstraint
        OnCoreDesktop *OnCoreDesktopConstraint

        DeviceScope *DeviceScopeConstraint
}

func (c *SlotConnectionConstraints) feature(flabel string) bool <span class="cov0" title="0">{
        if flabel == deviceScopeConstraintsFeature </span><span class="cov0" title="0">{
                return c.DeviceScope != nil
        }</span>
        <span class="cov0" title="0">if flabel == nameConstraintsFeature </span><span class="cov0" title="0">{
                return c.PlugNames != nil || c.SlotNames != nil
        }</span>
        <span class="cov0" title="0">return c.PlugAttributes.feature(flabel) || c.SlotAttributes.feature(flabel)</span>
}

func (c *SlotConnectionConstraints) setNameConstraints(field string, cstrs *NameConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-names":<span class="cov0" title="0">
                c.PlugNames = cstrs</span>
        case "slot-names":<span class="cov0" title="0">
                c.SlotNames = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotConnectionConstraints field " + field)</span>
        }
}

func (c *SlotConnectionConstraints) setAttributeConstraints(field string, cstrs *AttributeConstraints) <span class="cov0" title="0">{
        switch field </span>{
        case "plug-attributes":<span class="cov0" title="0">
                c.PlugAttributes = cstrs</span>
        case "slot-attributes":<span class="cov0" title="0">
                c.SlotAttributes = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotConnectionConstraints field " + field)</span>
        }
}

func (c *SlotConnectionConstraints) setIDConstraints(field string, cstrs []string) <span class="cov0" title="0">{
        switch field </span>{
        case "slot-snap-type":<span class="cov0" title="0">
                c.SlotSnapTypes = cstrs</span>
        case "plug-snap-type":<span class="cov0" title="0">
                c.PlugSnapTypes = cstrs</span>
        case "plug-snap-id":<span class="cov0" title="0">
                c.PlugSnapIDs = cstrs</span>
        case "plug-publisher-id":<span class="cov0" title="0">
                c.PlugPublisherIDs = cstrs</span>
        default:<span class="cov0" title="0">
                panic("unknown SlotConnectionConstraints field " + field)</span>
        }
}

var (
        slotIDConstraints = []string{"slot-snap-type", "plug-snap-type", "plug-publisher-id", "plug-snap-id"}
)

func (c *SlotConnectionConstraints) setSlotsPerPlug(a SideArityConstraint) <span class="cov0" title="0">{
        c.SlotsPerPlug = a
}</span>

func (c *SlotConnectionConstraints) setPlugsPerSlot(a SideArityConstraint) <span class="cov0" title="0">{
        c.PlugsPerSlot = a
}</span>

func (c *SlotConnectionConstraints) slotsPerPlug() SideArityConstraint <span class="cov0" title="0">{
        return c.SlotsPerPlug
}</span>

func (c *SlotConnectionConstraints) plugsPerSlot() SideArityConstraint <span class="cov0" title="0">{
        return c.PlugsPerSlot
}</span>

func (c *SlotConnectionConstraints) setOnClassicConstraint(onClassic *OnClassicConstraint) <span class="cov0" title="0">{
        c.OnClassic = onClassic
}</span>

func (c *SlotConnectionConstraints) setOnCoreDesktopConstraint(onCoreDesktop *OnCoreDesktopConstraint) <span class="cov0" title="0">{
        c.OnCoreDesktop = onCoreDesktop
}</span>

func (c *SlotConnectionConstraints) setDeviceScopeConstraint(deviceScope *DeviceScopeConstraint) <span class="cov0" title="0">{
        c.DeviceScope = deviceScope
}</span>

func compileSlotConnectionConstraints(context *subruleContext, cDef constraintsDef) (constraintsHolder, error) <span class="cov0" title="0">{
        slotConnCstrs := &amp;SlotConnectionConstraints{}
        err := baseCompileConstraints(context, cDef, slotConnCstrs, nameConstraints, attributeConstraints, slotIDConstraints)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">normalizeSideArityConstraints(context, slotConnCstrs)
        return slotConnCstrs, nil</span>
}

var slotRuleCompilers = map[string]subruleCompiler{
        "allow-installation":    compileSlotInstallationConstraints,
        "deny-installation":     compileSlotInstallationConstraints,
        "allow-connection":      compileSlotConnectionConstraints,
        "deny-connection":       compileSlotConnectionConstraints,
        "allow-auto-connection": compileSlotConnectionConstraints,
        "deny-auto-connection":  compileSlotConnectionConstraints,
}

func compileSlotRule(interfaceName string, rule any) (*SlotRule, error) <span class="cov0" title="0">{
        context := fmt.Sprintf("slot rule for interface %q", interfaceName)
        slotRule := &amp;SlotRule{
                Interface: interfaceName,
        }
        err := baseCompileRule(context, rule, slotRule, ruleSubrules, slotRuleCompilers, defaultOutcome, invertedOutcome)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return slotRule, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "sort"
        "strconv"
        "sync"
)

type memoryBackstore struct {
        top memBSBranch
        mu  sync.RWMutex
}

type memBSNode interface {
        put(assertType *AssertionType, key []string, assert Assertion) error
        get(key []string, maxFormat int) (Assertion, error)
        search(hint []string, found func(Assertion), maxFormat int)
        sequenceMemberAfter(prefix []string, after, maxFormat int) (Assertion, error)
}

type memBSBranch map[string]memBSNode

type memBSLeaf map[string]map[int]Assertion

type memBSSeqLeaf struct {
        memBSLeaf
        sequence []int
}

func (br memBSBranch) put(assertType *AssertionType, key []string, assert Assertion) error <span class="cov0" title="0">{
        key0 := key[0]
        down := br[key0]
        if down == nil </span><span class="cov0" title="0">{
                if len(key) &gt; 2 </span><span class="cov0" title="0">{
                        down = make(memBSBranch)
                }</span> else<span class="cov0" title="0"> {
                        leaf := make(memBSLeaf)
                        if assertType.SequenceForming() </span><span class="cov0" title="0">{
                                down = &amp;memBSSeqLeaf{memBSLeaf: leaf}
                        }</span> else<span class="cov0" title="0"> {
                                down = leaf
                        }</span>
                }
                <span class="cov0" title="0">br[key0] = down</span>
        }
        <span class="cov0" title="0">return down.put(assertType, key[1:], assert)</span>
}

func (leaf memBSLeaf) cur(key0 string, maxFormat int) (a Assertion) <span class="cov0" title="0">{
        for formatnum, a1 := range leaf[key0] </span><span class="cov0" title="0">{
                if formatnum &lt;= maxFormat </span><span class="cov0" title="0">{
                        if a == nil || a1.Revision() &gt; a.Revision() </span><span class="cov0" title="0">{
                                a = a1
                        }</span>
                }
        }
        <span class="cov0" title="0">return a</span>
}

func (leaf memBSLeaf) put(assertType *AssertionType, key []string, assert Assertion) error <span class="cov0" title="0">{
        key0 := key[0]
        cur := leaf.cur(key0, assertType.MaxSupportedFormat())
        if cur != nil </span><span class="cov0" title="0">{
                rev := assert.Revision()
                curRev := cur.Revision()
                if curRev &gt;= rev </span><span class="cov0" title="0">{
                        return &amp;RevisionError{Current: curRev, Used: rev}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := leaf[key0]; !ok </span><span class="cov0" title="0">{
                leaf[key0] = make(map[int]Assertion)
        }</span>
        <span class="cov0" title="0">leaf[key0][assert.Format()] = assert
        return nil</span>
}

func (leaf *memBSSeqLeaf) put(assertType *AssertionType, key []string, assert Assertion) error <span class="cov0" title="0">{
        if err := leaf.memBSLeaf.put(assertType, key, assert); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(leaf.memBSLeaf) != len(leaf.sequence) </span><span class="cov0" title="0">{
                seqnum := assert.(SequenceMember).Sequence()
                inspos := sort.SearchInts(leaf.sequence, seqnum)
                n := len(leaf.sequence)
                leaf.sequence = append(leaf.sequence, seqnum)
                if inspos != n </span><span class="cov0" title="0">{
                        copy(leaf.sequence[inspos+1:n+1], leaf.sequence[inspos:n])
                        leaf.sequence[inspos] = seqnum
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// errNotFound is used internally by backends, it is converted to the richer
// NotFoundError only at their public interface boundary
var errNotFound = errors.New("assertion not found")

func (br memBSBranch) get(key []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        key0 := key[0]
        down := br[key0]
        if down == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>
        <span class="cov0" title="0">return down.get(key[1:], maxFormat)</span>
}

func (leaf memBSLeaf) get(key []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        key0 := key[0]
        cur := leaf.cur(key0, maxFormat)
        if cur == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>
        <span class="cov0" title="0">return cur, nil</span>
}

func (br memBSBranch) search(hint []string, found func(Assertion), maxFormat int) <span class="cov0" title="0">{
        hint0 := hint[0]
        if hint0 == "" </span><span class="cov0" title="0">{
                for _, down := range br </span><span class="cov0" title="0">{
                        down.search(hint[1:], found, maxFormat)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">down := br[hint0]
        if down != nil </span><span class="cov0" title="0">{
                down.search(hint[1:], found, maxFormat)
        }</span>
}

func (leaf memBSLeaf) search(hint []string, found func(Assertion), maxFormat int) <span class="cov0" title="0">{
        hint0 := hint[0]
        if hint0 == "" </span><span class="cov0" title="0">{
                for key := range leaf </span><span class="cov0" title="0">{
                        cand := leaf.cur(key, maxFormat)
                        if cand != nil </span><span class="cov0" title="0">{
                                found(cand)
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">cur := leaf.cur(hint0, maxFormat)
        if cur != nil </span><span class="cov0" title="0">{
                found(cur)
        }</span>
}

func (br memBSBranch) sequenceMemberAfter(prefix []string, after, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        prefix0 := prefix[0]
        down := br[prefix0]
        if down == nil </span><span class="cov0" title="0">{
                return nil, errNotFound
        }</span>
        <span class="cov0" title="0">return down.sequenceMemberAfter(prefix[1:], after, maxFormat)</span>
}

func (left memBSLeaf) sequenceMemberAfter(prefix []string, after, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        panic("internal error: unexpected sequenceMemberAfter on memBSLeaf")</span>
}

func (leaf *memBSSeqLeaf) sequenceMemberAfter(prefix []string, after, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        n := len(leaf.sequence)
        dir := 1
        var start int
        if after == -1 </span><span class="cov0" title="0">{
                // search for the latest in sequence compatible with
                // maxFormat: consider all sequence numbers in
                // sequence backward
                dir = -1
                start = n - 1
        }</span> else<span class="cov0" title="0"> {
                // search for the first in sequence with sequence number
                // &gt; after and compatible with maxFormat
                start = sort.SearchInts(leaf.sequence, after)
                if start == n </span><span class="cov0" title="0">{
                        // nothing
                        return nil, errNotFound
                }</span>
                <span class="cov0" title="0">if leaf.sequence[start] == after </span><span class="cov0" title="0">{
                        // skip after itself
                        start += 1
                }</span>
        }
        <span class="cov0" title="0">for j := start; j &gt;= 0 &amp;&amp; j &lt; n; j += dir </span><span class="cov0" title="0">{
                seqkey := strconv.Itoa(leaf.sequence[j])
                cur := leaf.cur(seqkey, maxFormat)
                if cur != nil </span><span class="cov0" title="0">{
                        return cur, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errNotFound</span>
}

// NewMemoryBackstore creates a memory backed assertions backstore.
func NewMemoryBackstore() Backstore <span class="cov0" title="0">{
        return &amp;memoryBackstore{
                top: make(memBSBranch),
        }
}</span>

func (mbs *memoryBackstore) Put(assertType *AssertionType, assert Assertion) error <span class="cov0" title="0">{
        mbs.mu.Lock()
        defer mbs.mu.Unlock()

        internalKey := make([]string, 1, 1+len(assertType.PrimaryKey))
        internalKey[0] = assertType.Name
        internalKey = append(internalKey, assert.Ref().PrimaryKey...)

        err := mbs.top.put(assertType, internalKey, assert)
        return err
}</span>

func (mbs *memoryBackstore) Get(assertType *AssertionType, key []string, maxFormat int) (Assertion, error) <span class="cov0" title="0">{
        mbs.mu.RLock()
        defer mbs.mu.RUnlock()

        n := len(assertType.PrimaryKey)
        if len(key) &gt; n </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: Backstore.Get given a key longer than expected for %q: %v", assertType.Name, key)
        }</span>

        <span class="cov0" title="0">internalKey := make([]string, 1+len(assertType.PrimaryKey))
        internalKey[0] = assertType.Name
        copy(internalKey[1:], key)
        if len(key) &lt; n </span><span class="cov0" title="0">{
                for kopt := len(key); kopt &lt; n; kopt++ </span><span class="cov0" title="0">{
                        defl := assertType.OptionalPrimaryKeyDefaults[assertType.PrimaryKey[kopt]]
                        if defl == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("internal error: Backstore.Get given a key missing mandatory elements for %q: %v", assertType.Name, key)
                        }</span>
                        <span class="cov0" title="0">internalKey[kopt+1] = defl</span>
                }
        }

        <span class="cov0" title="0">a, err := mbs.top.get(internalKey, maxFormat)
        if err == errNotFound </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{Type: assertType}
        }</span>
        <span class="cov0" title="0">return a, err</span>
}

func (mbs *memoryBackstore) Search(assertType *AssertionType, headers map[string]string, foundCb func(Assertion), maxFormat int) error <span class="cov0" title="0">{
        mbs.mu.RLock()
        defer mbs.mu.RUnlock()

        hint := make([]string, 1+len(assertType.PrimaryKey))
        hint[0] = assertType.Name
        for i, name := range assertType.PrimaryKey </span><span class="cov0" title="0">{
                hint[1+i] = headers[name]
        }</span>

        <span class="cov0" title="0">candCb := func(a Assertion) </span><span class="cov0" title="0">{
                if searchMatch(a, headers) </span><span class="cov0" title="0">{
                        foundCb(a)
                }</span>
        }

        <span class="cov0" title="0">mbs.top.search(hint, candCb, maxFormat)
        return nil</span>
}

func (mbs *memoryBackstore) SequenceMemberAfter(assertType *AssertionType, sequenceKey []string, after, maxFormat int) (SequenceMember, error) <span class="cov0" title="0">{
        if !assertType.SequenceForming() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("internal error: SequenceMemberAfter on non sequence-forming assertion type %q", assertType.Name))</span>
        }
        <span class="cov0" title="0">if len(sequenceKey) != len(assertType.PrimaryKey)-1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: SequenceMemberAfter's sequence key argument length must be exactly 1 less than the assertion type primary key")
        }</span>

        <span class="cov0" title="0">mbs.mu.RLock()
        defer mbs.mu.RUnlock()

        internalPrefix := make([]string, len(assertType.PrimaryKey))
        internalPrefix[0] = assertType.Name
        copy(internalPrefix[1:], sequenceKey)

        a, err := mbs.top.sequenceMemberAfter(internalPrefix, after, maxFormat)
        if err == errNotFound </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{Type: assertType}
        }</span>
        <span class="cov0" title="0">return a.(SequenceMember), err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "sync"
)

type memoryKeypairManager struct {
        pairs map[string]PrivateKey
        mu    sync.RWMutex
}

// NewMemoryKeypairManager creates a new key pair manager with a memory backstore.
func NewMemoryKeypairManager() KeypairManager <span class="cov0" title="0">{
        return &amp;memoryKeypairManager{
                pairs: make(map[string]PrivateKey),
        }
}</span>

func (mkm *memoryKeypairManager) Put(privKey PrivateKey) error <span class="cov0" title="0">{
        mkm.mu.Lock()
        defer mkm.mu.Unlock()

        keyID := privKey.PublicKey().ID()
        if mkm.pairs[keyID] != nil </span><span class="cov0" title="0">{
                return errKeypairAlreadyExists
        }</span>
        <span class="cov0" title="0">mkm.pairs[keyID] = privKey
        return nil</span>
}

func (mkm *memoryKeypairManager) Get(keyID string) (PrivateKey, error) <span class="cov0" title="0">{
        mkm.mu.RLock()
        defer mkm.mu.RUnlock()

        privKey := mkm.pairs[keyID]
        if privKey == nil </span><span class="cov0" title="0">{
                return nil, errKeypairNotFound
        }</span>
        <span class="cov0" title="0">return privKey, nil</span>
}

func (mkm *memoryKeypairManager) Delete(keyID string) error <span class="cov0" title="0">{
        mkm.mu.RLock()
        defer mkm.mu.RUnlock()

        _, ok := mkm.pairs[keyID]
        if !ok </span><span class="cov0" title="0">{
                return errKeypairNotFound
        }</span>
        <span class="cov0" title="0">delete(mkm.pairs, keyID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2025 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

var (
        validMessageID   = regexp.MustCompile(`^([a-zA-Z0-9]{4,16})(?:-(\d+))?$`)
        validMessageKind = regexp.MustCompile(`^[a-z]+(?:-[a-z]+)*$`)
)

// DeviceID represents a unique device identifier composed of &lt;serial&gt;.&lt;model&gt;.&lt;brand-id&gt;.
type DeviceID struct {
        Serial  string
        Model   string
        BrandID string
}

func newDeviceIDFromString(rawID string) (DeviceID, error) <span class="cov0" title="0">{
        parts := strutil.SplitRightN(rawID, ".", 3)
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return DeviceID{}, fmt.Errorf("invalid device id format: expected 3 parts separated by '.', got %d: %s", len(parts), rawID)
        }</span>

        <span class="cov0" title="0">if !validModel.MatchString(parts[1]) </span><span class="cov0" title="0">{
                return DeviceID{}, fmt.Errorf("invalid model %q in device id %q", parts[1], rawID)
        }</span>

        <span class="cov0" title="0">if !validAccountID.MatchString(parts[2]) </span><span class="cov0" title="0">{
                return DeviceID{}, fmt.Errorf("invalid brand-id %q in device id %q", parts[2], rawID)
        }</span>

        <span class="cov0" title="0">return DeviceID{Serial: parts[0], Model: parts[1], BrandID: parts[2]}, nil</span>
}

// RequestMessage represents a request message assertion used to trigger actions on snapd.
type RequestMessage struct {
        assertionBase

        id     string
        seqNum int

        devices []DeviceID

        assumes []string

        sinceUntil
        timestamp time.Time
}

// AccountID returns the account identifier that sent this request message.
func (req *RequestMessage) AccountID() string <span class="cov0" title="0">{
        return req.HeaderString("account-id")
}</span>

// ID returns the message identifier without any sequence number suffix.
func (req *RequestMessage) ID() string <span class="cov0" title="0">{
        return req.id
}</span>

// SeqNum returns the message's sequence number within a sequence, or zero if not sequenced.
func (req *RequestMessage) SeqNum() int <span class="cov0" title="0">{
        return req.seqNum
}</span>

// Kind returns the message kind that determines which subsystem handles the message.
func (req *RequestMessage) Kind() string <span class="cov0" title="0">{
        return req.HeaderString("message-kind")
}</span>

// Devices returns the list of device IDs that this message targets.
func (req *RequestMessage) Devices() []DeviceID <span class="cov0" title="0">{
        return req.devices
}</span>

// Assumes returns the list of device properties required for this message to be applied.
func (req *RequestMessage) Assumes() []string <span class="cov0" title="0">{
        return req.assumes
}</span>

func assembleRequestMessage(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        accountID := assert.HeaderString("account-id")
        if !validAccountID.MatchString(accountID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid account id: %s", accountID)
        }</span>

        <span class="cov0" title="0">id, seqNum, err := parseMessageID(assert.HeaderString("message-id"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkStringMatches(assert.headers, "message-kind", validMessageKind)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">deviceIDs, err := parseDevices(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">assumes, err := checkAssumes(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sinceUntil, err := checkValidSinceUntilWhat(assert.headers, "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(assert.body) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("body must not be empty")
        }</span>

        <span class="cov0" title="0">return &amp;RequestMessage{
                assertionBase: assert,
                id:            id,
                seqNum:        seqNum,
                devices:       deviceIDs,
                assumes:       assumes,
                sinceUntil:    *sinceUntil,
                timestamp:     timestamp,
        }, nil</span>
}

func parseMessageID(rawID string) (string, int, error) <span class="cov0" title="0">{
        if !validMessageID.MatchString(rawID) </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("invalid message-id: %s", rawID)
        }</span>

        <span class="cov0" title="0">parts := strings.SplitN(rawID, "-", 2)
        if len(parts) == 1 </span><span class="cov0" title="0">{
                return parts[0], 0, nil
        }</span>

        <span class="cov0" title="0">seqNum, _ := strconv.Atoi(parts[1])
        if seqNum &lt;= 0 </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("invalid message-id: sequence number must be greater than 0")
        }</span>

        <span class="cov0" title="0">return parts[0], seqNum, nil</span>
}

func parseDevices(headers map[string]any) ([]DeviceID, error) <span class="cov0" title="0">{
        devices, err := checkStringList(headers, "devices")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(devices) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(`"devices" header must not be empty`)
        }</span>

        <span class="cov0" title="0">var deviceIDs []DeviceID
        for i, rawDeviceId := range devices </span><span class="cov0" title="0">{
                deviceID, err := newDeviceIDFromString(rawDeviceId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot parse device at position %d: %w", i+1, err)
                }</span>

                <span class="cov0" title="0">deviceIDs = append(deviceIDs, deviceID)</span>
        }

        <span class="cov0" title="0">return deviceIDs, nil</span>
}

func checkAssumes(headers map[string]any) ([]string, error) <span class="cov0" title="0">{
        assumes, err := checkStringList(headers, "assumes")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = naming.ValidateAssumes(assumes, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assumes: %w", err)
        }</span>

        <span class="cov0" title="0">return assumes, nil</span>
}

func checkValidSinceUntilWhat(m map[string]any, what string) (*sinceUntil, error) <span class="cov0" title="0">{
        since, err := checkRFC3339DateWhat(m, "valid-since", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">until, err := checkRFC3339DateWhat(m, "valid-until", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if until.Before(since) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'valid-until' time cannot be before 'valid-since' time")
        }</span>

        <span class="cov0" title="0">return &amp;sinceUntil{since: since, until: until}, nil</span>
}

// MessageStatus represents the response message's status after processing.
type MessageStatus string

const (
        // MessageStatusSuccess indicates the message payload was applied successfully.
        MessageStatusSuccess MessageStatus = "success"
        // MessageStatusError indicates an error occurred while applying the message.
        MessageStatusError MessageStatus = "error"
        // MessageStatusUnauthorized indicates the action is not allowed for the account/operator.
        MessageStatusUnauthorized MessageStatus = "unauthorized"
        // MessageStatusRejected indicates the message failed initial validation by snapd.
        MessageStatusRejected MessageStatus = "rejected"
)

func newMessageStatus(status string) (MessageStatus, error) <span class="cov0" title="0">{
        ms := MessageStatus(status)
        switch ms </span>{
        case MessageStatusSuccess, MessageStatusError, MessageStatusUnauthorized, MessageStatusRejected:<span class="cov0" title="0">
                return ms, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf(`expected "status" to be one of [success, error, unauthorized, rejected] but was %q`, status)</span>
        }
}

// ResponseMessage represents a response-message assertion generated by snapd
// for every processed request-message. It contains the processing outcome
// and any payload data in the assertion body.
type ResponseMessage struct {
        assertionBase

        id     string
        seqNum int

        device DeviceID

        status MessageStatus

        timestamp time.Time
}

// AccountID returns the account identifier that sent the original request-message.
func (res *ResponseMessage) AccountID() string <span class="cov0" title="0">{
        return res.HeaderString("account-id")
}</span>

// ID returns the message identifier of the original request-message.
func (res *ResponseMessage) ID() string <span class="cov0" title="0">{
        return res.id
}</span>

// SeqNum returns the message's sequence number within a sequence, or zero if not sequenced.
func (res *ResponseMessage) SeqNum() int <span class="cov0" title="0">{
        return res.seqNum
}</span>

// Status returns the response-message's status.
func (res *ResponseMessage) Status() MessageStatus <span class="cov0" title="0">{
        return res.status
}</span>

// Device returns the ID of the device that generated and signed this assertion.
func (res *ResponseMessage) Device() DeviceID <span class="cov0" title="0">{
        return res.device
}</span>

func assembleResponseMessage(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        accountID := assert.HeaderString("account-id")
        if !validAccountID.MatchString(accountID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid account id: %s", accountID)
        }</span>

        <span class="cov0" title="0">id, seqNum, err := parseMessageID(assert.HeaderString("message-id"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">deviceID, err := newDeviceIDFromString(assert.HeaderString("device"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status, err := newMessageStatus(assert.HeaderString("status"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ResponseMessage{
                assertionBase: assert,
                id:            id,
                seqNum:        seqNum,
                device:        deviceID,
                status:        status,
                timestamp:     timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016-2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/snap/channel"
        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

// ModelComponent holds details for components specified by a model assertion.
type ModelComponent struct {
        // Presence can be optional or required
        Presence string
        // Modes is an optional list of modes, which must be a subset
        // of the ones for the snap
        Modes []string
}

// TODO: for ModelSnap
//  * consider moving snap.Type out of snap and using it in ModelSnap
//    but remember assertions use "core" (never "os") for TypeOS
//  * consider having a first-class Presence type

// ModelSnap holds the details about a snap specified by a model assertion.
type ModelSnap struct {
        Name   string
        SnapID string
        // SnapType is one of: app|base|gadget|kernel|core, default is app
        SnapType string
        // Modes in which the snap must be made available
        Modes []string
        // DefaultChannel is the initial tracking channel,
        // default is latest/stable in an extended model
        DefaultChannel string
        // PinnedTrack is a pinned track for the snap, if set DefaultChannel
        // cannot be set at the same time (Core 18 models feature)
        PinnedTrack string
        // Presence is one of: required|optional
        Presence string
        // Classic indicates that this classic snap is intentionally
        // included in a classic model
        Classic bool
        // Components is a map of component names to ModelComponent
        Components map[string]ModelComponent
}

// SnapName implements naming.SnapRef.
func (s *ModelSnap) SnapName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ID implements naming.SnapRef.
func (s *ModelSnap) ID() string <span class="cov0" title="0">{
        return s.SnapID
}</span>

type modelSnaps struct {
        snapd            *ModelSnap
        base             *ModelSnap
        gadget           *ModelSnap
        kernel           *ModelSnap
        snapsNoEssential []*ModelSnap
}

func (ms *modelSnaps) list() (allSnaps []*ModelSnap, requiredWithEssentialSnaps []naming.SnapRef, numEssentialSnaps int) <span class="cov0" title="0">{
        addSnap := func(snap *ModelSnap, essentialSnap int) </span><span class="cov0" title="0">{
                if snap == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">numEssentialSnaps += essentialSnap
                allSnaps = append(allSnaps, snap)
                if snap.Presence == "required" </span><span class="cov0" title="0">{
                        requiredWithEssentialSnaps = append(requiredWithEssentialSnaps, snap)
                }</span>
        }

        <span class="cov0" title="0">addSnap(ms.snapd, 1)
        addSnap(ms.kernel, 1)
        addSnap(ms.base, 1)
        addSnap(ms.gadget, 1)
        for _, snap := range ms.snapsNoEssential </span><span class="cov0" title="0">{
                addSnap(snap, 0)
        }</span>
        <span class="cov0" title="0">return allSnaps, requiredWithEssentialSnaps, numEssentialSnaps</span>
}

var (
        essentialSnapModes = []string{"run", "ephemeral"}
        defaultModes       = []string{"run"}
)

func checkExtendedSnaps(extendedSnaps any, base string, grade ModelGrade, modelIsClassic bool) (*modelSnaps, error) <span class="cov0" title="0">{
        const wrongHeaderType = `"snaps" header must be a list of maps`

        entries, ok := extendedSnaps.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(wrongHeaderType)
        }</span>

        <span class="cov0" title="0">var modelSnaps modelSnaps
        seen := make(map[string]bool, len(entries))
        seenIDs := make(map[string]string, len(entries))

        for _, entry := range entries </span><span class="cov0" title="0">{
                snap, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(wrongHeaderType)
                }</span>
                <span class="cov0" title="0">modelSnap, err := checkModelSnap(snap, base, grade, modelIsClassic)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if seen[modelSnap.Name] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot list the same snap %q multiple times", modelSnap.Name)
                }</span>
                <span class="cov0" title="0">seen[modelSnap.Name] = true
                // at this time we do not support parallel installing
                // from model/seed
                if snapID := modelSnap.SnapID; snapID != "" </span><span class="cov0" title="0">{
                        if underName := seenIDs[snapID]; underName != "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify the same snap id %q multiple times, specified for snaps %q and %q", snapID, underName, modelSnap.Name)
                        }</span>
                        <span class="cov0" title="0">seenIDs[snapID] = modelSnap.Name</span>
                }

                <span class="cov0" title="0">switch </span>{
                case modelSnap.SnapType == "snapd":<span class="cov0" title="0">
                        // TODO: allow to be explicit only in grade: dangerous?
                        if modelSnaps.snapd != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify multiple snapd snaps: %q and %q", modelSnaps.snapd.Name, modelSnap.Name)
                        }</span>
                        <span class="cov0" title="0">modelSnaps.snapd = modelSnap</span>
                case modelSnap.SnapType == "kernel":<span class="cov0" title="0">
                        if modelSnaps.kernel != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify multiple kernel snaps: %q and %q", modelSnaps.kernel.Name, modelSnap.Name)
                        }</span>
                        <span class="cov0" title="0">modelSnaps.kernel = modelSnap</span>
                case modelSnap.SnapType == "gadget":<span class="cov0" title="0">
                        if modelSnaps.gadget != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify multiple gadget snaps: %q and %q", modelSnaps.gadget.Name, modelSnap.Name)
                        }</span>
                        <span class="cov0" title="0">modelSnaps.gadget = modelSnap</span>
                case modelSnap.Name == base:<span class="cov0" title="0">
                        if modelSnap.SnapType != "base" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`boot base %q must specify type "base", not %q`, base, modelSnap.SnapType)
                        }</span>
                        <span class="cov0" title="0">modelSnaps.base = modelSnap</span>
                }

                <span class="cov0" title="0">if !isEssentialSnap(modelSnap.Name, modelSnap.SnapType, base) </span><span class="cov0" title="0">{
                        modelSnaps.snapsNoEssential = append(modelSnaps.snapsNoEssential, modelSnap)
                }</span>
        }

        <span class="cov0" title="0">return &amp;modelSnaps, nil</span>
}

var (
        validSnapTypes     = []string{"app", "base", "gadget", "kernel", "core", "snapd"}
        validSnapMode      = regexp.MustCompile("^[a-z][-a-z]+$")
        validSnapPresences = []string{"required", "optional"}
)

func isEssentialSnap(snapName, snapType, modelBase string) bool <span class="cov0" title="0">{
        switch snapType </span>{
        case "snapd", "kernel", "gadget":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">if snapName == modelBase </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func checkModesForSnap(snap map[string]any, isEssential bool, what string) ([]string, error) <span class="cov0" title="0">{
        modes, err := checkStringListInMap(snap, "modes", fmt.Sprintf("%q %s", "modes", what),
                validSnapMode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isEssential </span><span class="cov0" title="0">{
                if len(modes) != 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("essential snaps are always available, cannot specify modes %s", what)
                }</span>
                <span class="cov0" title="0">modes = essentialSnapModes</span>
        }

        <span class="cov0" title="0">if len(modes) == 0 </span><span class="cov0" title="0">{
                modes = defaultModes
        }</span>

        <span class="cov0" title="0">return modes, nil</span>
}

func checkModelSnap(snap map[string]any, modelBase string, grade ModelGrade, modelIsClassic bool) (*ModelSnap, error) <span class="cov0" title="0">{
        name, err := checkNotEmptyStringWhat(snap, "name", "of snap")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := naming.ValidateSnap(name); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid snap name %q", name)
        }</span>

        <span class="cov0" title="0">what := fmt.Sprintf("of snap %q", name)

        var snapID string
        _, ok := snap["id"]
        if ok </span><span class="cov0" title="0">{
                var err error
                snapID, err = checkStringMatchesWhat(snap, "id", what, naming.ValidSnapID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                // snap ids are optional with grade dangerous to allow working
                // with local/not pushed yet to the store snaps
                if grade != ModelDangerous </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"id" %s is mandatory for %s grade model`, what, grade)
                }</span>
        }

        <span class="cov0" title="0">typ, err := checkOptionalStringWhat(snap, "type", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if typ == "" </span><span class="cov0" title="0">{
                typ = "app"
        }</span>
        <span class="cov0" title="0">if !strutil.ListContains(validSnapTypes, typ) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type of snap %q must be one of %s", name, strings.Join(validSnapTypes, "|"))
        }</span>

        <span class="cov0" title="0">presence, err := checkOptionalStringWhat(snap, "presence", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if presence != "" &amp;&amp; !strutil.ListContains(validSnapPresences, presence) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("presence of snap %q must be one of required|optional", name)
        }</span>
        <span class="cov0" title="0">essential := isEssentialSnap(name, typ, modelBase)
        if essential &amp;&amp; presence != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("essential snaps are always available, cannot specify presence for snap %q", name)
        }</span>
        <span class="cov0" title="0">if presence == "" </span><span class="cov0" title="0">{
                presence = "required"
        }</span>

        <span class="cov0" title="0">modes, err := checkModesForSnap(snap, essential, what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defaultChannel, err := checkOptionalStringWhat(snap, "default-channel", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if defaultChannel == "" </span><span class="cov0" title="0">{
                defaultChannel = "latest/stable"
        }</span>
        <span class="cov0" title="0">defCh, err := channel.ParseVerbatim(defaultChannel, "-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid default channel for snap %q: %v", name, err)
        }</span>
        <span class="cov0" title="0">if defCh.Track == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("default channel for snap %q must specify a track", name)
        }</span>

        <span class="cov0" title="0">isClassic, err := checkOptionalBoolWhat(snap, "classic", what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isClassic &amp;&amp; !modelIsClassic </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("snap %q cannot be classic in non-classic model", name)
        }</span>
        <span class="cov0" title="0">if isClassic &amp;&amp; typ != "app" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("snap %q cannot be classic with type %q instead of app", name, typ)
        }</span>
        <span class="cov0" title="0">if isClassic &amp;&amp; (len(modes) != 1 || modes[0] != "run") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("classic snap %q not allowed outside of run mode: %v",
                        name, modes)
        }</span>

        <span class="cov0" title="0">components, err := checkComponentsForMaps(snap, modes, what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ModelSnap{
                Name:           name,
                SnapID:         snapID,
                SnapType:       typ,
                Modes:          modes, // can be empty
                DefaultChannel: defaultChannel,
                Presence:       presence, // can be empty
                Classic:        isClassic,
                Components:     components, // can be empty
        }, nil</span>
}

// This is what we expect for components:
/**
snaps:
 - name: &lt;snap-name&gt;
   ...
   presence: "optional"|"required" # optional, defaults to "required"
   modes:    [&lt;mode-specifier&gt;]    # list of modes
   components:                          # optional
      &lt;component-name-1&gt;:
         presence: "optional"|"required"
         modes:    [&lt;mode-specifier&gt;] # list of modes, optional
                                      # must be a subset of snap modes
                                      # defaults to the same modes
                                      # as the snap
      &lt;component-name-2&gt;: "required"|"optional" # presence, shortcut syntax
**/
func checkComponentsForMaps(m map[string]any, validModes []string, what string) (map[string]ModelComponent, error) <span class="cov0" title="0">{
        const compsField = "components"
        value, ok := m[compsField]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">comps, ok := value.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q %s must be a map from strings to components",
                        compsField, what)
        }</span>

        <span class="cov0" title="0">res := make(map[string]ModelComponent, len(comps))
        for name, comp := range comps </span><span class="cov0" title="0">{
                // Name of component follows the same rules as snap components
                if err := naming.ValidateSnap(name); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid component name %s", name)
                }</span>

                // "comp: required|optional" case
                <span class="cov0" title="0">compWhat := fmt.Sprintf("of component %q %s", name, what)
                presence, ok := comp.(string)
                if ok </span><span class="cov0" title="0">{
                        if !strutil.ListContains(validSnapPresences, presence) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("presence %s must be one of required|optional", compWhat)
                        }</span>
                        <span class="cov0" title="0">res[name] = ModelComponent{Presence: presence,
                                Modes: append([]string(nil), validModes...)}
                        continue</span>
                }

                // try map otherwise
                <span class="cov0" title="0">compFields, ok := comp.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s must be a map of strings to components or one of required|optional",
                                compWhat)
                }</span>
                // Error out if unexpected entry
                <span class="cov0" title="0">for key := range compFields </span><span class="cov0" title="0">{
                        if !strutil.ListContains([]string{"presence", "modes"}, key) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("entry %q %s is unknown", key, compWhat)
                        }</span>
                }
                <span class="cov0" title="0">presence, err := checkNotEmptyStringWhat(compFields, "presence", compWhat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !strutil.ListContains(validSnapPresences, presence) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("presence %s must be one of required|optional", compWhat)
                }</span>
                <span class="cov0" title="0">modes, err := checkStringListInMap(compFields, "modes",
                        fmt.Sprintf("modes %s", compWhat), validSnapMode)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(modes) == 0 </span><span class="cov0" title="0">{
                        modes = append([]string(nil), validModes...)
                }</span> else<span class="cov0" title="0"> {
                        for _, m := range modes </span><span class="cov0" title="0">{
                                if !strutil.ListContains(validModes, m) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("mode %q %s is incompatible with the snap modes", m, compWhat)
                                }</span>
                        }
                }
                <span class="cov0" title="0">res[name] = ModelComponent{Presence: presence, Modes: modes}</span>
        }

        <span class="cov0" title="0">return res, nil</span>
}

// unextended case support

func checkSnapWithTrack(headers map[string]any, which string) (*ModelSnap, error) <span class="cov0" title="0">{
        _, ok := headers[which]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">value, ok := headers[which].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`%q header must be a string`, which)
        }</span>
        <span class="cov0" title="0">l := strings.SplitN(value, "=", 2)

        name := l[0]
        track := ""
        if err := validateSnapName(name, which); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(l) &gt; 1 </span><span class="cov0" title="0">{
                track = l[1]
                if strings.Count(track, "/") != 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`%q channel selector must be a track name only`, which)
                }</span>
                <span class="cov0" title="0">channelRisks := []string{"stable", "candidate", "beta", "edge"}
                if strutil.ListContains(channelRisks, track) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`%q channel selector must be a track name`, which)
                }</span>
        }

        <span class="cov0" title="0">return &amp;ModelSnap{
                Name:        name,
                SnapType:    which,
                Modes:       defaultModes,
                PinnedTrack: track,
                Presence:    "required",
        }, nil</span>
}

func validateSnapName(name string, headerName string) error <span class="cov0" title="0">{
        if err := naming.ValidateSnap(name); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid snap name in %q header: %s", headerName, name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func checkRequiredSnap(name string, headerName string, snapType string) (*ModelSnap, error) <span class="cov0" title="0">{
        if err := validateSnapName(name, headerName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ModelSnap{
                Name:     name,
                SnapType: snapType,
                Modes:    defaultModes,
                Presence: "required",
        }, nil</span>
}

// ModelGrade characterizes the security of the model which then
// controls related policy.
type ModelGrade string

const (
        ModelGradeUnset ModelGrade = "unset"
        // ModelSecured implies mandatory full disk encryption and secure boot.
        ModelSecured ModelGrade = "secured"
        // ModelSigned implies all seed snaps are signed and mentioned
        // in the model, i.e. no unasserted or extra snaps.
        ModelSigned ModelGrade = "signed"
        // ModelDangerous allows unasserted snaps and extra snaps.
        ModelDangerous ModelGrade = "dangerous"
)

// StorageSafety characterizes the requested storage safety of
// the model which then controls what encryption is used
type StorageSafety string

const (
        StorageSafetyUnset StorageSafety = "unset"
        // StorageSafetyEncrypted implies mandatory full disk encryption.
        StorageSafetyEncrypted StorageSafety = "encrypted"
        // StorageSafetyPreferEncrypted implies full disk
        // encryption when the system supports it.
        StorageSafetyPreferEncrypted StorageSafety = "prefer-encrypted"
        // StorageSafetyPreferUnencrypted implies no full disk
        // encryption by default even if the system supports
        // encryption.
        StorageSafetyPreferUnencrypted StorageSafety = "prefer-unencrypted"
)

var validStorageSafeties = []string{string(StorageSafetyEncrypted), string(StorageSafetyPreferEncrypted), string(StorageSafetyPreferUnencrypted)}

var validModelGrades = []string{string(ModelSecured), string(ModelSigned), string(ModelDangerous)}

// gradeToCode encodes grades into 32 bits, trying to be slightly future-proof:
//   - lower 16 bits are reserved
//   - in the higher bits use the sequence 1, 8, 16 to have some space
//     to possibly add new grades in between
var gradeToCode = map[ModelGrade]uint32{
        ModelGradeUnset: 0,
        ModelDangerous:  0x10000,
        ModelSigned:     0x80000,
        ModelSecured:    0x100000,
        // reserved by secboot to measure classic models
        // "ClassicModelGradeMask": 0x80000000
}

// Code returns a bit representation of the grade, for example for
// measuring it in a full disk encryption implementation.
func (mg ModelGrade) Code() uint32 <span class="cov0" title="0">{
        code, ok := gradeToCode[mg]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("unknown model grade: %s", mg))</span>
        }
        <span class="cov0" title="0">return code</span>
}

type ModelValidationSetMode string

const (
        ModelValidationSetModePreferEnforced ModelValidationSetMode = "prefer-enforce"
        ModelValidationSetModeEnforced       ModelValidationSetMode = "enforce"
)

var validModelValidationSetModes = []string{
        string(ModelValidationSetModePreferEnforced),
        string(ModelValidationSetModeEnforced),
}

// ModelValidationSet represents a reference to a validation set assertion.
// The structure also describes how the validation set will be applied
// to the device, and whether the validation set should be pinned to
// a specific sequence.
type ModelValidationSet struct {
        // AccountID is the account ID the validation set originates from.
        // If this was not explicitly set in the stanza, this will instead
        // be set to the brand ID.
        AccountID string
        // Name is the name of the validation set from the account ID.
        Name string
        // Sequence, if non-zero, specifies that the validation set should be
        // pinned at this sequence number.
        Sequence int
        // Mode is the enforcement mode the validation set should be applied with.
        Mode ModelValidationSetMode
}

// SequenceKey returns the sequence key for this validation set.
func (mvs *ModelValidationSet) SequenceKey() string <span class="cov0" title="0">{
        return vsSequenceKey(release.Series, mvs.AccountID, mvs.Name)
}</span>

func (mvs *ModelValidationSet) AtSequence() *AtSequence <span class="cov0" title="0">{
        return &amp;AtSequence{
                Type:        ValidationSetType,
                SequenceKey: []string{release.Series, mvs.AccountID, mvs.Name},
                Sequence:    mvs.Sequence,
                Pinned:      mvs.Sequence &gt; 0,
                Revision:    RevisionNotKnown,
        }
}</span>

// Model holds a model assertion, which is a statement by a brand
// about the properties of a device model.
type Model struct {
        assertionBase
        classic bool

        baseSnap   *ModelSnap
        gadgetSnap *ModelSnap
        kernelSnap *ModelSnap

        grade ModelGrade

        storageSafety StorageSafety

        allSnaps []*ModelSnap
        // consumers of this info should care only about snap identity =&gt;
        // snapRef
        requiredWithEssentialSnaps []naming.SnapRef
        numEssentialSnaps          int

        validationSets []*ModelValidationSet

        serialAuthority  []string
        sysUserAuthority []string
        preseedAuthority []string
        timestamp        time.Time
}

// BrandID returns the brand identifier. Same as the authority id.
func (mod *Model) BrandID() string <span class="cov0" title="0">{
        return mod.HeaderString("brand-id")
}</span>

// Model returns the model name identifier.
func (mod *Model) Model() string <span class="cov0" title="0">{
        return mod.HeaderString("model")
}</span>

// DisplayName returns the human-friendly name of the model or
// falls back to Model if this was not set.
func (mod *Model) DisplayName() string <span class="cov0" title="0">{
        display := mod.HeaderString("display-name")
        if display == "" </span><span class="cov0" title="0">{
                return mod.Model()
        }</span>
        <span class="cov0" title="0">return display</span>
}

// Series returns the series of the core software the model uses.
func (mod *Model) Series() string <span class="cov0" title="0">{
        return mod.HeaderString("series")
}</span>

// Classic returns whether the model is a classic system.
func (mod *Model) Classic() bool <span class="cov0" title="0">{
        return mod.classic
}</span>

// HybridClassic returns whether the model is a hybrid classic system, meaning
// it is both classic and has an associated kernel snap.
func (mod *Model) HybridClassic() bool <span class="cov0" title="0">{
        return mod.classic &amp;&amp; mod.kernelSnap != nil
}</span>

// Distribution returns the linux distro specified in the model.
func (mod *Model) Distribution() string <span class="cov0" title="0">{
        return mod.HeaderString("distribution")
}</span>

// Architecture returns the architecture the model is based on.
func (mod *Model) Architecture() string <span class="cov0" title="0">{
        return mod.HeaderString("architecture")
}</span>

// Grade returns the stability grade of the model. Will be ModelGradeUnset
// for Core 16/18 models.
func (mod *Model) Grade() ModelGrade <span class="cov0" title="0">{
        return mod.grade
}</span>

// StorageSafety returns the storage safety for the model. Will be
// StorageSafetyUnset for Core 16/18 models.
func (mod *Model) StorageSafety() StorageSafety <span class="cov0" title="0">{
        return mod.storageSafety
}</span>

// GadgetSnap returns the details of the gadget snap the model uses.
func (mod *Model) GadgetSnap() *ModelSnap <span class="cov0" title="0">{
        return mod.gadgetSnap
}</span>

// Gadget returns the gadget snap the model uses.
func (mod *Model) Gadget() string <span class="cov0" title="0">{
        if mod.gadgetSnap == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return mod.gadgetSnap.Name</span>
}

// GadgetTrack returns the gadget track the model uses.
// XXX this should go away
func (mod *Model) GadgetTrack() string <span class="cov0" title="0">{
        if mod.gadgetSnap == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return mod.gadgetSnap.PinnedTrack</span>
}

// KernelSnap returns the details of the kernel snap the model uses.
func (mod *Model) KernelSnap() *ModelSnap <span class="cov0" title="0">{
        return mod.kernelSnap
}</span>

// Kernel returns the kernel snap the model uses.
// XXX this should go away
func (mod *Model) Kernel() string <span class="cov0" title="0">{
        if mod.kernelSnap == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return mod.kernelSnap.Name</span>
}

// KernelTrack returns the kernel track the model uses.
// XXX this should go away
func (mod *Model) KernelTrack() string <span class="cov0" title="0">{
        if mod.kernelSnap == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return mod.kernelSnap.PinnedTrack</span>
}

// Base returns the base snap the model uses.
func (mod *Model) Base() string <span class="cov0" title="0">{
        return mod.HeaderString("base")
}</span>

// BaseSnap returns the details of the base snap the model uses.
func (mod *Model) BaseSnap() *ModelSnap <span class="cov0" title="0">{
        return mod.baseSnap
}</span>

// Store returns the snap store the model uses.
func (mod *Model) Store() string <span class="cov0" title="0">{
        return mod.HeaderString("store")
}</span>

// RequiredNoEssentialSnaps returns the snaps that must be installed at all times and cannot be removed for this model, excluding the essential snaps (gadget, kernel, boot base, snapd).
func (mod *Model) RequiredNoEssentialSnaps() []naming.SnapRef <span class="cov0" title="0">{
        return mod.requiredWithEssentialSnaps[mod.numEssentialSnaps:]
}</span>

// RequiredWithEssentialSnaps returns the snaps that must be installed at all times and cannot be removed for this model, including any essential snaps (gadget, kernel, boot base, snapd).
func (mod *Model) RequiredWithEssentialSnaps() []naming.SnapRef <span class="cov0" title="0">{
        return mod.requiredWithEssentialSnaps
}</span>

// EssentialSnaps returns all essential snaps explicitly mentioned by
// the model.
// They are always returned according to this order with some skipped
// if not mentioned: snapd, kernel, boot base, gadget.
func (mod *Model) EssentialSnaps() []*ModelSnap <span class="cov0" title="0">{
        return mod.allSnaps[:mod.numEssentialSnaps]
}</span>

// SnapsWithoutEssential returns all the snaps listed by the model
// without any of the essential snaps (as returned by EssentialSnaps).
// They are returned in the order of mention by the model.
func (mod *Model) SnapsWithoutEssential() []*ModelSnap <span class="cov0" title="0">{
        return mod.allSnaps[mod.numEssentialSnaps:]
}</span>

// AllSnaps returns all the snaps listed by the model, across all modes.
// Essential snaps are at the front of the slice, followed by the non-essential
// snaps. The essential snaps follow the same order as returned by
// EssentialSnaps. The non-essential snaps are returned in the order they are
// mentioned in the model.
func (mod *Model) AllSnaps() []*ModelSnap <span class="cov0" title="0">{
        return mod.allSnaps
}</span>

// ValidationSets returns all the validation-sets listed by the model.
func (mod *Model) ValidationSets() []*ModelValidationSet <span class="cov0" title="0">{
        return mod.validationSets
}</span>

// SerialAuthority returns the authority ids that are accepted as
// signers for serial assertions for this model. It always includes the
// brand of the model.
func (mod *Model) SerialAuthority() []string <span class="cov0" title="0">{
        return mod.serialAuthority
}</span>

// SystemUserAuthority returns the authority ids that are accepted as
// signers of system-user assertions for this model. Empty list means
// any, otherwise it always includes the brand of the model.
func (mod *Model) SystemUserAuthority() []string <span class="cov0" title="0">{
        return mod.sysUserAuthority
}</span>

// PreseedAuthority returns the authority ids that are accepted as
// signers of the preseed binary blob for this model. It always includes the
// brand of the model.
func (mod *Model) PreseedAuthority() []string <span class="cov0" title="0">{
        return mod.preseedAuthority
}</span>

// Timestamp returns the time when the model assertion was issued.
func (mod *Model) Timestamp() time.Time <span class="cov0" title="0">{
        return mod.timestamp
}</span>

// Implement further consistency checks.
func (mod *Model) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // TODO: double check trust level of authority depending on class and possibly allowed-modes
        return nil
}</span>

// expected interface is implemented
var _ consistencyChecker = (*Model)(nil)

// limit model to only lowercase for now
var validModel = regexp.MustCompile("^[a-zA-Z0-9](?:-?[a-zA-Z0-9])*$")

func checkModel(headers map[string]any) (string, error) <span class="cov0" title="0">{
        s, err := checkStringMatches(headers, "model", validModel)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // TODO: support the concept of case insensitive/preserving string headers
        <span class="cov0" title="0">if strings.ToLower(s) != s </span><span class="cov0" title="0">{
                return "", fmt.Errorf(`"model" header cannot contain uppercase letters`)
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}

func checkAuthorityMatchesBrand(a Assertion) error <span class="cov0" title="0">{
        typeName := a.Type().Name
        authorityID := a.AuthorityID()
        brand := a.HeaderString("brand-id")
        if brand != authorityID </span><span class="cov0" title="0">{
                return fmt.Errorf("authority-id and brand-id must match, %s assertions are expected to be signed by the brand: %q != %q", typeName, authorityID, brand)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func checkOptionalAuthority(headers map[string]any, name string, brandID string, acceptsWildcard bool) ([]string, error) <span class="cov0" title="0">{
        ids := []string{brandID}
        v, ok := headers[name]
        if !ok </span><span class="cov0" title="0">{
                return ids, nil
        }</span>
        <span class="cov0" title="0">switch x := v.(type) </span>{
        case string:<span class="cov0" title="0">
                if acceptsWildcard &amp;&amp; x == "*" </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
        case []any:<span class="cov0" title="0">
                lst, err := checkStringListMatches(headers, name, validAccountID)
                if err == nil </span><span class="cov0" title="0">{
                        if !strutil.ListContains(lst, brandID) </span><span class="cov0" title="0">{
                                lst = append(ids, lst...)
                        }</span>
                        <span class="cov0" title="0">return lst, nil</span>
                }
        }

        <span class="cov0" title="0">if acceptsWildcard </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%q header must be '*' or a list of account ids", name)
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("%q header must be a list of account ids", name)
        }</span>
}

func checkOptionalSerialAuthority(headers map[string]any, brandID string) ([]string, error) <span class="cov0" title="0">{
        const acceptsWildcard = false
        return checkOptionalAuthority(headers, "serial-authority", brandID, acceptsWildcard)
}</span>

func checkOptionalSystemUserAuthority(headers map[string]any, brandID string) ([]string, error) <span class="cov0" title="0">{
        const acceptsWildcard = true
        return checkOptionalAuthority(headers, "system-user-authority", brandID, acceptsWildcard)
}</span>

func checkOptionalPreseedAuthority(headers map[string]any, brandID string) ([]string, error) <span class="cov0" title="0">{
        const acceptsWildcard = false
        return checkOptionalAuthority(headers, "preseed-authority", brandID, acceptsWildcard)
}</span>

func checkModelValidationSetAccountID(headers map[string]any, what, brandID string) (string, error) <span class="cov0" title="0">{
        accountID, err := checkOptionalStringWhat(headers, "account-id", what)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // default to brand ID if account ID is not provided
        <span class="cov0" title="0">if accountID == "" </span><span class="cov0" title="0">{
                return brandID, nil
        }</span>
        <span class="cov0" title="0">return accountID, nil</span>
}

// checkOptionalModelValidationSetSequence reads the optional 'sequence' member, if
// not set, returns 0 as this means unpinned. Unfortunately we are not able
// to reuse `checkSequence` as it operates inside different parameters.
func checkOptionalModelValidationSetSequence(headers map[string]any, what string) (int, error) <span class="cov0" title="0">{
        // Default to 0 when the sequence header is not present
        if _, ok := headers["sequence"]; !ok </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">seq, err := checkIntWhat(headers, "sequence", what)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // If sequence is provided, only accept positive values above 0
        <span class="cov0" title="0">if seq &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("\"sequence\" %s must be larger than 0 or left unspecified (meaning tracking latest)", what)
        }</span>
        <span class="cov0" title="0">return seq, nil</span>
}

func checkModelValidationSetMode(headers map[string]any, what string) (ModelValidationSetMode, error) <span class="cov0" title="0">{
        modeStr, err := checkNotEmptyStringWhat(headers, "mode", what)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if modeStr != "" &amp;&amp; !strutil.ListContains(validModelValidationSetModes, modeStr) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("\"mode\" %s must be %s, not %q", what, strings.Join(validModelValidationSetModes, "|"), modeStr)
        }</span>
        <span class="cov0" title="0">return ModelValidationSetMode(modeStr), nil</span>
}

func checkModelValidationSet(headers map[string]any, brandID string) (*ModelValidationSet, error) <span class="cov0" title="0">{
        name, err := checkStringMatchesWhat(headers, "name", "of validation-set", validValidationSetName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">what := fmt.Sprintf("of validation-set %q", name)
        accountID, err := checkModelValidationSetAccountID(headers, what, brandID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">what = fmt.Sprintf("of validation-set \"%s/%s\"", accountID, name)
        seq, err := checkOptionalModelValidationSetSequence(headers, what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mode, err := checkModelValidationSetMode(headers, what)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ModelValidationSet{
                AccountID: accountID,
                Name:      name,
                Sequence:  seq,
                Mode:      mode,
        }, nil</span>
}

func checkOptionalModelValidationSets(headers map[string]any, brandID string) ([]*ModelValidationSet, error) <span class="cov0" title="0">{
        valSets, ok := headers["validation-sets"]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">entries, ok := valSets.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"validation-sets" must be a list of validation sets`)
        }</span>

        <span class="cov0" title="0">vss := make([]*ModelValidationSet, len(entries))
        seen := make(map[string]bool, len(entries))
        for i, entry := range entries </span><span class="cov0" title="0">{
                data, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`entry in "validation-sets" is not a valid validation-set`)
                }</span>

                <span class="cov0" title="0">vs, err := checkModelValidationSet(data, brandID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vsKey := fmt.Sprintf("%s/%s", vs.AccountID, vs.Name)
                if seen[vsKey] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot add validation set %q twice", vsKey)
                }</span>

                <span class="cov0" title="0">vss[i] = vs
                seen[vsKey] = true</span>
        }
        <span class="cov0" title="0">return vss, nil</span>
}

var (
        modelMandatory           = []string{"architecture", "gadget", "kernel"}
        extendedMandatory        = []string{"architecture", "base"}
        extendedSnapsConflicting = []string{"gadget", "kernel", "required-snaps"}
        classicModelOptional     = []string{"architecture", "gadget"}

        // The distribution header must be a valid ID according to
        // https://www.freedesktop.org/software/systemd/man/os-release.html#ID=
        validDistribution = regexp.MustCompile(`^[a-z0-9._-]*$`)
)

func assembleModel(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        err := checkAuthorityMatchesBrand(&amp;assert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkModel(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">classic, err := checkOptionalBool(assert.headers, "classic")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Core 20 extended snaps header
        <span class="cov0" title="0">extendedSnaps, extended := assert.headers["snaps"]
        if extended </span><span class="cov0" title="0">{
                for _, conflicting := range extendedSnapsConflicting </span><span class="cov0" title="0">{
                        if _, ok := assert.headers[conflicting]; ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify separate %q header once using the extended snaps header", conflicting)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                if _, ok := assert.headers["grade"]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot specify a grade for model without the extended snaps header")
                }</span>
                <span class="cov0" title="0">if _, ok := assert.headers["storage-safety"]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot specify storage-safety for model without the extended snaps header")
                }</span>
        }

        <span class="cov0" title="0">if classic &amp;&amp; !extended </span><span class="cov0" title="0">{
                if _, ok := assert.headers["kernel"]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot specify a kernel with a non-extended classic model")
                }</span>
                <span class="cov0" title="0">if _, ok := assert.headers["base"]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot specify a base with a non-extended classic model")
                }</span>
        }

        // distribution mandatory for classic with extended snaps, not
        // allowed otherwise.
        <span class="cov0" title="0">if classic &amp;&amp; extended </span><span class="cov0" title="0">{
                _, err := checkStringMatches(assert.headers, "distribution", validDistribution)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%v, see distribution ID in os-release spec", err)
                }</span>
        } else<span class="cov0" title="0"> if _, ok := assert.headers["distribution"]; ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot specify distribution for model unless it is classic and has an extended snaps header")
        }</span>

        <span class="cov0" title="0">checker := checkNotEmptyString
        toCheck := modelMandatory
        if extended </span><span class="cov0" title="0">{
                toCheck = extendedMandatory
        }</span> else<span class="cov0" title="0"> if classic </span><span class="cov0" title="0">{
                checker = checkOptionalString
                toCheck = classicModelOptional
        }</span>

        <span class="cov0" title="0">for _, h := range toCheck </span><span class="cov0" title="0">{
                if _, err := checker(assert.headers, h); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // base, if provided, must be a valid snap name too
        <span class="cov0" title="0">var baseSnap *ModelSnap
        base, err := checkOptionalString(assert.headers, "base")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if base != "" </span><span class="cov0" title="0">{
                baseSnap, err = checkRequiredSnap(base, "base", "base")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // store is optional but must be a string, defaults to the ubuntu store
        <span class="cov0" title="0">if _, err = checkOptionalString(assert.headers, "store"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // display-name is optional but must be a string
        <span class="cov0" title="0">if _, err = checkOptionalString(assert.headers, "display-name"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var modSnaps *modelSnaps
        grade := ModelGradeUnset
        storageSafety := StorageSafetyUnset
        if extended </span><span class="cov0" title="0">{
                gradeStr, err := checkOptionalString(assert.headers, "grade")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if gradeStr != "" &amp;&amp; !strutil.ListContains(validModelGrades, gradeStr) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("grade for model must be %s, not %q", strings.Join(validModelGrades, "|"), gradeStr)
                }</span>
                <span class="cov0" title="0">grade = ModelSigned
                if gradeStr != "" </span><span class="cov0" title="0">{
                        grade = ModelGrade(gradeStr)
                }</span>

                <span class="cov0" title="0">storageSafetyStr, err := checkOptionalString(assert.headers, "storage-safety")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if storageSafetyStr != "" &amp;&amp; !strutil.ListContains(validStorageSafeties, storageSafetyStr) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("storage-safety for model must be %s, not %q", strings.Join(validStorageSafeties, "|"), storageSafetyStr)
                }</span>
                <span class="cov0" title="0">if storageSafetyStr != "" </span><span class="cov0" title="0">{
                        storageSafety = StorageSafety(storageSafetyStr)
                }</span> else<span class="cov0" title="0"> {
                        if grade == ModelSecured </span><span class="cov0" title="0">{
                                storageSafety = StorageSafetyEncrypted
                        }</span> else<span class="cov0" title="0"> {
                                storageSafety = StorageSafetyPreferEncrypted
                        }</span>
                }

                <span class="cov0" title="0">if grade == ModelSecured &amp;&amp; storageSafety != StorageSafetyEncrypted </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`secured grade model must not have storage-safety overridden, only "encrypted" is valid`)
                }</span>

                <span class="cov0" title="0">modSnaps, err = checkExtendedSnaps(extendedSnaps, base, grade, classic)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">hasKernel := modSnaps.kernel != nil
                hasGadget := modSnaps.gadget != nil
                if !classic </span><span class="cov0" title="0">{
                        if !hasGadget </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`one "snaps" header entry must specify the model gadget`)
                        }</span>
                        <span class="cov0" title="0">if !hasKernel </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`one "snaps" header entry must specify the model kernel`)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if hasKernel &amp;&amp; !hasGadget </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify a kernel in an extended classic model without a model gadget")
                        }</span>
                }

                <span class="cov0" title="0">if modSnaps.base == nil </span><span class="cov0" title="0">{
                        // complete with defaults,
                        // the assumption is that base names are very stable
                        // essentially fixed
                        modSnaps.base = baseSnap
                        snapID := naming.WellKnownSnapID(modSnaps.base.Name)
                        if snapID == "" &amp;&amp; grade != ModelDangerous </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`cannot specify not well-known base %q without a corresponding "snaps" header entry`, modSnaps.base.Name)
                        }</span>
                        <span class="cov0" title="0">modSnaps.base.SnapID = snapID
                        modSnaps.base.Modes = essentialSnapModes
                        modSnaps.base.DefaultChannel = "latest/stable"</span>
                }
        } else<span class="cov0" title="0"> {
                modSnaps = &amp;modelSnaps{
                        base: baseSnap,
                }
                // kernel/gadget must be valid snap names and can have (optional) tracks
                // - validate those
                modSnaps.kernel, err = checkSnapWithTrack(assert.headers, "kernel")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">modSnaps.gadget, err = checkSnapWithTrack(assert.headers, "gadget")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // required snap must be valid snap names
                <span class="cov0" title="0">reqSnaps, err := checkStringList(assert.headers, "required-snaps")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, name := range reqSnaps </span><span class="cov0" title="0">{
                        reqSnap, err := checkRequiredSnap(name, "required-snaps", "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">modSnaps.snapsNoEssential = append(modSnaps.snapsNoEssential, reqSnap)</span>
                }
        }

        <span class="cov0" title="0">brandID := assert.HeaderString("brand-id")

        serialAuthority, err := checkOptionalSerialAuthority(assert.headers, brandID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sysUserAuthority, err := checkOptionalSystemUserAuthority(assert.headers, brandID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">preseedAuthority, err := checkOptionalPreseedAuthority(assert.headers, brandID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allSnaps, requiredWithEssentialSnaps, numEssentialSnaps := modSnaps.list()

        valSets, err := checkOptionalModelValidationSets(assert.headers, brandID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // NB:
        // * core is not supported at this time, it defaults to ubuntu-core
        // in prepare-image until rename and/or introduction of the header.
        // * some form of allowed-modes, class are postponed,
        //
        // prepare-image takes care of not allowing them for now

        // ignore extra headers and non-empty body for future compatibility
        <span class="cov0" title="0">return &amp;Model{
                assertionBase:              assert,
                classic:                    classic,
                baseSnap:                   modSnaps.base,
                gadgetSnap:                 modSnaps.gadget,
                kernelSnap:                 modSnaps.kernel,
                grade:                      grade,
                storageSafety:              storageSafety,
                allSnaps:                   allSnaps,
                requiredWithEssentialSnaps: requiredWithEssentialSnaps,
                numEssentialSnaps:          numEssentialSnaps,
                validationSets:             valSets,
                serialAuthority:            serialAuthority,
                sysUserAuthority:           sysUserAuthority,
                preseedAuthority:           preseedAuthority,
                timestamp:                  timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2020-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"

        "github.com/snapcore/snapd/asserts/internal"
)

// A Grouping identifies opaquely a grouping of assertions.
// Pool uses it to label the intersection between a set of groups.
type Grouping string

// A pool helps holding and tracking a set of assertions and their
// prerequisites as they need to be updated or resolved.  The
// assertions can be organized in groups. Failure can be tracked
// isolated to groups, conversely any error related to a single group
// alone will stop any work to resolve it. Independent assertions
// should not be grouped. Assertions and prerequisites that are part
// of more than one group are tracked properly only once.
//
// Typical usage involves specifying the initial assertions needing to
// be resolved or updated using AddUnresolved and AddToUpdate.
// AddUnresolvedSequence and AddSequenceToUpdate exist parallel to
// AddUnresolved/AddToUpdate to handle sequence-forming assertions,
// which cannot be used with the latter.
// At this point ToResolve can be called to get them organized in
// groupings ready for fetching. Fetched assertions can then be provided
// with Add or AddBatch. Because these can have prerequisites calling
// ToResolve and fetching needs to be repeated until ToResolve's
// result is empty.  Between any two ToResolve invocations but after
// any Add or AddBatch AddUnresolved/AddToUpdate can also be used
// again.
//
//                      V
//                      |
//        /-&gt; AddUnresolved, AddToUpdate
//        |             |
//        |             V
//        |------&gt; ToResolve -&gt; empty? done
//        |             |
//        |             V
//        \ __________ Add
//
// If errors prevent from fulfilling assertions from a ToResolve,
// AddError and AddGroupingError can be used to report the errors so
// that they can be associated with groups.
//
// All the resolved assertions in a Pool from groups not in error can
// be committed to a destination database with CommitTo.
type Pool struct {
        groundDB RODatabase

        numbering map[string]uint16
        groupings *internal.Groupings

        unresolved          map[string]unresolvedAssertRecord
        unresolvedSequences map[string]unresolvedAssertRecord
        prerequisites       map[string]unresolvedAssertRecord

        bs        Backstore
        unchanged map[string]bool

        groups map[uint16]*groupRec

        curPhase poolPhase
}

// NewPool creates a new Pool, groundDB is used to resolve trusted and
// predefined assertions and to provide the current revision for
// assertions to update and their prerequisites. Up to n groups can be
// used to organize the assertions.
func NewPool(groundDB RODatabase, n int) *Pool <span class="cov0" title="0">{
        groupings, err := internal.NewGroupings(n)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("NewPool: %v", err))</span>
        }
        <span class="cov0" title="0">return &amp;Pool{
                groundDB:            groundDB,
                numbering:           make(map[string]uint16),
                groupings:           groupings,
                unresolved:          make(map[string]unresolvedAssertRecord),
                unresolvedSequences: make(map[string]unresolvedAssertRecord),
                prerequisites:       make(map[string]unresolvedAssertRecord),
                bs:                  NewMemoryBackstore(),
                unchanged:           make(map[string]bool),
                groups:              make(map[uint16]*groupRec),
        }</span>
}

func (p *Pool) groupNum(group string) (gnum uint16, err error) <span class="cov0" title="0">{
        if gnum, ok := p.numbering[group]; ok </span><span class="cov0" title="0">{
                return gnum, nil
        }</span>
        <span class="cov0" title="0">gnum = uint16(len(p.numbering))
        if err = p.groupings.WithinRange(gnum); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">p.numbering[group] = gnum
        return gnum, nil</span>
}

func (p *Pool) ensureGroup(group string) (gnum uint16, err error) <span class="cov0" title="0">{
        gnum, err = p.groupNum(group)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if gRec := p.groups[gnum]; gRec == nil </span><span class="cov0" title="0">{
                p.groups[gnum] = &amp;groupRec{
                        name: group,
                }
        }</span>
        <span class="cov0" title="0">return gnum, nil</span>
}

// Singleton returns a grouping containing only the given group.
// It is useful mainly for tests and to drive Add are AddBatch when the
// server is pushing assertions (instead of the usual pull scenario).
func (p *Pool) Singleton(group string) (Grouping, error) <span class="cov0" title="0">{
        gnum, err := p.ensureGroup(group)
        if err != nil </span><span class="cov0" title="0">{
                return Grouping(""), nil
        }</span>

        <span class="cov0" title="0">var grouping internal.Grouping
        p.groupings.AddTo(&amp;grouping, gnum)
        return Grouping(p.groupings.Serialize(&amp;grouping)), nil</span>
}

type unresolvedAssertRecord interface {
        isAssertionNewer(a Assertion) bool
        groupingPtr() *internal.Grouping
        label() Grouping
        isRevisionNotKnown() bool
        error() error
}

// An unresolvedRec tracks a single unresolved assertion until it is
// resolved or there is an error doing so. The field 'grouping' will
// grow to contain all the groups requiring this assertion while it
// is unresolved.
type unresolvedRec struct {
        at       *AtRevision
        grouping internal.Grouping

        serializedLabel Grouping

        err error
}

func (u *unresolvedRec) isAssertionNewer(a Assertion) bool <span class="cov0" title="0">{
        return a.Revision() &gt; u.at.Revision
}</span>

func (u *unresolvedRec) groupingPtr() *internal.Grouping <span class="cov0" title="0">{
        return &amp;u.grouping
}</span>

func (u *unresolvedRec) label() Grouping <span class="cov0" title="0">{
        return u.serializedLabel
}</span>

func (u *unresolvedRec) isRevisionNotKnown() bool <span class="cov0" title="0">{
        return u.at.Revision == RevisionNotKnown
}</span>

func (u *unresolvedRec) error() error <span class="cov0" title="0">{
        return u.err
}</span>

func (u *unresolvedRec) exportTo(r map[Grouping][]*AtRevision, gr *internal.Groupings) <span class="cov0" title="0">{
        serLabel := Grouping(gr.Serialize(&amp;u.grouping))
        // remember serialized label
        u.serializedLabel = serLabel
        r[serLabel] = append(r[serLabel], u.at)
}</span>

func (u *unresolvedRec) merge(at *AtRevision, gnum uint16, gr *internal.Groupings) <span class="cov0" title="0">{
        gr.AddTo(&amp;u.grouping, gnum)
        // assume we want to resolve/update wrt the highest revision
        if at.Revision &gt; u.at.Revision </span><span class="cov0" title="0">{
                u.at.Revision = at.Revision
        }</span>
}

type unresolvedSeqRec struct {
        at       *AtSequence
        grouping internal.Grouping

        serializedLabel Grouping

        err error
}

func (u *unresolvedSeqRec) groupingPtr() *internal.Grouping <span class="cov0" title="0">{
        return &amp;u.grouping
}</span>

func (u *unresolvedSeqRec) label() Grouping <span class="cov0" title="0">{
        return u.serializedLabel
}</span>

func (u *unresolvedSeqRec) isAssertionNewer(a Assertion) bool <span class="cov0" title="0">{
        seqf, ok := a.(SequenceMember)
        if !ok </span><span class="cov0" title="0">{
                // This should never happen because resolveWith() compares correct types.
                panic(fmt.Sprintf("internal error: cannot compare assertion %v with unresolved sequence-forming assertion (wrong type)", a.Ref()))</span>
        }
        <span class="cov0" title="0">if u.at.Pinned </span><span class="cov0" title="0">{
                return seqf.Sequence() == u.at.Sequence &amp;&amp; a.Revision() &gt; u.at.Revision
        }</span>
        // not pinned
        <span class="cov0" title="0">if seqf.Sequence() == u.at.Sequence </span><span class="cov0" title="0">{
                return a.Revision() &gt; u.at.Revision
        }</span>
        <span class="cov0" title="0">return seqf.Sequence() &gt; u.at.Sequence</span>
}

func (u *unresolvedSeqRec) isRevisionNotKnown() bool <span class="cov0" title="0">{
        return u.at.Revision == RevisionNotKnown
}</span>

func (u *unresolvedSeqRec) error() error <span class="cov0" title="0">{
        return u.err
}</span>

func (u *unresolvedSeqRec) exportTo(r map[Grouping][]*AtSequence, gr *internal.Groupings) <span class="cov0" title="0">{
        serLabel := Grouping(gr.Serialize(&amp;u.grouping))
        // remember serialized label
        u.serializedLabel = serLabel
        r[serLabel] = append(r[serLabel], u.at)
}</span>

// A groupRec keeps track of all the resolved assertions in a group
// or whether the group should be considered in error (err != nil).
type groupRec struct {
        name     string
        err      error
        resolved []Ref
}

func (gRec *groupRec) hasErr() bool <span class="cov0" title="0">{
        return gRec.err != nil
}</span>

func (gRec *groupRec) setErr(e error) <span class="cov0" title="0">{
        if gRec.err == nil </span><span class="cov0" title="0">{
                gRec.err = e
        }</span>
}

func (gRec *groupRec) markResolved(ref *Ref) (marked bool) <span class="cov0" title="0">{
        if gRec.hasErr() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">gRec.resolved = append(gRec.resolved, *ref)
        return true</span>
}

// markResolved marks the assertion referenced by ref as resolved
// in all the groups in grouping, except those already in error.
func (p *Pool) markResolved(grouping *internal.Grouping, resolved *Ref) (marked bool) <span class="cov0" title="0">{
        p.groupings.Iter(grouping, func(gnum uint16) error </span><span class="cov0" title="0">{
                if p.groups[gnum].markResolved(resolved) </span><span class="cov0" title="0">{
                        marked = true
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return marked</span>
}

// setErr marks all the groups in grouping as in error with error err
// except those already in error.
func (p *Pool) setErr(grouping *internal.Grouping, err error) <span class="cov0" title="0">{
        p.groupings.Iter(grouping, func(gnum uint16) error </span><span class="cov0" title="0">{
                p.groups[gnum].setErr(err)
                return nil
        }</span>)
}

func (p *Pool) isPredefined(ref *Ref) (bool, error) <span class="cov0" title="0">{
        _, err := ref.Resolve(p.groundDB.FindPredefined)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

func (p *Pool) isResolved(ref *Ref) (bool, error) <span class="cov0" title="0">{
        if p.unchanged[ref.Unique()] </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">_, err := p.bs.Get(ref.Type, ref.PrimaryKey, ref.Type.MaxSupportedFormat())
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

func (p *Pool) curRevision(ref *Ref) (int, error) <span class="cov0" title="0">{
        a, err := ref.Resolve(p.groundDB.Find)
        if err != nil &amp;&amp; !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return a.Revision(), nil
        }</span>
        <span class="cov0" title="0">return RevisionNotKnown, nil</span>
}

func (p *Pool) curSeqRevision(seq *AtSequence) (int, error) <span class="cov0" title="0">{
        a, err := seq.Resolve(p.groundDB.Find)
        if err != nil &amp;&amp; !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return a.Revision(), nil
        }</span>
        <span class="cov0" title="0">return RevisionNotKnown, nil</span>
}

type poolPhase int

const (
        poolPhaseAddUnresolved = iota
        poolPhaseAdd
)

func (p *Pool) phase(ph poolPhase) error <span class="cov0" title="0">{
        if ph == p.curPhase </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if ph == poolPhaseAdd </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot switch to Pool add phase without invoking ToResolve first")
        }</span>
        // ph == poolPhaseAddUnresolved
        <span class="cov0" title="0">p.unresolvedBookkeeping()
        p.curPhase = poolPhaseAddUnresolved
        return nil</span>
}

// AddUnresolved adds the assertion referenced by unresolved
// AtRevision to the Pool as unresolved and as required by the given group.
// Usually unresolved.Revision will have been set to RevisionNotKnown.
func (p *Pool) AddUnresolved(unresolved *AtRevision, group string) error <span class="cov0" title="0">{
        if unresolved.Type.SequenceForming() </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: AddUnresolved requested for sequence-forming assertion")
        }</span>

        <span class="cov0" title="0">if err := p.phase(poolPhaseAddUnresolved); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gnum, err := p.ensureGroup(group)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u := *unresolved
        ok, err := p.isPredefined(&amp;u.Ref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                // predefined, nothing to do
                return nil
        }</span>
        <span class="cov0" title="0">return p.addUnresolved(&amp;u, gnum)</span>
}

// AddUnresolvedSequence adds the assertion referenced by unresolved
// AtSequence to the Pool as unresolved and as required by the given group.
// Usually unresolved.Revision will have been set to RevisionNotKnown.
// Given sequence can only be added once to the Pool.
func (p *Pool) AddUnresolvedSequence(unresolved *AtSequence, group string) error <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAddUnresolved); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if p.unresolvedSequences[unresolved.Unique()] != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: sequence %v is already being resolved", unresolved.SequenceKey)
        }</span>
        <span class="cov0" title="0">gnum, err := p.ensureGroup(group)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u := *unresolved
        p.addUnresolvedSeq(&amp;u, gnum)
        return nil</span>
}

func (p *Pool) addUnresolved(unresolved *AtRevision, gnum uint16) error <span class="cov0" title="0">{
        ok, err := p.isResolved(&amp;unresolved.Ref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                // We assume that either the resolving of
                // prerequisites for the already resolved assertion in
                // progress has succeeded or will. If that's not the
                // case we will fail at CommitTo time. We could
                // instead recurse into its prerequisites again but the
                // complexity isn't clearly worth it.
                // See TestParallelPartialResolutionFailure
                // Mark this as resolved in the group.
                p.groups[gnum].markResolved(&amp;unresolved.Ref)
                return nil
        }</span>
        <span class="cov0" title="0">uniq := unresolved.Ref.Unique()
        var u unresolvedAssertRecord
        if u = p.unresolved[uniq]; u == nil </span><span class="cov0" title="0">{
                u = &amp;unresolvedRec{
                        at: unresolved,
                }
                p.unresolved[uniq] = u
        }</span>

        <span class="cov0" title="0">urec := u.(*unresolvedRec)
        urec.merge(unresolved, gnum, p.groupings)
        return nil</span>
}

func (p *Pool) addUnresolvedSeq(unresolved *AtSequence, gnum uint16) error <span class="cov0" title="0">{
        uniq := unresolved.Unique()
        u := &amp;unresolvedSeqRec{
                at: unresolved,
        }
        p.unresolvedSequences[uniq] = u
        return p.groupings.AddTo(&amp;u.grouping, gnum)
}</span>

// ToResolve returns all the currently unresolved assertions in the
// Pool, organized in opaque groupings based on which set of groups
// requires each of them.
// At the next ToResolve any unresolved assertion with not known
// revision that was not added via Add or AddBatch will result in all
// groups requiring it being in error with ErrUnresolved.
// Conversely, the remaining unresolved assertions originally added
// via AddToUpdate will be assumed to still be at their current
// revisions.
func (p *Pool) ToResolve() (map[Grouping][]*AtRevision, map[Grouping][]*AtSequence, error) <span class="cov0" title="0">{
        if p.curPhase == poolPhaseAdd </span><span class="cov0" title="0">{
                p.unresolvedBookkeeping()
        }</span> else<span class="cov0" title="0"> {
                p.curPhase = poolPhaseAdd
        }</span>
        <span class="cov0" title="0">atr := make(map[Grouping][]*AtRevision)
        for _, ur := range p.unresolved </span><span class="cov0" title="0">{
                u := ur.(*unresolvedRec)
                if u.at.Revision == RevisionNotKnown </span><span class="cov0" title="0">{
                        rev, err := p.curRevision(&amp;u.at.Ref)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">if rev != RevisionNotKnown </span><span class="cov0" title="0">{
                                u.at.Revision = rev
                        }</span>
                }
                <span class="cov0" title="0">u.exportTo(atr, p.groupings)</span>
        }

        <span class="cov0" title="0">ats := make(map[Grouping][]*AtSequence)
        for _, u := range p.unresolvedSequences </span><span class="cov0" title="0">{
                seq := u.(*unresolvedSeqRec)
                if seq.at.Revision == RevisionNotKnown </span><span class="cov0" title="0">{
                        rev, err := p.curSeqRevision(seq.at)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">if rev != RevisionNotKnown </span><span class="cov0" title="0">{
                                seq.at.Revision = rev
                        }</span>
                }
                <span class="cov0" title="0">seq.exportTo(ats, p.groupings)</span>
        }
        <span class="cov0" title="0">return atr, ats, nil</span>
}

func (p *Pool) addPrerequisite(pref *Ref, g *internal.Grouping) error <span class="cov0" title="0">{
        uniq := pref.Unique()
        u := p.unresolved[uniq]
        at := &amp;AtRevision{
                Ref:      *pref,
                Revision: RevisionNotKnown,
        }
        if u == nil </span><span class="cov0" title="0">{
                u = p.prerequisites[uniq]
        }</span>
        <span class="cov0" title="0">if u != nil </span><span class="cov0" title="0">{
                gr := p.groupings
                gr.Iter(g, func(gnum uint16) error </span><span class="cov0" title="0">{
                        urec := u.(*unresolvedRec)
                        urec.merge(at, gnum, gr)
                        return nil
                }</span>)
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">ok, err := p.isPredefined(pref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                // nothing to do
                return nil
        }</span>
        <span class="cov0" title="0">ok, err = p.isResolved(pref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                // nothing to do, it is anyway implied
                return nil
        }</span>
        <span class="cov0" title="0">p.prerequisites[uniq] = &amp;unresolvedRec{
                at:       at,
                grouping: g.Copy(),
        }
        return nil</span>
}

func (p *Pool) add(a Assertion, g *internal.Grouping) error <span class="cov0" title="0">{
        if err := p.bs.Put(a.Type(), a); err != nil </span><span class="cov0" title="0">{
                if revErr, ok := err.(*RevisionError); ok </span><span class="cov0" title="0">{
                        if revErr.Current &gt;= a.Revision() </span><span class="cov0" title="0">{
                                // we already got something more recent
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">for _, pref := range a.Prerequisites() </span><span class="cov0" title="0">{
                if err := p.addPrerequisite(pref, g); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">keyRef := &amp;Ref{
                Type:       AccountKeyType,
                PrimaryKey: []string{a.SignKeyID()},
        }
        return p.addPrerequisite(keyRef, g)</span>
}

func (p *Pool) resolveWith(unresolved map[string]unresolvedAssertRecord, uniq string, u unresolvedAssertRecord, a Assertion, extrag *internal.Grouping) (ok bool, err error) <span class="cov0" title="0">{
        if u.isAssertionNewer(a) </span><span class="cov0" title="0">{
                if extrag == nil </span><span class="cov0" title="0">{
                        extrag = u.groupingPtr()
                }</span> else<span class="cov0" title="0"> {
                        p.groupings.Iter(u.groupingPtr(), func(gnum uint16) error </span><span class="cov0" title="0">{
                                p.groupings.AddTo(extrag, gnum)
                                return nil
                        }</span>)
                }
                <span class="cov0" title="0">ref := a.Ref()
                if p.markResolved(extrag, ref) </span><span class="cov0" title="0">{
                        // remove from tracking -
                        // remove u from unresolved only if the assertion
                        // is added to the resolved backstore;
                        // otherwise it might resurface as unresolved;
                        // it will be ultimately handled in
                        // unresolvedBookkeeping if it stays around
                        delete(unresolved, uniq)
                        if err := p.add(a, extrag); err != nil </span><span class="cov0" title="0">{
                                p.setErr(extrag, err)
                                return false, err
                        }</span>
                }
        }
        <span class="cov0" title="0">return true, nil</span>
}

// Add adds the given assertion associated with the given grouping to the
// Pool as resolved in all the groups requiring it.
// Any not already resolved prerequisites of the assertion will
// be implicitly added as unresolved and required by all of those groups.
// The grouping will usually have been associated with the assertion
// in a ToResolve's result. Otherwise the union of all groups
// requiring the assertion plus the groups in grouping will be considered.
// The latter is mostly relevant in scenarios where the server is pushing
// assertions.
// If an error is returned it refers to an immediate or local error.
// Errors related to the assertions are associated with the relevant groups
// and can be retrieved with Err, in which case ok is set to false.
func (p *Pool) Add(a Assertion, grouping Grouping) (ok bool, err error) <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAdd); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if !a.SupportedFormat() </span><span class="cov0" title="0">{
                e := &amp;UnsupportedFormatError{Ref: a.Ref(), Format: a.Format()}
                p.AddGroupingError(e, grouping)
                return false, nil
        }</span>

        <span class="cov0" title="0">return p.addToGrouping(a, grouping, p.groupings.Deserialize)</span>
}

func (p *Pool) addToGrouping(a Assertion, grouping Grouping, deserializeGrouping func(string) (*internal.Grouping, error)) (ok bool, err error) <span class="cov0" title="0">{
        var uniq string
        ref := a.Ref()
        var u unresolvedAssertRecord
        var extrag *internal.Grouping
        var unresolved map[string]unresolvedAssertRecord

        if !ref.Type.SequenceForming() </span><span class="cov0" title="0">{
                uniq = ref.Unique()
                if u = p.unresolved[uniq]; u != nil </span><span class="cov0" title="0">{
                        unresolved = p.unresolved
                }</span> else<span class="cov0" title="0"> if u = p.prerequisites[uniq]; u != nil </span><span class="cov0" title="0">{
                        unresolved = p.prerequisites
                }</span> else<span class="cov0" title="0"> {
                        ok, err := p.isPredefined(a.Ref())
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                // nothing to do
                                return true, nil
                        }</span>
                        // a is not tracked as unresolved in any way so far,
                        // this is an atypical scenario where something gets
                        // pushed but we still want to add it to the resolved
                        // lists of the relevant groups; in case it is
                        // actually already resolved most of resolveWith below will
                        // be a nop
                        <span class="cov0" title="0">rec := &amp;unresolvedRec{
                                at: a.At(),
                        }
                        rec.at.Revision = RevisionNotKnown
                        u = rec</span>
                }
        } else<span class="cov0" title="0"> {
                atseq := AtSequence{
                        Type:        ref.Type,
                        SequenceKey: ref.PrimaryKey[:len(ref.PrimaryKey)-1],
                }
                uniq = atseq.Unique()
                if u = p.unresolvedSequences[uniq]; u != nil </span><span class="cov0" title="0">{
                        unresolved = p.unresolvedSequences
                }</span> else<span class="cov0" title="0"> {
                        // note: sequence-forming assertions are never prerequisites.
                        at := a.At()
                        // a is not tracked as unresolved in any way so far,
                        // this is an atypical scenario where something gets
                        // pushed but we still want to add it to the resolved
                        // lists of the relevant groups; in case it is
                        // actually already resolved most of resolveWith below will
                        // be a nop
                        rec := &amp;unresolvedSeqRec{
                                at: &amp;AtSequence{
                                        Type:        a.Type(),
                                        SequenceKey: at.PrimaryKey[:len(at.PrimaryKey)-1],
                                },
                        }
                        rec.at.Revision = RevisionNotKnown
                        u = rec
                }</span>
        }

        <span class="cov0" title="0">if u.label() != grouping </span><span class="cov0" title="0">{
                var err error
                extrag, err = deserializeGrouping(string(grouping))
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">return p.resolveWith(unresolved, uniq, u, a, extrag)</span>
}

// AddBatch adds all the assertions in the Batch to the Pool,
// associated with the given grouping and as resolved in all the
// groups requiring them. It is equivalent to using Add on each of them.
// If an error is returned it refers to an immediate or local error.
// Errors related to the assertions are associated with the relevant groups
// and can be retrieved with Err, in which case ok set to false.
func (p *Pool) AddBatch(b *Batch, grouping Grouping) (ok bool, err error) <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAdd); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // b dealt with unsupported formats already

        // deserialize grouping if needed only once
        <span class="cov0" title="0">var cachedGrouping *internal.Grouping
        deser := func(_ string) (*internal.Grouping, error) </span><span class="cov0" title="0">{
                if cachedGrouping != nil </span><span class="cov0" title="0">{
                        // do a copy as addToGrouping and resolveWith
                        // might add to their input
                        g := cachedGrouping.Copy()
                        return &amp;g, nil
                }</span>
                <span class="cov0" title="0">var err error
                cachedGrouping, err = p.groupings.Deserialize(string(grouping))
                return cachedGrouping, err</span>
        }

        <span class="cov0" title="0">inError := false
        for _, a := range b.added </span><span class="cov0" title="0">{
                ok, err := p.addToGrouping(a, grouping, deser)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        inError = true
                }</span>
        }

        <span class="cov0" title="0">return !inError, nil</span>
}

var (
        ErrUnresolved       = errors.New("unresolved assertion")
        ErrUnknownPoolGroup = errors.New("unknown pool group")
)

// unresolvedBookkeeping processes any left over unresolved assertions
// since the last ToResolve invocation and intervening calls to Add/AddBatch,
//   - they were either marked as in error which will be propagated
//     to all groups requiring them
//   - simply unresolved, which will be propagated to groups requiring them
//     as ErrUnresolved
//   - unchanged (update case)
//
// unresolvedBookkeeping will also promote any recorded prerequisites
// into actively unresolved, as long as not all the groups requiring them
// are in error.
func (p *Pool) unresolvedBookkeeping() <span class="cov0" title="0">{
        // any left over unresolved are either:
        //  * in error
        //  * unchanged
        //  * or unresolved
        processUnresolved := func(unresolved map[string]unresolvedAssertRecord) </span><span class="cov0" title="0">{
                for uniq, ur := range unresolved </span><span class="cov0" title="0">{
                        e := ur.error()
                        if e == nil </span><span class="cov0" title="0">{
                                if ur.isRevisionNotKnown() </span><span class="cov0" title="0">{
                                        e = ErrUnresolved
                                }</span> else<span class="cov0" title="0"> {
                                        // unchanged
                                        p.unchanged[uniq] = true
                                }</span>
                        }
                        <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                                p.setErr(ur.groupingPtr(), e)
                        }</span>
                        <span class="cov0" title="0">delete(unresolved, uniq)</span>
                }
        }
        <span class="cov0" title="0">processUnresolved(p.unresolved)
        processUnresolved(p.unresolvedSequences)

        // prerequisites will become the new unresolved but drop them
        // if all their groups are in error
        for uniq, pr := range p.prerequisites </span><span class="cov0" title="0">{
                prereq := pr.(*unresolvedRec)
                useful := false
                p.groupings.Iter(&amp;prereq.grouping, func(gnum uint16) error </span><span class="cov0" title="0">{
                        if !p.groups[gnum].hasErr() </span><span class="cov0" title="0">{
                                useful = true
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if !useful </span><span class="cov0" title="0">{
                        delete(p.prerequisites, uniq)
                        continue</span>
                }
        }

        // prerequisites become the new unresolved, the emptied
        // unresolved is used for prerequisites in the next round
        <span class="cov0" title="0">p.unresolved, p.prerequisites = p.prerequisites, p.unresolved</span>
}

// Err returns the error for group if group is in error, nil otherwise.
func (p *Pool) Err(group string) error <span class="cov0" title="0">{
        gnum, err := p.groupNum(group)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gRec := p.groups[gnum]
        if gRec == nil </span><span class="cov0" title="0">{
                return ErrUnknownPoolGroup
        }</span>
        <span class="cov0" title="0">return gRec.err</span>
}

// Errors returns a mapping of groups in error to their errors.
func (p *Pool) Errors() map[string]error <span class="cov0" title="0">{
        res := make(map[string]error)
        for _, gRec := range p.groups </span><span class="cov0" title="0">{
                if err := gRec.err; err != nil </span><span class="cov0" title="0">{
                        res[gRec.name] = err
                }</span>
        }
        <span class="cov0" title="0">if len(res) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return res</span>
}

// AddError associates error e with the unresolved assertion.
// The error will be propagated to all the affected groups at
// the next ToResolve.
func (p *Pool) AddError(e error, ref *Ref) error <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAdd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uniq := ref.Unique()
        if u := p.unresolved[uniq]; u != nil &amp;&amp; u.(*unresolvedRec).err == nil </span><span class="cov0" title="0">{
                u.(*unresolvedRec).err = e
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddSequenceError associates error e with the unresolved sequence-forming
// assertion.
// The error will be propagated to all the affected groups at
// the next ToResolve.
func (p *Pool) AddSequenceError(e error, atSeq *AtSequence) error <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAdd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uniq := atSeq.Unique()
        if u := p.unresolvedSequences[uniq]; u != nil &amp;&amp; u.(*unresolvedSeqRec).err == nil </span><span class="cov0" title="0">{
                u.(*unresolvedSeqRec).err = e
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddGroupingError puts all the groups of grouping in error, with error e.
func (p *Pool) AddGroupingError(e error, grouping Grouping) error <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAdd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">g, err := p.groupings.Deserialize(string(grouping))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">p.setErr(g, e)
        return nil</span>
}

// AddToUpdate adds the assertion referenced by toUpdate and all its
// prerequisites to the Pool as unresolved and as required by the
// given group. It is assumed that the assertion is currently in the
// ground database of the Pool, otherwise this will error.
// The current revisions of the assertion and its prerequisites will
// be recorded and only higher revisions will then resolve them,
// otherwise if ultimately unresolved they will be assumed to still be
// at their current ones.
func (p *Pool) AddToUpdate(toUpdate *Ref, group string) error <span class="cov0" title="0">{
        if toUpdate.Type.SequenceForming() </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: AddToUpdate requested for sequence-forming assertion")
        }</span>
        <span class="cov0" title="0">if err := p.phase(poolPhaseAddUnresolved); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gnum, err := p.ensureGroup(group)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">retrieve := func(ref *Ref) (Assertion, error) </span><span class="cov0" title="0">{
                return ref.Resolve(p.groundDB.Find)
        }</span>
        <span class="cov0" title="0">add := func(a Assertion) error </span><span class="cov0" title="0">{
                return p.addUnresolved(a.At(), gnum)
        }</span>
        <span class="cov0" title="0">f := NewFetcher(p.groundDB, retrieve, add)
        if err := f.Fetch(toUpdate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddSequenceToUpdate adds the assertion referenced by toUpdate and all its
// prerequisites to the Pool as unresolved and as required by the
// given group. It is assumed that the assertion is currently in the
// ground database of the Pool, otherwise this will error.
// The current revisions of the assertion and its prerequisites will
// be recorded and only higher revisions will then resolve them,
// otherwise if ultimately unresolved they will be assumed to still be
// at their current ones. If toUpdate is pinned, then it will be resolved
// to the highest revision with same sequence point (toUpdate.Sequence).
func (p *Pool) AddSequenceToUpdate(toUpdate *AtSequence, group string) error <span class="cov0" title="0">{
        if err := p.phase(poolPhaseAddUnresolved); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if toUpdate.Sequence &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: sequence to update must have a sequence number set")
        }</span>
        <span class="cov0" title="0">if p.unresolvedSequences[toUpdate.Unique()] != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: sequence %v is already being resolved", toUpdate.SequenceKey)
        }</span>
        <span class="cov0" title="0">gnum, err := p.ensureGroup(group)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">retrieve := func(ref *Ref) (Assertion, error) </span><span class="cov0" title="0">{
                return ref.Resolve(p.groundDB.Find)
        }</span>
        <span class="cov0" title="0">retrieveSeq := func(seq *AtSequence) (Assertion, error) </span><span class="cov0" title="0">{
                return seq.Resolve(p.groundDB.Find)
        }</span>
        <span class="cov0" title="0">add := func(a Assertion) error </span><span class="cov0" title="0">{
                if !a.Type().SequenceForming() </span><span class="cov0" title="0">{
                        return p.addUnresolved(a.At(), gnum)
                }</span>
                // sequence forming assertions are never predefined, so no check for it.
                // final add corresponding to toUpdate itself.
                <span class="cov0" title="0">u := *toUpdate
                u.Revision = a.Revision()
                return p.addUnresolvedSeq(&amp;u, gnum)</span>
        }
        <span class="cov0" title="0">f := NewSequenceFormingFetcher(p.groundDB, retrieve, retrieveSeq, add)
        if err := f.FetchSequence(toUpdate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CommitTo adds the assertions from groups without errors to the
// given assertion database. Commit errors can be retrieved via Err
// per group. An error is returned directly only if CommitTo is called
// with possible pending unresolved assertions.
func (p *Pool) CommitTo(db *Database) error <span class="cov0" title="0">{
        if p.curPhase == poolPhaseAddUnresolved </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: cannot commit Pool during add unresolved phase")
        }</span>
        <span class="cov0" title="0">p.unresolvedBookkeeping()

        retrieve := func(ref *Ref) (Assertion, error) </span><span class="cov0" title="0">{
                a, err := p.bs.Get(ref.Type, ref.PrimaryKey, ref.Type.MaxSupportedFormat())
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        // fallback to pre-existing assertions
                        a, err = ref.Resolve(db.Find)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, resolveError("cannot resolve prerequisite assertion: %s", ref, err)
                }</span>
                <span class="cov0" title="0">return a, nil</span>
        }
        <span class="cov0" title="0">save := func(a Assertion) error </span><span class="cov0" title="0">{
                err := db.Add(a)
                if IsUnaccceptedUpdate(err) </span><span class="cov0" title="0">{
                        // unsupported format case is handled before.
                        // be idempotent, db has already the same or
                        // newer.
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

<span class="cov0" title="0">NextGroup:
        for _, gRec := range p.groups </span><span class="cov0" title="0">{
                if gRec.hasErr() </span><span class="cov0" title="0">{
                        // already in error, ignore
                        continue</span>
                }
                // TODO: try to reuse fetcher
                <span class="cov0" title="0">f := NewFetcher(db, retrieve, save)
                for i := range gRec.resolved </span><span class="cov0" title="0">{
                        if err := f.Fetch(&amp;gRec.resolved[i]); err != nil </span><span class="cov0" title="0">{
                                gRec.setErr(err)
                                continue NextGroup</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ClearGroups clears the pool in terms of information associated with groups
// while preserving information about already resolved or unchanged assertions.
// It is useful for reusing a pool once the maximum of usable groups
// that was set with NewPool has been exhausted. Group errors must be
// queried before calling it otherwise they are lost. It is an error
// to call it when there are still pending unresolved assertions in
// the pool.
func (p *Pool) ClearGroups() error <span class="cov0" title="0">{
        if len(p.unresolved) != 0 || len(p.prerequisites) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("internal error: trying to clear groups of asserts.Pool with pending unresolved or prerequisites")
        }</span>

        <span class="cov0" title="0">p.numbering = make(map[string]uint16)
        // use a fresh Groupings as well so that max group tracking starts
        // from scratch.
        // NewGroupings cannot fail on a value accepted by it previously
        p.groupings, _ = internal.NewGroupings(p.groupings.N())
        p.groups = make(map[uint16]*groupRec)
        p.curPhase = poolPhaseAdd
        return nil</span>
}

// Backstore returns the memory backstore of this pool.
func (p *Pool) Backstore() Backstore <span class="cov0" title="0">{
        return p.bs
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "crypto"
        "errors"
        "fmt"
        "regexp"
        "time"

        "github.com/snapcore/snapd/snap/naming"
)

// validSystemLabel is the regex describing a valid system label. Typically
// system labels are expected to be date based, eg. 20201116, but for
// completeness follow the same rule as model names (incl. one letter model
// names and thus system labels), with the exception that uppercase letters are
// not allowed, as the systems will often be stored in a FAT filesystem.
var validSystemLabel = regexp.MustCompile("^[a-z0-9](?:-?[a-z0-9])*$")

// IsValidSystemLabel checks whether the string is a valid UC20 seed system
// label.
func IsValidSystemLabel(label string) error <span class="cov0" title="0">{
        if !validSystemLabel.MatchString(label) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid seed system label: %q", label)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PreseedSnap holds the details about a snap constrained by a preseed assertion.
type PreseedSnap struct {
        Name       string
        SnapID     string
        Revision   int
        Components []PreseedComponent
}

type PreseedComponent struct {
        Name     string
        Revision int
}

// SnapName implements naming.SnapRef.
func (s *PreseedSnap) SnapName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ID implements naming.SnapRef.
func (s *PreseedSnap) ID() string <span class="cov0" title="0">{
        return s.SnapID
}</span>

// Preseed holds preseed assertion, which is a statement about system-label,
// model, set of snaps and preseed artifact used for preseeding of UC20 system.
type Preseed struct {
        assertionBase
        snaps     []*PreseedSnap
        timestamp time.Time
}

// Series returns the series that this assertion is valid for.
func (p *Preseed) Series() string <span class="cov0" title="0">{
        return p.HeaderString("series")
}</span>

// BrandID returns the brand identifier.
func (p *Preseed) BrandID() string <span class="cov0" title="0">{
        return p.HeaderString("brand-id")
}</span>

// Model returns the model name identifier.
func (p *Preseed) Model() string <span class="cov0" title="0">{
        return p.HeaderString("model")
}</span>

// SystemLabel returns the label of the seeded system.
func (p *Preseed) SystemLabel() string <span class="cov0" title="0">{
        return p.HeaderString("system-label")
}</span>

// Timestamp returns the time when the preseed assertion was issued.
func (p *Preseed) Timestamp() time.Time <span class="cov0" title="0">{
        return p.timestamp
}</span>

// ArtifactSHA3_384 returns the checksum of preseeding artifact.
func (p *Preseed) ArtifactSHA3_384() string <span class="cov0" title="0">{
        return p.HeaderString("artifact-sha3-384")
}</span>

// Snaps returns the snaps for preseeding.
func (p *Preseed) Snaps() []*PreseedSnap <span class="cov0" title="0">{
        return p.snaps
}</span>

func checkPreseedSnap(snap map[string]any) (*PreseedSnap, error) <span class="cov0" title="0">{
        name, err := checkNotEmptyStringWhat(snap, "name", "of snap")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := naming.ValidateSnap(name); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid snap name %q", name)
        }</span>

        <span class="cov0" title="0">what := fmt.Sprintf("of snap %q", name)

        // snap id can be omitted if the model allows for unasserted snaps
        var snapID string
        if _, ok := snap["id"]; ok </span><span class="cov0" title="0">{
                snapID, err = checkStringMatchesWhat(snap, "id", what, naming.ValidSnapID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Revision is x1 if unasserted, as that is what we will get on first installation
        <span class="cov0" title="0">snapRevision := -1
        if _, ok := snap["revision"]; ok </span><span class="cov0" title="0">{
                var err error
                snapRevision, err = checkSnapRevisionWhat(snap, "revision", what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if snapID != "" &amp;&amp; snapRevision &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("snap revision is required when snap id is set")
        }</span>
        <span class="cov0" title="0">if snapID == "" &amp;&amp; snapRevision &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("snap id is required when revision is set")
        }</span>

        <span class="cov0" title="0">var components []PreseedComponent
        if comps, ok := snap["components"]; ok </span><span class="cov0" title="0">{
                components, err = checkPreseedComponents(comps, snapRevision)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;PreseedSnap{
                Name:       name,
                SnapID:     snapID,
                Revision:   snapRevision,
                Components: components,
        }, nil</span>
}

func checkPreseedComponents(comps any, snapRevision int) ([]PreseedComponent, error) <span class="cov0" title="0">{
        const wrongHeaderType = `"components" header must be a list of maps`

        entries, ok := comps.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(wrongHeaderType)
        }</span>

        <span class="cov0" title="0">seen := make(map[string]bool)
        components := make([]PreseedComponent, 0, len(entries))
        for _, entry := range entries </span><span class="cov0" title="0">{
                comp, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(wrongHeaderType)
                }</span>

                <span class="cov0" title="0">preseedComp, err := checkPreseedComponent(comp, snapRevision)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if _, ok := seen[preseedComp.Name]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot list the same component %q multiple times", preseedComp.Name)
                }</span>

                <span class="cov0" title="0">seen[preseedComp.Name] = true
                components = append(components, preseedComp)</span>
        }

        <span class="cov0" title="0">return components, nil</span>
}

func checkPreseedComponent(comp map[string]any, snapRevision int) (PreseedComponent, error) <span class="cov0" title="0">{
        name, err := checkNotEmptyStringWhat(comp, "name", "of component")
        if err != nil </span><span class="cov0" title="0">{
                return PreseedComponent{}, err
        }</span>

        <span class="cov0" title="0">if err := naming.ValidateSnap(name); err != nil </span><span class="cov0" title="0">{
                return PreseedComponent{}, err
        }</span>
        <span class="cov0" title="0">what := fmt.Sprintf("of component %q", name)

        // Revision is x1 if unasserted, as that is what we will get on first installation
        revision := -1
        if _, ok := comp["revision"]; ok </span><span class="cov0" title="0">{
                revision, err = checkSnapRevisionWhat(comp, "revision", what)
                if err != nil </span><span class="cov0" title="0">{
                        return PreseedComponent{}, err
                }</span>
        }

        <span class="cov0" title="0">if revision &lt;= 0 &amp;&amp; snapRevision &gt; 0 </span><span class="cov0" title="0">{
                return PreseedComponent{}, fmt.Errorf("component %q must have a revision since its snap has a revision", name)
        }</span>

        <span class="cov0" title="0">if revision &gt; 0 &amp;&amp; snapRevision &lt;= 0 </span><span class="cov0" title="0">{
                return PreseedComponent{}, fmt.Errorf("component %q cannot have a revision since its snap has no revision", name)
        }</span>

        <span class="cov0" title="0">return PreseedComponent{
                Name:     name,
                Revision: revision,
        }, nil</span>
}

func checkPreseedSnaps(snapList any) ([]*PreseedSnap, error) <span class="cov0" title="0">{
        const wrongHeaderType = `"snaps" header must be a list of maps`

        entries, ok := snapList.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(wrongHeaderType)
        }</span>

        <span class="cov0" title="0">seen := make(map[string]bool, len(entries))
        seenIDs := make(map[string]string, len(entries))
        snaps := make([]*PreseedSnap, 0, len(entries))
        for _, entry := range entries </span><span class="cov0" title="0">{
                snap, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(wrongHeaderType)
                }</span>

                <span class="cov0" title="0">preseedSnap, err := checkPreseedSnap(snap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if seen[preseedSnap.Name] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot list the same snap %q multiple times", preseedSnap.Name)
                }</span>
                <span class="cov0" title="0">seen[preseedSnap.Name] = true
                snapID := preseedSnap.SnapID
                if snapID != "" </span><span class="cov0" title="0">{
                        if underName := seenIDs[snapID]; underName != "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot specify the same snap id %q multiple times, specified for snaps %q and %q", snapID, underName, preseedSnap.Name)
                        }</span>
                        <span class="cov0" title="0">seenIDs[snapID] = preseedSnap.Name</span>
                }
                <span class="cov0" title="0">snaps = append(snaps, preseedSnap)</span>
        }

        <span class="cov0" title="0">return snaps, nil</span>
}

func assemblePreseed(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        // because the authority-id and model-id can differ (as per the model),
        // authority-id should be validated against allowed IDs when the preseed
        // blob is being checked

        _, err := checkModel(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkStringMatches(assert.headers, "system-label", validSystemLabel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapList, ok := assert.headers["snaps"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"snaps" header is mandatory`)
        }</span>
        <span class="cov0" title="0">snaps, err := checkPreseedSnaps(snapList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkDigest(assert.headers, "artifact-sha3-384", crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Preseed{
                assertionBase: assert,
                snaps:         snaps,
                timestamp:     timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2017 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "strings"
        "time"

        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

// Repair holds an repair assertion which allows running repair
// code to fixup broken systems. It can be limited by series and models, as well
// as by bases and modes.
type Repair struct {
        assertionBase

        series        []string
        architectures []string
        models        []string

        modes []string
        bases []string

        id int

        disabled  bool
        timestamp time.Time
}

// BrandID returns the brand identifier that signed this assertion.
func (r *Repair) BrandID() string <span class="cov0" title="0">{
        return r.HeaderString("brand-id")
}</span>

// RepairID returns the sequential id of the repair. There
// should be a public place to look up details about the repair
// by brand-id and repair-id.
// (e.g. the snapcraft forum).
func (r *Repair) RepairID() int <span class="cov0" title="0">{
        return r.id
}</span>

// Sequence implements SequenceMember, it returns the same as RepairID.
func (r *Repair) Sequence() int <span class="cov0" title="0">{
        return r.RepairID()
}</span>

// Summary returns the mandatory summary description of the repair.
func (r *Repair) Summary() string <span class="cov0" title="0">{
        return r.HeaderString("summary")
}</span>

// Architectures returns the architectures that this assertions applies to.
func (r *Repair) Architectures() []string <span class="cov0" title="0">{
        return r.architectures
}</span>

// Series returns the series that this assertion is valid for.
func (r *Repair) Series() []string <span class="cov0" title="0">{
        return r.series
}</span>

// Modes returns the modes that this assertion is valid for. It is either a list
// of "run", "recover", or "install", or it is the empty list. The empty list
// is interpreted to mean only "run" mode.
func (r *Repair) Modes() []string <span class="cov0" title="0">{
        return r.modes
}</span>

// Bases returns the bases that this assertion is valid for. It is either a list
// of valid base snaps that Ubuntu Core systems can have or it is the empty
// list. The empty list effectively means all Ubuntu Core systems while "core"
// means Ubuntu Core 16, "core18" means Ubuntu Core 18, etc.
func (r *Repair) Bases() []string <span class="cov0" title="0">{
        return r.bases
}</span>

// Models returns the models that this assertion is valid for.
// It is a list of "brand-id/model-name" strings.
func (r *Repair) Models() []string <span class="cov0" title="0">{
        return r.models
}</span>

// Disabled returns true if the repair has been disabled.
func (r *Repair) Disabled() bool <span class="cov0" title="0">{
        return r.disabled
}</span>

// Timestamp returns the time when the repair was issued.
func (r *Repair) Timestamp() time.Time <span class="cov0" title="0">{
        return r.timestamp
}</span>

// Implement further consistency checks.
func (r *Repair) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // Do the cross-checks when this assertion is actually used,
        // i.e. in the future repair code

        return nil
}</span>

// expected interface is implemented
var _ consistencyChecker = (*Repair)(nil)

func assembleRepair(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        err := checkAuthorityMatchesBrand(&amp;assert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">repairID, err := checkSequence(assert.headers, "repair-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">summary, err := checkNotEmptyString(assert.headers, "summary")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if strings.ContainsAny(summary, "\n\r") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"summary" header cannot have newlines`)
        }</span>

        <span class="cov0" title="0">series, err := checkStringList(assert.headers, "series")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">models, err := checkStringList(assert.headers, "models")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">architectures, err := checkStringList(assert.headers, "architectures")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">modes, err := checkStringList(assert.headers, "modes")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bases, err := checkStringList(assert.headers, "bases")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // validate that all base snap names are valid snap names
        <span class="cov0" title="0">for _, b := range bases </span><span class="cov0" title="0">{
                if err := naming.ValidateSnap(b); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid snap name %q in \"bases\"", b)
                }</span>
        }

        // verify that modes is a list of only "run" and "recover"
        <span class="cov0" title="0">if len(modes) != 0 </span><span class="cov0" title="0">{
                for _, m := range modes </span><span class="cov0" title="0">{
                        // note that we could import boot here to use i.e. boot.ModeRun, but
                        // that is rather a heavy package considering that this package is
                        // used in many places, so instead just use the values directly,
                        // they're unlikely to change now
                        if !strutil.ListContains([]string{"run", "recover"}, m) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("header \"modes\" contains an invalid element: %q (valid values are run and recover)", m)
                        }</span>
                }

                // if modes is non-empty, then bases must be core2X, i.e. core20+
                // however, we don't know what future bases could be UC20-like and named
                // differently yet, so we just fail on bases that we know as of today
                // are _not_ UC20: core and core18

                <span class="cov0" title="0">for _, b := range bases </span><span class="cov0" title="0">{
                        // fail on uc16 and uc18 base snaps
                        if b == "core" || b == "core18" || b == "core16" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("in the presence of a non-empty \"modes\" header, \"bases\" must only contain base snaps supporting recovery modes")
                        }</span>
                }
        }

        <span class="cov0" title="0">disabled, err := checkOptionalBool(assert.headers, "disabled")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Repair{
                assertionBase: assert,
                series:        series,
                architectures: architectures,
                models:        models,
                modes:         modes,
                bases:         bases,
                id:            repairID,
                disabled:      disabled,
                timestamp:     timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "time"

        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/strutil"
)

// Serial holds a serial assertion, which is a statement binding a
// device identity with the device public key.
type Serial struct {
        assertionBase
        timestamp time.Time
        pubKey    PublicKey
}

// BrandID returns the brand identifier of the device.
func (ser *Serial) BrandID() string <span class="cov0" title="0">{
        return ser.HeaderString("brand-id")
}</span>

// Model returns the model name identifier of the device.
func (ser *Serial) Model() string <span class="cov0" title="0">{
        return ser.HeaderString("model")
}</span>

// Serial returns the serial identifier of the device, together with
// brand id and model they form the unique identifier of the device.
func (ser *Serial) Serial() string <span class="cov0" title="0">{
        return ser.HeaderString("serial")
}</span>

// DeviceKey returns the public key of the device.
func (ser *Serial) DeviceKey() PublicKey <span class="cov0" title="0">{
        return ser.pubKey
}</span>

// Timestamp returns the time when the serial assertion was issued.
func (ser *Serial) Timestamp() time.Time <span class="cov0" title="0">{
        return ser.timestamp
}</span>

func (ser *Serial) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        if ser.AuthorityID() != ser.BrandID() </span><span class="cov0" title="0">{
                // serial authority and brand do not match, check the model
                a, err := db.Find(ModelType, map[string]string{
                        "series":   release.Series,
                        "brand-id": ser.BrandID(),
                        "model":    ser.Model(),
                })
                if err != nil &amp;&amp; !errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if errors.Is(err, &amp;NotFoundError{}) || !strutil.ListContains(a.(*Model).SerialAuthority(), ser.AuthorityID()) </span><span class="cov0" title="0">{
                        return fmt.Errorf("serial with authority %q different from brand %q without model assertion with serial-authority set to to allow for them", ser.AuthorityID(), ser.BrandID())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func assembleSerial(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        // brand-id and authority-id can diverge if the model allows
        // for it via serial-authority, check for brand-id well-formedness
        _, err := checkStringMatches(assert.headers, "brand-id", validAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkModel(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedKey, err := checkNotEmptyString(assert.headers, "device-key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">pubKey, err := DecodePublicKey([]byte(encodedKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keyID, err := checkNotEmptyString(assert.headers, "device-key-sha3-384")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyID != pubKey.ID() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("device key does not match provided key id")
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // ignore extra headers and non-empty body for future compatibility
        <span class="cov0" title="0">return &amp;Serial{
                assertionBase: assert,
                timestamp:     timestamp,
                pubKey:        pubKey,
        }, nil</span>
}

// SerialRequest holds a serial-request assertion, which is a self-signed request to obtain a full device identity bound to the device public key.
type SerialRequest struct {
        assertionBase
        pubKey PublicKey
}

// BrandID returns the brand identifier of the device making the request.
func (sreq *SerialRequest) BrandID() string <span class="cov0" title="0">{
        return sreq.HeaderString("brand-id")
}</span>

// Model returns the model name identifier of the device making the request.
func (sreq *SerialRequest) Model() string <span class="cov0" title="0">{
        return sreq.HeaderString("model")
}</span>

// Serial returns the optional proposed serial identifier for the device, the service taking the request might use it or ignore it.
func (sreq *SerialRequest) Serial() string <span class="cov0" title="0">{
        return sreq.HeaderString("serial")
}</span>

// RequestID returns the id for the request, obtained from and to be presented to the serial signing service.
func (sreq *SerialRequest) RequestID() string <span class="cov0" title="0">{
        return sreq.HeaderString("request-id")
}</span>

// DeviceKey returns the public key of the device making the request.
func (sreq *SerialRequest) DeviceKey() PublicKey <span class="cov0" title="0">{
        return sreq.pubKey
}</span>

func assembleSerialRequest(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkNotEmptyString(assert.headers, "brand-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkModel(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "request-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkOptionalString(assert.headers, "serial")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedKey, err := checkNotEmptyString(assert.headers, "device-key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">pubKey, err := DecodePublicKey([]byte(encodedKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if pubKey.ID() != assert.SignKeyID() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("device key does not match included signing key id")
        }</span>

        // ignore extra headers and non-empty body for future compatibility
        <span class="cov0" title="0">return &amp;SerialRequest{
                assertionBase: assert,
                pubKey:        pubKey,
        }, nil</span>
}

// DeviceSessionRequest holds a device-session-request assertion, which is a request wrapping a store-provided nonce to start a session by a device signed with its key.
type DeviceSessionRequest struct {
        assertionBase
        timestamp time.Time
}

// BrandID returns the brand identifier of the device making the request.
func (req *DeviceSessionRequest) BrandID() string <span class="cov0" title="0">{
        return req.HeaderString("brand-id")
}</span>

// Model returns the model name identifier of the device making the request.
func (req *DeviceSessionRequest) Model() string <span class="cov0" title="0">{
        return req.HeaderString("model")
}</span>

// Serial returns the serial identifier of the device making the request,
// together with brand id and model it forms the unique identifier of
// the device.
func (req *DeviceSessionRequest) Serial() string <span class="cov0" title="0">{
        return req.HeaderString("serial")
}</span>

// Nonce returns the nonce obtained from store and to be presented when requesting a device session.
func (req *DeviceSessionRequest) Nonce() string <span class="cov0" title="0">{
        return req.HeaderString("nonce")
}</span>

// Timestamp returns the time when the device-session-request was created.
func (req *DeviceSessionRequest) Timestamp() time.Time <span class="cov0" title="0">{
        return req.timestamp
}</span>

func assembleDeviceSessionRequest(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkModel(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "nonce")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // ignore extra headers and non-empty body for future compatibility
        <span class="cov0" title="0">return &amp;DeviceSessionRequest{
                assertionBase: assert,
                timestamp:     timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2015-2022 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "bytes"
        "crypto"
        "encoding/hex"
        "errors"
        "fmt"
        "strings"
        "time"

        // expected for digests
        _ "golang.org/x/crypto/sha3"

        "github.com/snapcore/snapd/osutil"
        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

// SnapDeclaration holds a snap-declaration assertion, declaring a
// snap binding its identifying snap-id to a name, asserting its
// publisher and its other properties.
type SnapDeclaration struct {
        assertionBase
        refreshControl      []string
        plugRules           map[string]*PlugRule
        slotRules           map[string]*SlotRule
        autoAliases         []string
        aliases             map[string]string
        revisionAuthorities []*RevisionAuthority
        timestamp           time.Time
}

// Series returns the series for which the snap is being declared.
func (snapdcl *SnapDeclaration) Series() string <span class="cov0" title="0">{
        return snapdcl.HeaderString("series")
}</span>

// SnapID returns the snap id of the declared snap.
func (snapdcl *SnapDeclaration) SnapID() string <span class="cov0" title="0">{
        return snapdcl.HeaderString("snap-id")
}</span>

// SnapName returns the declared snap name.
func (snapdcl *SnapDeclaration) SnapName() string <span class="cov0" title="0">{
        return snapdcl.HeaderString("snap-name")
}</span>

// PublisherID returns the identifier of the publisher of the declared snap.
func (snapdcl *SnapDeclaration) PublisherID() string <span class="cov0" title="0">{
        return snapdcl.HeaderString("publisher-id")
}</span>

// Timestamp returns the time when the snap-declaration was issued.
func (snapdcl *SnapDeclaration) Timestamp() time.Time <span class="cov0" title="0">{
        return snapdcl.timestamp
}</span>

// RefreshControl returns the ids of snaps whose updates are controlled by this declaration.
func (snapdcl *SnapDeclaration) RefreshControl() []string <span class="cov0" title="0">{
        return snapdcl.refreshControl
}</span>

// PlugRule returns the plug-side rule about the given interface if one was included in the plugs stanza of the declaration, otherwise it returns nil.
func (snapdcl *SnapDeclaration) PlugRule(interfaceName string) *PlugRule <span class="cov0" title="0">{
        return snapdcl.plugRules[interfaceName]
}</span>

// SlotRule returns the slot-side rule about the given interface if one was included in the slots stanza of the declaration, otherwise it returns nil.
func (snapdcl *SnapDeclaration) SlotRule(interfaceName string) *SlotRule <span class="cov0" title="0">{
        return snapdcl.slotRules[interfaceName]
}</span>

// AutoAliases returns the optional auto-aliases granted to this snap.
// XXX: deprecated, will go away
func (snapdcl *SnapDeclaration) AutoAliases() []string <span class="cov0" title="0">{
        return snapdcl.autoAliases
}</span>

// Aliases returns the optional explicit aliases granted to this snap.
func (snapdcl *SnapDeclaration) Aliases() map[string]string <span class="cov0" title="0">{
        return snapdcl.aliases
}</span>

// RevisionAuthority return any revision authority entries matching the given
// provenance.
func (snapdcl *SnapDeclaration) RevisionAuthority(provenance string) []*RevisionAuthority <span class="cov0" title="0">{
        res := make([]*RevisionAuthority, 0, 1)
        for _, ra := range snapdcl.revisionAuthorities </span><span class="cov0" title="0">{
                if strutil.ListContains(ra.Provenance, provenance) </span><span class="cov0" title="0">{
                        res = append(res, ra)
                }</span>
        }
        <span class="cov0" title="0">if len(res) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return res</span>
}

// Implement further consistency checks.
func (snapdcl *SnapDeclaration) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        if !db.IsTrustedAccount(snapdcl.AuthorityID()) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-declaration assertion for %q (id %q) is not signed by a directly trusted authority: %s", snapdcl.SnapName(), snapdcl.SnapID(), snapdcl.AuthorityID())
        }</span>
        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{
                "account-id": snapdcl.PublisherID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-declaration assertion for %q (id %q) does not have a matching account assertion for the publisher %q", snapdcl.SnapName(), snapdcl.SnapID(), snapdcl.PublisherID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*SnapDeclaration)(nil)

// Prerequisites returns references to this snap-declaration's prerequisite assertions.
func (snapdcl *SnapDeclaration) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: AccountType, PrimaryKey: []string{snapdcl.PublisherID()}},
        }
}</span>

func compilePlugRules(plugs map[string]any, compiled func(iface string, plugRule *PlugRule)) error <span class="cov0" title="0">{
        for iface, rule := range plugs </span><span class="cov0" title="0">{
                plugRule, err := compilePlugRule(iface, rule)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">compiled(iface, plugRule)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func compileSlotRules(slots map[string]any, compiled func(iface string, slotRule *SlotRule)) error <span class="cov0" title="0">{
        for iface, rule := range slots </span><span class="cov0" title="0">{
                slotRule, err := compileSlotRule(iface, rule)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">compiled(iface, slotRule)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func snapDeclarationFormatAnalyze(headers map[string]any, body []byte) (formatnum int, err error) <span class="cov0" title="0">{
        _, plugsOk := headers["plugs"]
        _, slotsOk := headers["slots"]
        if !(plugsOk || slotsOk) </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">formatnum = 1
        setFormatNum := func(num int) </span><span class="cov0" title="0">{
                if num &gt; formatnum </span><span class="cov0" title="0">{
                        formatnum = num
                }</span>
        }

        <span class="cov0" title="0">plugs, err := checkMap(headers, "plugs")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">err = compilePlugRules(plugs, func(_ string, rule *PlugRule) </span><span class="cov0" title="0">{
                if rule.feature(dollarAttrConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(2)
                }</span>
                <span class="cov0" title="0">if rule.feature(deviceScopeConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(3)
                }</span>
                <span class="cov0" title="0">if rule.feature(nameConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(4)
                }</span>
                <span class="cov0" title="0">if rule.feature(altAttrMatcherFeature) </span><span class="cov0" title="0">{
                        setFormatNum(5)
                }</span>
                <span class="cov0" title="0">if rule.feature(publisherIDConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(6)
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">slots, err := checkMap(headers, "slots")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">err = compileSlotRules(slots, func(_ string, rule *SlotRule) </span><span class="cov0" title="0">{
                if rule.feature(dollarAttrConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(2)
                }</span>
                <span class="cov0" title="0">if rule.feature(deviceScopeConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(3)
                }</span>
                <span class="cov0" title="0">if rule.feature(nameConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(4)
                }</span>
                <span class="cov0" title="0">if rule.feature(altAttrMatcherFeature) </span><span class="cov0" title="0">{
                        setFormatNum(5)
                }</span>
                <span class="cov0" title="0">if rule.feature(publisherIDConstraintsFeature) </span><span class="cov0" title="0">{
                        setFormatNum(6)
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return formatnum, nil</span>
}

func checkAliases(headers map[string]any) (map[string]string, error) <span class="cov0" title="0">{
        value, ok := headers["aliases"]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">aliasList, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"aliases" header must be a list of alias maps`)
        }</span>
        <span class="cov0" title="0">if len(aliasList) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">aliasMap := make(map[string]string, len(aliasList))
        for i, item := range aliasList </span><span class="cov0" title="0">{
                aliasItem, ok := item.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"aliases" header must be a list of alias maps`)
                }</span>

                <span class="cov0" title="0">what := fmt.Sprintf(`in "aliases" item %d`, i+1)
                name, err := checkStringMatchesWhat(aliasItem, "name", what, naming.ValidAlias)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">what = fmt.Sprintf(`for alias %q`, name)
                target, err := checkStringMatchesWhat(aliasItem, "target", what, naming.ValidApp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if _, ok := aliasMap[name]; ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`duplicated definition in "aliases" for alias %q`, name)
                }</span>

                <span class="cov0" title="0">aliasMap[name] = target</span>
        }

        <span class="cov0" title="0">return aliasMap, nil</span>
}

func assembleSnapDeclaration(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkExistsString(assert.headers, "snap-name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "publisher-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var refControl []string
        var plugRules map[string]*PlugRule
        var slotRules map[string]*SlotRule

        refControl, err = checkStringList(assert.headers, "refresh-control")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">plugs, err := checkMap(assert.headers, "plugs")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if plugs != nil </span><span class="cov0" title="0">{
                plugRules = make(map[string]*PlugRule, len(plugs))
                err := compilePlugRules(plugs, func(iface string, rule *PlugRule) </span><span class="cov0" title="0">{
                        plugRules[iface] = rule
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">slots, err := checkMap(assert.headers, "slots")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if slots != nil </span><span class="cov0" title="0">{
                slotRules = make(map[string]*SlotRule, len(slots))
                err := compileSlotRules(slots, func(iface string, rule *SlotRule) </span><span class="cov0" title="0">{
                        slotRules[iface] = rule
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // XXX: depracated, will go away later
        <span class="cov0" title="0">autoAliases, err := checkStringListMatches(assert.headers, "auto-aliases", naming.ValidAlias)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">aliases, err := checkAliases(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var ras []*RevisionAuthority

        ra, ok := assert.headers["revision-authority"]
        if ok </span><span class="cov0" title="0">{
                ramaps, ok := ra.([]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("revision-authority stanza must be a list of maps")
                }</span>
                <span class="cov0" title="0">if len(ramaps) == 0 </span><span class="cov0" title="0">{
                        // there is no syntax producing this scenario but be robust
                        return nil, fmt.Errorf("revision-authority stanza cannot be empty")
                }</span>
                <span class="cov0" title="0">ras = make([]*RevisionAuthority, 0, len(ramaps))
                for _, ramap := range ramaps </span><span class="cov0" title="0">{
                        m, ok := ramap.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("revision-authority stanza must be a list of maps")
                        }</span>
                        <span class="cov0" title="0">accountID, err := checkStringMatchesWhat(m, "account-id", "in revision authority", validAccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">prov, err := checkStringListInMap(m, "provenance", "provenance in revision authority", naming.ValidProvenance)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if len(prov) == 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("provenance in revision authority cannot be empty")
                        }</span>
                        <span class="cov0" title="0">minRevision := 1
                        maxRevision := 0
                        if _, ok := m["min-revision"]; ok </span><span class="cov0" title="0">{
                                var err error
                                minRevision, err = checkSnapRevisionWhat(m, "min-revision", "in revision authority")
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">if _, ok := m["max-revision"]; ok </span><span class="cov0" title="0">{
                                var err error
                                maxRevision, err = checkSnapRevisionWhat(m, "max-revision", "in revision authority")
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">if maxRevision != 0 &amp;&amp; maxRevision &lt; minRevision </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("optional max-revision cannot be less than min-revision in revision-authority")
                        }</span>
                        <span class="cov0" title="0">devscope, err := compileDeviceScopeConstraint(m, "revision-authority")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">ras = append(ras, &amp;RevisionAuthority{
                                AccountID:   accountID,
                                Provenance:  prov,
                                MinRevision: minRevision,
                                MaxRevision: maxRevision,
                                DeviceScope: devscope,
                        })</span>
                }

        }

        <span class="cov0" title="0">return &amp;SnapDeclaration{
                assertionBase:       assert,
                refreshControl:      refControl,
                plugRules:           plugRules,
                slotRules:           slotRules,
                autoAliases:         autoAliases,
                aliases:             aliases,
                revisionAuthorities: ras,
                timestamp:           timestamp,
        }, nil</span>
}

// RevisionAuthority holds information about an account that can sign revisions
// for a given snap.
type RevisionAuthority struct {
        AccountID  string
        Provenance []string

        MinRevision int
        MaxRevision int

        DeviceScope *DeviceScopeConstraint
}

func (ra *RevisionAuthority) checkProvenanceAndRevision(a interface {
        Assertion
        Provenance() string
}, what string, revno int, model *Model, store *Store) error <span class="cov0" title="0">{
        if !strutil.ListContains(ra.Provenance, a.Provenance()) </span><span class="cov0" title="0">{
                return fmt.Errorf("provenance mismatch")
        }</span>
        <span class="cov0" title="0">if a.AuthorityID() != ra.AccountID </span><span class="cov0" title="0">{
                return fmt.Errorf("authority-id mismatch")
        }</span>
        <span class="cov0" title="0">if revno &lt; ra.MinRevision </span><span class="cov0" title="0">{
                return fmt.Errorf("%s revision %d is less than min-revision %d", what, revno, ra.MinRevision)
        }</span>
        <span class="cov0" title="0">if ra.MaxRevision != 0 &amp;&amp; revno &gt; ra.MaxRevision </span><span class="cov0" title="0">{
                return fmt.Errorf("%s revision %d is greater than max-revision %d", what, revno, ra.MaxRevision)
        }</span>
        <span class="cov0" title="0">if ra.DeviceScope != nil &amp;&amp; model != nil </span><span class="cov0" title="0">{
                opts := DeviceScopeConstraintCheckOptions{UseFriendlyStores: true}
                if err := ra.DeviceScope.Check(model, store, &amp;opts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Check tests whether rev matches the revision authority constraints.
// Optional model and store must be provided to cross-check device-specific
// constraints.
func (ra *RevisionAuthority) Check(rev *SnapRevision, model *Model, store *Store) error <span class="cov0" title="0">{
        return ra.checkProvenanceAndRevision(rev, "snap", rev.SnapRevision(), model, store)
}</span>

// CheckResourceRevision tests whether resrev matches the revision authority
// constraints. Optional model and store must be provided to cross-check
// device-specific constraints.
func (ra *RevisionAuthority) CheckResourceRevision(resrev *SnapResourceRevision, model *Model, store *Store) error <span class="cov0" title="0">{
        return ra.checkProvenanceAndRevision(resrev, "resource", resrev.ResourceRevision(), model, store)
}</span>

var validSnapIntegrityTypes = []string{"dm-verity"}

var validVersionsForIntegrityType = map[string][]int{
        // version 1 corresponds to dm-verity format 1
        "dm-verity": {1},
}

var validHashAlgorithmsForIntegrityType = map[string][]string{
        // kernel supported algorithms:
        // https://gitlab.com/cryptsetup/cryptsetup/-/blob/main/lib/crypto_backend/crypto_kernel.c?ref_type=heads#L35
        // Go crypto's supported algorithms:
        // https://cs.opensource.google/go/go/+/refs/tags/go1.23.4:src/crypto/crypto.go;l=68
        "dm-verity": {
                "sha256",
        },
}

func contains[V int | string](l []V, i V) bool <span class="cov0" title="0">{
        for _, v := range l </span><span class="cov0" title="0">{
                if v == i </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func toHash(s string) crypto.Hash <span class="cov0" title="0">{
        switch s </span>{
        case "sha256":<span class="cov0" title="0">
                return crypto.SHA256</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// IntegrityData holds information about integrity data of a specific type included in a snap or resource's revision.
//
// A single snap or resource revision can have multiple variants of integrity data which are represented as an array in the
// snap or resource revision assertion.
type IntegrityData struct {
        Type          string
        Version       uint
        HashAlg       string
        DataBlockSize uint
        HashBlockSize uint
        Digest        string
        Salt          string
}

// SnapFileSHA3_384 computes the SHA3-384 digest of the given snap file.
// It also returns its size.
func SnapFileSHA3_384(snapPath string) (digest string, size uint64, err error) <span class="cov0" title="0">{
        sha3_384Dgst, size, err := osutil.FileDigest(snapPath, crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("cannot compute snap %q digest: %v", snapPath, err)
        }</span>

        <span class="cov0" title="0">sha3_384, err := EncodeDigest(crypto.SHA3_384, sha3_384Dgst)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("cannot encode snap %q digest: %v", snapPath, err)
        }</span>
        <span class="cov0" title="0">return sha3_384, size, nil</span>
}

// SnapBuild holds a snap-build assertion, asserting the properties of a snap
// at the time it was built by the developer.
type SnapBuild struct {
        assertionBase
        size      uint64
        timestamp time.Time
}

// SnapSHA3_384 returns the SHA3-384 digest of the snap.
func (snapbld *SnapBuild) SnapSHA3_384() string <span class="cov0" title="0">{
        return snapbld.HeaderString("snap-sha3-384")
}</span>

// SnapID returns the snap id of the snap.
func (snapbld *SnapBuild) SnapID() string <span class="cov0" title="0">{
        return snapbld.HeaderString("snap-id")
}</span>

// SnapSize returns the size of the snap.
func (snapbld *SnapBuild) SnapSize() uint64 <span class="cov0" title="0">{
        return snapbld.size
}</span>

// Grade returns the grade of the snap: devel|stable
func (snapbld *SnapBuild) Grade() string <span class="cov0" title="0">{
        return snapbld.HeaderString("grade")
}</span>

// Timestamp returns the time when the snap-build assertion was created.
func (snapbld *SnapBuild) Timestamp() time.Time <span class="cov0" title="0">{
        return snapbld.timestamp
}</span>

func assembleSnapBuild(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkDigest(assert.headers, "snap-sha3-384", crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "snap-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "grade")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">size, err := checkUint(assert.headers, "snap-size", 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // ignore extra headers and non-empty body for future compatibility
        <span class="cov0" title="0">return &amp;SnapBuild{
                assertionBase: assert,
                size:          size,
                timestamp:     timestamp,
        }, nil</span>
}

// SnapRevision holds a snap-revision assertion, which is a statement by the
// store acknowledging the receipt of a build of a snap and labeling it with a
// snap revision.
type SnapRevision struct {
        assertionBase
        snapSize     uint64
        snapRevision int
        timestamp    time.Time

        snapIntegrityData []IntegrityData
}

// SnapSHA3_384 returns the SHA3-384 digest of the snap.
func (snaprev *SnapRevision) SnapSHA3_384() string <span class="cov0" title="0">{
        return snaprev.HeaderString("snap-sha3-384")
}</span>

// Provenance returns the optional provenance of the snap (defaults to
// global-upload (naming.DefaultProvenance)).
func (snaprev *SnapRevision) Provenance() string <span class="cov0" title="0">{
        return snaprev.HeaderString("provenance")
}</span>

// SnapID returns the snap id of the snap.
func (snaprev *SnapRevision) SnapID() string <span class="cov0" title="0">{
        return snaprev.HeaderString("snap-id")
}</span>

// SnapSize returns the size in bytes of the snap submitted to the store.
func (snaprev *SnapRevision) SnapSize() uint64 <span class="cov0" title="0">{
        return snaprev.snapSize
}</span>

// SnapRevision returns the revision assigned to this build of the snap.
func (snaprev *SnapRevision) SnapRevision() int <span class="cov0" title="0">{
        return snaprev.snapRevision
}</span>

// DeveloperID returns the id of the developer that submitted this build of the
// snap.
func (snaprev *SnapRevision) DeveloperID() string <span class="cov0" title="0">{
        return snaprev.HeaderString("developer-id")
}</span>

// Timestamp returns the time when the snap-revision was issued.
func (snaprev *SnapRevision) Timestamp() time.Time <span class="cov0" title="0">{
        return snaprev.timestamp
}</span>

// SnapIntegrityData returns the integrity data associated with the snap revision if any.
func (snaprev *SnapRevision) SnapIntegrityData() []IntegrityData <span class="cov0" title="0">{
        return snaprev.snapIntegrityData
}</span>

// Implement further consistency checks.
func (snaprev *SnapRevision) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        otherProvenance := snaprev.Provenance() != naming.DefaultProvenance
        if !otherProvenance &amp;&amp; !db.IsTrustedAccount(snaprev.AuthorityID()) </span><span class="cov0" title="0">{
                // delegating global-upload revisions is not allowed
                return fmt.Errorf("snap-revision assertion for snap id %q is not signed by a store: %s", snaprev.SnapID(), snaprev.AuthorityID())
        }</span>
        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{
                "account-id": snaprev.DeveloperID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-revision assertion for snap id %q does not have a matching account assertion for the developer %q", snaprev.SnapID(), snaprev.DeveloperID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a, err := db.Find(SnapDeclarationType, map[string]string{
                // XXX: mediate getting current series through some context object? this gets the job done for now
                "series":  release.Series,
                "snap-id": snaprev.SnapID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-revision assertion for snap id %q does not have a matching snap-declaration assertion", snaprev.SnapID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if otherProvenance </span><span class="cov0" title="0">{
                decl := a.(*SnapDeclaration)
                ras := decl.RevisionAuthority(snaprev.Provenance())
                matchingRevAuthority := false
                for _, ra := range ras </span><span class="cov0" title="0">{
                        // model==store==nil, we do not perform device-specific
                        // checks at this level, those are performed at
                        // higher-level guarding installing actual snaps
                        if err := ra.Check(snaprev, nil, nil); err == nil </span><span class="cov0" title="0">{
                                matchingRevAuthority = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !matchingRevAuthority </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap-revision assertion with provenance %q for snap id %q is not signed by an authorized authority: %s", snaprev.Provenance(), snaprev.SnapID(), snaprev.AuthorityID())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*SnapRevision)(nil)

// Prerequisites returns references to this snap-revision's prerequisite assertions.
func (snaprev *SnapRevision) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                // XXX: mediate getting current series through some context object? this gets the job done for now
                {Type: SnapDeclarationType, PrimaryKey: []string{release.Series, snaprev.SnapID()}},
                {Type: AccountType, PrimaryKey: []string{snaprev.DeveloperID()}},
        }
}</span>

func checkSnapRevisionWhat(headers map[string]any, name, what string) (snapRevision int, err error) <span class="cov0" title="0">{
        snapRevision, err = checkIntWhat(headers, name, what)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if snapRevision &lt; 1 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf(`%q %s must be &gt;=1: %d`, name, what, snapRevision)
        }</span>
        <span class="cov0" title="0">return snapRevision, nil</span>
}

func checkOptionalSnapRevisionWhat(headers map[string]any, name, what string) (snapRevision int, err error) <span class="cov0" title="0">{
        if _, ok := headers[name]; !ok </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return checkSnapRevisionWhat(headers, name, what)</span>
}

func checkSnapIntegrity(headers map[string]any) ([]IntegrityData, error) <span class="cov0" title="0">{
        value, ok := headers["integrity"]
        if !ok </span><span class="cov0" title="0">{
                // integrity stanzas are optional
                return nil, nil
        }</span>

        <span class="cov0" title="0">integrityList, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"integrity" header must contain a list of integrity data`)
        }</span>
        <span class="cov0" title="0">if len(integrityList) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var snapIntegrityDataList []IntegrityData

        for i, il := range integrityList </span><span class="cov0" title="0">{
                id, ok := il.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"integrity" header must contain a list of integrity data`)
                }</span>

                <span class="cov0" title="0">what := fmt.Sprintf("of integrity data [%d]", i)
                typ, err := checkExistsStringWhat(id, "type", what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if !contains(validSnapIntegrityTypes, typ) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("\"type\" of integrity data [%d] must be one of (%s)", i, strings.Join(validSnapIntegrityTypes, "|"))
                }</span>

                <span class="cov0" title="0">what = fmt.Sprintf("of integrity data [%d] of type %q", i, typ)
                version, err := checkUintWhat(id, "version", 64, what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if !contains(validVersionsForIntegrityType[typ], int(version)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`version of integrity data [%d] of type %q must be one of %v`, i, typ, validVersionsForIntegrityType[typ])
                }</span>

                <span class="cov0" title="0">alg, err := checkExistsStringWhat(id, "hash-algorithm", what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if !contains(validHashAlgorithmsForIntegrityType[typ], alg) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`hash algorithm of integrity data [%d] of type %q must be one of %v`, i, typ, validHashAlgorithmsForIntegrityType[typ])
                }</span>

                <span class="cov0" title="0">what = fmt.Sprintf("of integrity data [%d] of type %q (%s)", i, typ, alg)
                dataBlockSize, err := checkUintWhat(id, "data-block-size", 64, what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">hashBlockSize, err := checkUintWhat(id, "hash-block-size", 64, what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">h := toHash(alg)
                encDigest, err := checkDigestDecWhat(id, "digest", h, hex.DecodeString, what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">encSalt, err := checkDigestDecWhat(id, "salt", h, hex.DecodeString, what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">snapIntegrityData := IntegrityData{
                        Type:          typ,
                        Version:       uint(version),
                        HashAlg:       alg,
                        DataBlockSize: uint(dataBlockSize),
                        HashBlockSize: uint(hashBlockSize),
                        Digest:        encDigest,
                        Salt:          encSalt,
                }

                snapIntegrityDataList = append(snapIntegrityDataList, snapIntegrityData)</span>
        }

        <span class="cov0" title="0">return snapIntegrityDataList, nil</span>
}

func assembleSnapRevision(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkDigest(assert.headers, "snap-sha3-384", crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkStringMatches(assert.headers, "provenance", naming.ValidProvenance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "snap-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapSize, err := checkUint(assert.headers, "snap-size", 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapRevision, err := checkSnapRevisionWhat(assert.headers, "snap-revision", "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "developer-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapIntegrityData, err := checkSnapIntegrity(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SnapRevision{
                assertionBase:     assert,
                snapSize:          snapSize,
                snapRevision:      snapRevision,
                timestamp:         timestamp,
                snapIntegrityData: snapIntegrityData,
        }, nil</span>
}

// Validation holds a validation assertion, describing that a combination of
// (snap-id, approved-snap-id, approved-revision) has been validated for
// the series, meaning updating to that revision of approved-snap-id
// has been approved by the owner of the gating snap with snap-id.
type Validation struct {
        assertionBase
        revoked              bool
        timestamp            time.Time
        approvedSnapRevision int
}

// Series returns the series for which the validation holds.
func (validation *Validation) Series() string <span class="cov0" title="0">{
        return validation.HeaderString("series")
}</span>

// SnapID returns the ID of the gating snap.
func (validation *Validation) SnapID() string <span class="cov0" title="0">{
        return validation.HeaderString("snap-id")
}</span>

// ApprovedSnapID returns the ID of the gated snap.
func (validation *Validation) ApprovedSnapID() string <span class="cov0" title="0">{
        return validation.HeaderString("approved-snap-id")
}</span>

// ApprovedSnapRevision returns the approved revision of the gated snap.
func (validation *Validation) ApprovedSnapRevision() int <span class="cov0" title="0">{
        return validation.approvedSnapRevision
}</span>

// Revoked returns true if the validation has been revoked.
func (validation *Validation) Revoked() bool <span class="cov0" title="0">{
        return validation.revoked
}</span>

// Timestamp returns the time when the validation was issued.
func (validation *Validation) Timestamp() time.Time <span class="cov0" title="0">{
        return validation.timestamp
}</span>

// Implement further consistency checks.
func (validation *Validation) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        _, err := db.Find(SnapDeclarationType, map[string]string{
                "series":  validation.Series(),
                "snap-id": validation.ApprovedSnapID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("validation assertion by snap-id %q does not have a matching snap-declaration assertion for approved-snap-id %q", validation.SnapID(), validation.ApprovedSnapID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a, err := db.Find(SnapDeclarationType, map[string]string{
                "series":  validation.Series(),
                "snap-id": validation.SnapID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("validation assertion by snap-id %q does not have a matching snap-declaration assertion", validation.SnapID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gatingDecl := a.(*SnapDeclaration)
        if gatingDecl.PublisherID() != validation.AuthorityID() </span><span class="cov0" title="0">{
                return fmt.Errorf("validation assertion by snap %q (id %q) not signed by its publisher", gatingDecl.SnapName(), validation.SnapID())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*Validation)(nil)

// Prerequisites returns references to this validation's prerequisite assertions.
func (validation *Validation) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: SnapDeclarationType, PrimaryKey: []string{validation.Series(), validation.SnapID()}},
                {Type: SnapDeclarationType, PrimaryKey: []string{validation.Series(), validation.ApprovedSnapID()}},
        }
}</span>

func assembleValidation(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        approvedSnapRevision, err := checkSnapRevisionWhat(assert.headers, "approved-snap-revision", "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">revoked, err := checkOptionalBool(assert.headers, "revoked")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Validation{
                assertionBase:        assert,
                revoked:              revoked,
                timestamp:            timestamp,
                approvedSnapRevision: approvedSnapRevision,
        }, nil</span>
}

// BaseDeclaration holds a base-declaration assertion, declaring the
// policies (to start with interface ones) applying to all snaps of
// a series.
type BaseDeclaration struct {
        assertionBase
        plugRules map[string]*PlugRule
        slotRules map[string]*SlotRule
        timestamp time.Time
}

// Series returns the series whose snaps are governed by the declaration.
func (basedcl *BaseDeclaration) Series() string <span class="cov0" title="0">{
        return basedcl.HeaderString("series")
}</span>

// Timestamp returns the time when the base-declaration was issued.
func (basedcl *BaseDeclaration) Timestamp() time.Time <span class="cov0" title="0">{
        return basedcl.timestamp
}</span>

// PlugRule returns the plug-side rule about the given interface if one was included in the plugs stanza of the declaration, otherwise it returns nil.
func (basedcl *BaseDeclaration) PlugRule(interfaceName string) *PlugRule <span class="cov0" title="0">{
        return basedcl.plugRules[interfaceName]
}</span>

// SlotRule returns the slot-side rule about the given interface if one was included in the slots stanza of the declaration, otherwise it returns nil.
func (basedcl *BaseDeclaration) SlotRule(interfaceName string) *SlotRule <span class="cov0" title="0">{
        return basedcl.slotRules[interfaceName]
}</span>

// Implement further consistency checks.
func (basedcl *BaseDeclaration) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // XXX: not signed or stored yet in a db, but being ready for that
        if !db.IsTrustedAccount(basedcl.AuthorityID()) </span><span class="cov0" title="0">{
                return fmt.Errorf("base-declaration assertion for series %s is not signed by a directly trusted authority: %s", basedcl.Series(), basedcl.AuthorityID())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*BaseDeclaration)(nil)

func assembleBaseDeclaration(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        var plugRules map[string]*PlugRule
        plugs, err := checkMap(assert.headers, "plugs")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if plugs != nil </span><span class="cov0" title="0">{
                plugRules = make(map[string]*PlugRule, len(plugs))
                err := compilePlugRules(plugs, func(iface string, rule *PlugRule) </span><span class="cov0" title="0">{
                        plugRules[iface] = rule
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var slotRules map[string]*SlotRule
        slots, err := checkMap(assert.headers, "slots")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if slots != nil </span><span class="cov0" title="0">{
                slotRules = make(map[string]*SlotRule, len(slots))
                err := compileSlotRules(slots, func(iface string, rule *SlotRule) </span><span class="cov0" title="0">{
                        slotRules[iface] = rule
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;BaseDeclaration{
                assertionBase: assert,
                plugRules:     plugRules,
                slotRules:     slotRules,
                timestamp:     timestamp,
        }, nil</span>
}

var builtinBaseDeclaration *BaseDeclaration

// BuiltinBaseDeclaration exposes the initialized builtin base-declaration assertion. This is used by overlord/assertstate, other code should use assertstate.BaseDeclaration.
func BuiltinBaseDeclaration() *BaseDeclaration <span class="cov0" title="0">{
        return builtinBaseDeclaration
}</span>

var (
        builtinBaseDeclarationCheckOrder      = []string{"type", "authority-id", "series"}
        builtinBaseDeclarationExpectedHeaders = map[string]any{
                "type":         "base-declaration",
                "authority-id": "canonical",
                "series":       release.Series,
        }
)

// InitBuiltinBaseDeclaration initializes the builtin base-declaration based on headers (or resets it if headers is nil).
func InitBuiltinBaseDeclaration(headers []byte) error <span class="cov0" title="0">{
        if headers == nil </span><span class="cov0" title="0">{
                builtinBaseDeclaration = nil
                return nil
        }</span>
        <span class="cov0" title="0">trimmed := bytes.TrimSpace(headers)
        h, err := parseHeaders(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, name := range builtinBaseDeclarationCheckOrder </span><span class="cov0" title="0">{
                expected := builtinBaseDeclarationExpectedHeaders[name]
                if h[name] != expected </span><span class="cov0" title="0">{
                        return fmt.Errorf("the builtin base-declaration %q header is not set to expected value %q", name, expected)
                }</span>
        }
        <span class="cov0" title="0">revision, err := checkRevision(h)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot assemble the builtin-base declaration: %v", err)
        }</span>
        <span class="cov0" title="0">h["timestamp"] = time.Now().UTC().Format(time.RFC3339)
        a, err := assembleBaseDeclaration(assertionBase{
                headers:   h,
                body:      nil,
                revision:  revision,
                content:   trimmed,
                signature: []byte("$builtin"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot assemble the builtin base-declaration: %v", err)
        }</span>
        <span class="cov0" title="0">builtinBaseDeclaration = a.(*BaseDeclaration)
        return nil</span>
}

type dateRange struct {
        Since time.Time
        Until time.Time
}

// SnapDeveloper holds a snap-developer assertion, defining the developers who
// can collaborate on a snap while it's owned by a specific publisher.
//
// The primary key (snap-id, publisher-id) allows a snap to have many
// snap-developer assertions, e.g. to allow a future publisher's collaborations
// to be defined before the snap is transferred. However only the
// snap-developer for the current publisher (the snap-declaration publisher-id)
// is relevant to a device.
type SnapDeveloper struct {
        assertionBase
        developerRanges map[string][]*dateRange
}

// SnapID returns the snap id of the snap.
func (snapdev *SnapDeveloper) SnapID() string <span class="cov0" title="0">{
        return snapdev.HeaderString("snap-id")
}</span>

// PublisherID returns the publisher's account id.
func (snapdev *SnapDeveloper) PublisherID() string <span class="cov0" title="0">{
        return snapdev.HeaderString("publisher-id")
}</span>

func (snapdev *SnapDeveloper) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // Check authority is the publisher or trusted.
        authorityID := snapdev.AuthorityID()
        publisherID := snapdev.PublisherID()
        if !db.IsTrustedAccount(authorityID) &amp;&amp; (publisherID != authorityID) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-developer must be signed by the publisher or a trusted authority but got authority %q and publisher %q", authorityID, publisherID)
        }</span>

        // Check snap-declaration for the snap-id exists for the series.
        // Note: the current publisher is irrelevant here because this assertion
        // may be for a future publisher.
        <span class="cov0" title="0">_, err := db.Find(SnapDeclarationType, map[string]string{
                // XXX: mediate getting current series through some context object? this gets the job done for now
                "series":  release.Series,
                "snap-id": snapdev.SnapID(),
        })
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap-developer assertion for snap id %q does not have a matching snap-declaration assertion", snapdev.SnapID())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // check there's an account for the publisher-id
        <span class="cov0" title="0">_, err = db.Find(AccountType, map[string]string{"account-id": publisherID})
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap-developer assertion for snap-id %q does not have a matching account assertion for the publisher %q", snapdev.SnapID(), publisherID)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // check there's an account for each developer
        <span class="cov0" title="0">for developerID := range snapdev.developerRanges </span><span class="cov0" title="0">{
                if developerID == publisherID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, err = db.Find(AccountType, map[string]string{"account-id": developerID})
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                                return fmt.Errorf("snap-developer assertion for snap-id %q does not have a matching account assertion for the developer %q", snapdev.SnapID(), developerID)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*SnapDeveloper)(nil)

// Prerequisites returns references to this snap-developer's prerequisite assertions.
func (snapdev *SnapDeveloper) Prerequisites() []*Ref <span class="cov0" title="0">{
        // Capacity for the snap-declaration, the publisher and all developers.
        refs := make([]*Ref, 0, 2+len(snapdev.developerRanges))

        // snap-declaration
        // XXX: mediate getting current series through some context object? this gets the job done for now
        refs = append(refs, &amp;Ref{SnapDeclarationType, []string{release.Series, snapdev.SnapID()}})

        // the publisher and developers
        publisherID := snapdev.PublisherID()
        refs = append(refs, &amp;Ref{AccountType, []string{publisherID}})
        for developerID := range snapdev.developerRanges </span><span class="cov0" title="0">{
                if developerID != publisherID </span><span class="cov0" title="0">{
                        refs = append(refs, &amp;Ref{AccountType, []string{developerID}})
                }</span>
        }

        <span class="cov0" title="0">return refs</span>
}

func assembleSnapDeveloper(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        developerRanges, err := checkDevelopers(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SnapDeveloper{
                assertionBase:   assert,
                developerRanges: developerRanges,
        }, nil</span>
}

func checkDevelopers(headers map[string]any) (map[string][]*dateRange, error) <span class="cov0" title="0">{
        value, ok := headers["developers"]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">developers, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"developers" must be a list of developer maps`)
        }</span>
        <span class="cov0" title="0">if len(developers) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Used to check for a developer with revoking and non-revoking items.
        // No entry means developer not yet seen, false means seen but not revoked,
        // true means seen and revoked.
        <span class="cov0" title="0">revocationStatus := map[string]bool{}

        developerRanges := make(map[string][]*dateRange)
        for i, item := range developers </span><span class="cov0" title="0">{
                developer, ok := item.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"developers" must be a list of developer maps`)
                }</span>

                <span class="cov0" title="0">what := fmt.Sprintf(`in "developers" item %d`, i+1)
                accountID, err := checkStringMatchesWhat(developer, "developer-id", what, validAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">what = fmt.Sprintf(`in "developers" item %d for developer %q`, i+1, accountID)
                since, err := checkRFC3339DateWhat(developer, "since", what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">until, err := checkRFC3339DateWithDefaultWhat(developer, "until", what, time.Time{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !until.IsZero() &amp;&amp; since.After(until) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`"since" %s must be less than or equal to "until"`, what)
                }</span>

                // Track/check for revocation conflicts.
                <span class="cov0" title="0">revoked := since.Equal(until)
                previouslyRevoked, ok := revocationStatus[accountID]
                if !ok </span><span class="cov0" title="0">{
                        revocationStatus[accountID] = revoked
                }</span> else<span class="cov0" title="0"> if previouslyRevoked || revoked </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`revocation for developer %q must be standalone but found other "developers" items`, accountID)
                }</span>

                <span class="cov0" title="0">developerRanges[accountID] = append(developerRanges[accountID], &amp;dateRange{since, until})</span>
        }

        <span class="cov0" title="0">return developerRanges, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "crypto"
        "errors"
        "fmt"
        "time"

        "github.com/snapcore/snapd/release"
        "github.com/snapcore/snapd/snap/naming"
)

// SnapResourceRevision holds a snap-resource-revision assertion, which is a
// statement by the store acknowledging the receipt of data for a resource of a
// snap and labeling it with a resource revision.
type SnapResourceRevision struct {
        assertionBase
        resourceSize     uint64
        resourceRevision int
        timestamp        time.Time

        resourceIntegrityData []IntegrityData
}

// ResourceSHA3_384 returns the SHA3-384 digest of the snap resource.
func (resrev *SnapResourceRevision) ResourceSHA3_384() string <span class="cov0" title="0">{
        return resrev.HeaderString("resource-sha3-384")
}</span>

// Provenance returns the optional provenance of the snap (defaults to
// global-upload (naming.DefaultProvenance)).
func (resrev *SnapResourceRevision) Provenance() string <span class="cov0" title="0">{
        return resrev.HeaderString("provenance")
}</span>

// SnapID returns the snap id of the snap for the resource.
func (resrev *SnapResourceRevision) SnapID() string <span class="cov0" title="0">{
        return resrev.HeaderString("snap-id")
}</span>

// ResourceName returns the name of the snap resource.
func (resrev *SnapResourceRevision) ResourceName() string <span class="cov0" title="0">{
        return resrev.HeaderString("resource-name")
}</span>

// ResourceSize returns the size in bytes of the snap resource submitted to the store.
func (resrev *SnapResourceRevision) ResourceSize() uint64 <span class="cov0" title="0">{
        return resrev.resourceSize
}</span>

// ResourceRevision returns the revision assigned to this upload of the snap resource.
func (resrev *SnapResourceRevision) ResourceRevision() int <span class="cov0" title="0">{
        return resrev.resourceRevision
}</span>

// DeveloperID returns the id of the developer that submitted the snap resource.
func (resrev *SnapResourceRevision) DeveloperID() string <span class="cov0" title="0">{
        return resrev.HeaderString("developer-id")
}</span>

// Timestamp returns the time when the snap-resource-revision was issued.
func (resrev *SnapResourceRevision) Timestamp() time.Time <span class="cov0" title="0">{
        return resrev.timestamp
}</span>

// ResourceIntegrityData returns the integrity data associated with the snap resource revision assertion if any.
func (resrev *SnapResourceRevision) ResourceIntegrityData() []IntegrityData <span class="cov0" title="0">{
        return resrev.resourceIntegrityData
}</span>

// Implement further consistency checks.
func (resrev *SnapResourceRevision) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        otherProvenance := resrev.Provenance() != naming.DefaultProvenance
        if !otherProvenance &amp;&amp; !db.IsTrustedAccount(resrev.AuthorityID()) </span><span class="cov0" title="0">{
                // delegating global-upload revisions is not allowed
                return fmt.Errorf("snap-resource-revision assertion for snap id %q is not signed by a store: %s", resrev.SnapID(), resrev.AuthorityID())
        }</span>
        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{
                "account-id": resrev.DeveloperID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-resource-revision assertion for snap id %q does not have a matching account assertion for the developer %q", resrev.SnapID(), resrev.DeveloperID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a, err := db.Find(SnapDeclarationType, map[string]string{
                "series":  release.Series,
                "snap-id": resrev.SnapID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-resource-revision assertion for snap id %q does not have a matching snap-declaration assertion", resrev.SnapID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if otherProvenance </span><span class="cov0" title="0">{
                decl := a.(*SnapDeclaration)
                ras := decl.RevisionAuthority(resrev.Provenance())
                matchingRevAuthority := false
                for _, ra := range ras </span><span class="cov0" title="0">{
                        // model==store==nil, we do not perform device-specific
                        // checks at this level, those are performed at
                        // higher-level guarding installing actual components
                        if err := ra.CheckResourceRevision(resrev, nil, nil); err == nil </span><span class="cov0" title="0">{
                                matchingRevAuthority = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !matchingRevAuthority </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap-resource-revision assertion with provenance %q for snap id %q is not signed by an authorized authority: %s", resrev.Provenance(), resrev.SnapID(), resrev.AuthorityID())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*SnapResourceRevision)(nil)

// Prerequisites returns references to this snap-resource-revision's prerequisite assertions.
func (resrev *SnapResourceRevision) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: SnapDeclarationType, PrimaryKey: []string{release.Series, resrev.SnapID()}},
                {Type: AccountType, PrimaryKey: []string{resrev.DeveloperID()}},
        }
}</span>

func checkResourceName(headers map[string]any) error <span class="cov0" title="0">{
        resName, err := checkNotEmptyString(headers, "resource-name")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // same format as snap names
        <span class="cov0" title="0">if err := naming.ValidateSnap(resName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid resource name %q", resName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func assembleSnapResourceRevision(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        if err := checkResourceName(assert.headers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err := checkDigest(assert.headers, "resource-sha3-384", crypto.SHA3_384)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkStringMatches(assert.headers, "provenance", naming.ValidProvenance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resourceSize, err := checkUint(assert.headers, "resource-size", 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resourceRevision, err := checkSnapRevisionWhat(assert.headers, "resource-revision", "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "developer-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resourceIntegrityData, err := checkSnapIntegrity(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SnapResourceRevision{
                assertionBase:         assert,
                resourceSize:          resourceSize,
                resourceRevision:      resourceRevision,
                timestamp:             timestamp,
                resourceIntegrityData: resourceIntegrityData,
        }, nil</span>
}

// SnapResourcePair holds a snap-resource-pair assertion, which is a
// statement by the store acknowledging that it received indication
// that the given snap resource revision can work with the given
// snap revision.
type SnapResourcePair struct {
        assertionBase
        resourceRevision int
        snapRevision     int
        timestamp        time.Time
}

// SnapID returns the snap id of the snap for the resource.
func (respair *SnapResourcePair) SnapID() string <span class="cov0" title="0">{
        return respair.HeaderString("snap-id")
}</span>

// ResourceName returns the name of the snap resource.
func (respair *SnapResourcePair) ResourceName() string <span class="cov0" title="0">{
        return respair.HeaderString("resource-name")
}</span>

// ResourceRevision returns the snap resource revision being paired.
func (respair *SnapResourcePair) ResourceRevision() int <span class="cov0" title="0">{
        return respair.resourceRevision
}</span>

// SnapRevision returns the snap revision being paired with.
func (respair *SnapResourcePair) SnapRevision() int <span class="cov0" title="0">{
        return respair.snapRevision
}</span>

// Provenance returns the optional provenance of the snap (defaults to
// global-upload (naming.DefaultProvenance)).
func (respair *SnapResourcePair) Provenance() string <span class="cov0" title="0">{
        return respair.HeaderString("provenance")
}</span>

// DeveloperID returns the id of the developer that submitted the snap resource for the snap revision.
func (respair *SnapResourcePair) DeveloperID() string <span class="cov0" title="0">{
        return respair.HeaderString("developer-id")
}</span>

// Timestamp returns the time when the snap-resource-pair was issued.
func (respair *SnapResourcePair) Timestamp() time.Time <span class="cov0" title="0">{
        return respair.timestamp
}</span>

// Implement further consistency checks.
func (respair *SnapResourcePair) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        otherProvenance := respair.Provenance() != naming.DefaultProvenance
        if !otherProvenance &amp;&amp; !db.IsTrustedAccount(respair.AuthorityID()) </span><span class="cov0" title="0">{
                // delegating global-upload revisions is not allowed
                return fmt.Errorf("snap-resource-pair assertion for snap id %q is not signed by a store: %s", respair.SnapID(), respair.AuthorityID())
        }</span>
        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{
                "account-id": respair.DeveloperID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-resource-pair assertion for snap id %q does not have a matching account assertion for the developer %q", respair.SnapID(), respair.DeveloperID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a, err := db.Find(SnapDeclarationType, map[string]string{
                "series":  release.Series,
                "snap-id": respair.SnapID(),
        })
        if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                return fmt.Errorf("snap-resource-pair assertion for snap id %q does not have a matching snap-declaration assertion", respair.SnapID())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if otherProvenance </span><span class="cov0" title="0">{
                decl := a.(*SnapDeclaration)
                ras := decl.RevisionAuthority(respair.Provenance())
                // check that there's matching delegation using the snap-revision
                matchingRevAuthority := false
                for _, ra := range ras </span><span class="cov0" title="0">{
                        // model==store==nil, we do not perform device-specific
                        // checks at this level, those are performed at
                        // higher-level guarding installing actual components
                        if err := ra.checkProvenanceAndRevision(respair, "snap", respair.SnapRevision(), nil, nil); err == nil </span><span class="cov0" title="0">{
                                matchingRevAuthority = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !matchingRevAuthority </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap-resource-pair assertion with provenance %q for snap id %q is not signed by an authorized authority: %s", respair.Provenance(), respair.SnapID(), respair.AuthorityID())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// expected interface is implemented
var _ consistencyChecker = (*SnapResourcePair)(nil)

// Prerequisites returns references to this snap-resource-pair's prerequisite assertions.
func (respair *SnapResourcePair) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {Type: SnapDeclarationType, PrimaryKey: []string{release.Series, respair.SnapID()}},
        }
}</span>

func assembleSnapResourcePair(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        if err := checkResourceName(assert.headers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err := checkStringMatches(assert.headers, "provenance", naming.ValidProvenance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resourceRevision, err := checkSnapRevisionWhat(assert.headers, "resource-revision", "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapRevision, err := checkSnapRevisionWhat(assert.headers, "snap-revision", "header")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkNotEmptyString(assert.headers, "developer-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SnapResourcePair{
                assertionBase:    assert,
                resourceRevision: resourceRevision,
                snapRevision:     snapRevision,
                timestamp:        timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2017 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "net/url"
        "time"
)

// Store holds a store assertion, defining the configuration needed to connect
// a device to the store or relative to a non-default store.
type Store struct {
        assertionBase
        url            *url.URL
        friendlyStores []string
        timestamp      time.Time
}

// Store returns the identifying name of the operator's store.
func (store *Store) Store() string <span class="cov0" title="0">{
        return store.HeaderString("store")
}</span>

// OperatorID returns the account id of the store's operator.
func (store *Store) OperatorID() string <span class="cov0" title="0">{
        return store.HeaderString("operator-id")
}</span>

// URL returns the URL of the store's API.
func (store *Store) URL() *url.URL <span class="cov0" title="0">{
        return store.url
}</span>

// FriendlyStores returns stores holding snaps that are also exposed
// through this one.
func (store *Store) FriendlyStores() []string <span class="cov0" title="0">{
        return store.friendlyStores
}</span>

// Location returns a summary of the store's location/purpose.
func (store *Store) Location() string <span class="cov0" title="0">{
        return store.HeaderString("location")
}</span>

// Timestamp returns the time when the store assertion was issued.
func (store *Store) Timestamp() time.Time <span class="cov0" title="0">{
        return store.timestamp
}</span>

func (store *Store) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // Will be applied to a system's snapd or influence snapd
        // policy decisions (via friendly-stores) so must be signed by a trusted
        // authority!
        if !db.IsTrustedAccount(store.AuthorityID()) </span><span class="cov0" title="0">{
                return fmt.Errorf("store assertion %q is not signed by a directly trusted authority: %s",
                        store.Store(), store.AuthorityID())
        }</span>

        <span class="cov0" title="0">_, err := db.Find(AccountType, map[string]string{"account-id": store.OperatorID()})
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, &amp;NotFoundError{}) </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "store assertion %q does not have a matching account assertion for the operator %q",
                                store.Store(), store.OperatorID())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Prerequisites returns references to this store's prerequisite assertions.
func (store *Store) Prerequisites() []*Ref <span class="cov0" title="0">{
        return []*Ref{
                {AccountType, []string{store.OperatorID()}},
        }
}</span>

// checkStoreURL validates the "url" header and returns a full URL or nil.
func checkStoreURL(headers map[string]any) (*url.URL, error) <span class="cov0" title="0">{
        s, err := checkOptionalString(headers, "url")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">errWhat := `"url" header`

        u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s must be a valid URL: %s", errWhat, s)
        }</span>
        <span class="cov0" title="0">if u.Scheme != "http" &amp;&amp; u.Scheme != "https" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`%s scheme must be "https" or "http": %s`, errWhat, s)
        }</span>
        <span class="cov0" title="0">if u.Host == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`%s must have a host: %s`, errWhat, s)
        }</span>
        <span class="cov0" title="0">if u.RawQuery != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`%s must not have a query: %s`, errWhat, s)
        }</span>
        <span class="cov0" title="0">if u.Fragment != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`%s must not have a fragment: %s`, errWhat, s)
        }</span>

        <span class="cov0" title="0">return u, nil</span>
}

func assembleStore(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        _, err := checkNotEmptyString(assert.headers, "operator-id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url, err := checkStoreURL(assert.headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">friendlyStores, err := checkStringList(assert.headers, "friendly-stores")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = checkOptionalString(assert.headers, "location")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Store{
                assertionBase:  assert,
                url:            url,
                friendlyStores: friendlyStores,
                timestamp:      timestamp,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "fmt"
        "net/mail"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// validSystemUserUsernames matches the regex we allow by osutil/user.go:IsValidUsername
var validSystemUserUsernames = regexp.MustCompile(`^[a-z0-9][-a-z0-9._]*$`)

// SystemUser holds a system-user assertion which allows creating local
// system users.
type SystemUser struct {
        assertionBase
        series     []string
        models     []string
        serials    []string
        sshKeys    []string
        since      time.Time
        until      time.Time
        expiration string

        forcePasswordChange bool
}

// BrandID returns the brand identifier that signed this assertion.
func (su *SystemUser) BrandID() string <span class="cov0" title="0">{
        return su.HeaderString("brand-id")
}</span>

// Email returns the email address that this assertion is valid for.
func (su *SystemUser) Email() string <span class="cov0" title="0">{
        return su.HeaderString("email")
}</span>

// Series returns the series that this assertion is valid for.
func (su *SystemUser) Series() []string <span class="cov0" title="0">{
        return su.series
}</span>

// Models returns the models that this assertion is valid for.
func (su *SystemUser) Models() []string <span class="cov0" title="0">{
        return su.models
}</span>

// Serials returns the serials that this assertion is valid for.
func (su *SystemUser) Serials() []string <span class="cov0" title="0">{
        return su.serials
}</span>

// Name returns the full name of the user (e.g. Random Guy).
func (su *SystemUser) Name() string <span class="cov0" title="0">{
        return su.HeaderString("name")
}</span>

// Username returns the system user name that should be created (e.g. "foo").
func (su *SystemUser) Username() string <span class="cov0" title="0">{
        return su.HeaderString("username")
}</span>

// Password returns the crypt(3) compatible password for the user.
// Note that only ID: $6$ or stronger is supported (sha512crypt).
func (su *SystemUser) Password() string <span class="cov0" title="0">{
        return su.HeaderString("password")
}</span>

// ForcePasswordChange returns true if the user needs to change the password
// after the first login.
func (su *SystemUser) ForcePasswordChange() bool <span class="cov0" title="0">{
        return su.forcePasswordChange
}</span>

// SSHKeys returns the ssh keys for the user.
func (su *SystemUser) SSHKeys() []string <span class="cov0" title="0">{
        return su.sshKeys
}</span>

// Since returns the time since the assertion is valid.
func (su *SystemUser) Since() time.Time <span class="cov0" title="0">{
        return su.since
}</span>

// Until returns the time until the assertion is valid.
func (su *SystemUser) Until() time.Time <span class="cov0" title="0">{
        return su.until
}</span>

// UserExpiration returns the expiration or validity duration of the user created.
//
// If no expiration was specified, this will return an zero time.Time structure.
//
// If expiration was set to 'until-expiration' then the .Until() time will be
// returned.
func (su *SystemUser) UserExpiration() time.Time <span class="cov0" title="0">{
        if su.expiration == "until-expiration" </span><span class="cov0" title="0">{
                return su.until
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

// ValidAt returns whether the system-user is valid at 'when' time.
func (su *SystemUser) ValidAt(when time.Time) bool <span class="cov0" title="0">{
        valid := when.After(su.since) || when.Equal(su.since)
        if valid </span><span class="cov0" title="0">{
                valid = when.Before(su.until)
        }</span>
        <span class="cov0" title="0">return valid</span>
}

// Implement further consistency checks.
func (su *SystemUser) checkConsistency(db RODatabase, acck *AccountKey) error <span class="cov0" title="0">{
        // Do the cross-checks when this assertion is actually used,
        // i.e. in the create-user code. See also Model.checkConsitency

        return nil
}</span>

// expected interface is implemented
var _ consistencyChecker = (*SystemUser)(nil)

type shadow struct {
        ID     string
        Rounds string
        Salt   string
        Hash   string
}

// crypt(3) compatible hashes have the forms:
// - $id$salt$hash
// - $id$rounds=N$salt$hash
func parseShadowLine(line string) (*shadow, error) <span class="cov0" title="0">{
        l := strings.SplitN(line, "$", 5)
        if len(l) != 4 &amp;&amp; len(l) != 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`hashed password must be of the form "$integer-id$salt$hash", see crypt(3)`)
        }</span>

        // if rounds is the second field, the line must consist of 4
        <span class="cov0" title="0">if strings.HasPrefix(l[2], "rounds=") &amp;&amp; len(l) == 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`missing hash field`)
        }</span>

        // shadow line without $rounds=N$
        <span class="cov0" title="0">if len(l) == 4 </span><span class="cov0" title="0">{
                return &amp;shadow{
                        ID:   l[1],
                        Salt: l[2],
                        Hash: l[3],
                }, nil
        }</span>
        // shadow line with rounds
        <span class="cov0" title="0">return &amp;shadow{
                ID:     l[1],
                Rounds: l[2],
                Salt:   l[3],
                Hash:   l[4],
        }, nil</span>
}

// see crypt(3) for the legal chars
var isValidSaltAndHash = regexp.MustCompile(`^[a-zA-Z0-9./]+$`).MatchString

func checkHashedPassword(headers map[string]any, name string) (string, error) <span class="cov0" title="0">{
        pw, err := checkOptionalString(headers, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // the pw string is optional, so just return if its empty
        <span class="cov0" title="0">if pw == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // parse the shadow line
        <span class="cov0" title="0">shd, err := parseShadowLine(pw)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(`%q header invalid: %s`, name, err)
        }</span>

        // and verify it

        // see crypt(3), ID 6 means SHA-512 (since glibc 2.7)
        <span class="cov0" title="0">ID, err := strconv.Atoi(shd.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(`%q header must start with "$integer-id$", got %q`, name, shd.ID)
        }</span>
        // double check that we only allow modern hashes
        <span class="cov0" title="0">if ID &lt; 6 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q header only supports $id$ values of 6 (sha512crypt) or higher", name)
        }</span>

        // the $rounds=N$ part is optional
        <span class="cov0" title="0">if strings.HasPrefix(shd.Rounds, "rounds=") </span><span class="cov0" title="0">{
                rounds, err := strconv.Atoi(strings.SplitN(shd.Rounds, "=", 2)[1])
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("%q header has invalid number of rounds: %s", name, err)
                }</span>
                <span class="cov0" title="0">if rounds &lt; 5000 || rounds &gt; 999999999 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("%q header rounds parameter out of bounds: %d", name, rounds)
                }</span>
        }

        <span class="cov0" title="0">if !isValidSaltAndHash(shd.Salt) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q header has invalid chars in salt %q", name, shd.Salt)
        }</span>
        <span class="cov0" title="0">if !isValidSaltAndHash(shd.Hash) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q header has invalid chars in hash %q", name, shd.Hash)
        }</span>

        <span class="cov0" title="0">return pw, nil</span>
}

func checkSystemUserPresence(assert assertionBase) (string, error) <span class="cov0" title="0">{
        str, err := checkOptionalString(assert.headers, "user-presence")
        if err != nil || str == "" </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if assert.Format() &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf(`the "user-presence" header is only supported for format 2 or greater`)
        }</span>

        <span class="cov0" title="0">if str != "until-expiration" </span><span class="cov0" title="0">{
                return "", fmt.Errorf(`invalid "user-presence" header, only explicit valid value is "until-expiration": %q`, str)
        }</span>
        <span class="cov0" title="0">return str, nil</span>
}

func assembleSystemUser(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        // brand-id here can be different from authority-id,
        // the code using the assertion must use the policy set
        // by the model assertion system-user-authority header
        email, err := checkNotEmptyString(assert.headers, "email")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := mail.ParseAddress(email); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"email" header must be a RFC 5322 compliant email address: %s`, err)
        }</span>

        <span class="cov0" title="0">series, err := checkStringList(assert.headers, "series")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">models, err := checkStringList(assert.headers, "models")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">serials, err := checkStringList(assert.headers, "serials")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(serials) &gt; 0 &amp;&amp; assert.Format() &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`the "serials" header is only supported for format 1 or greater`)
        }</span>
        <span class="cov0" title="0">if len(serials) &gt; 0 &amp;&amp; len(models) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`in the presence of the "serials" header "models" must specify exactly one model`)
        }</span>

        <span class="cov0" title="0">if _, err := checkOptionalString(assert.headers, "name"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := checkStringMatches(assert.headers, "username", validSystemUserUsernames); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">password, err := checkHashedPassword(assert.headers, "password")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">forcePasswordChange, err := checkOptionalBool(assert.headers, "force-password-change")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if forcePasswordChange &amp;&amp; password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`cannot use "force-password-change" with an empty "password"`)
        }</span>

        <span class="cov0" title="0">sshKeys, err := checkStringList(assert.headers, "ssh-keys")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">since, err := checkRFC3339Date(assert.headers, "since")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">until, err := checkRFC3339Date(assert.headers, "until")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if until.Before(since) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'until' time cannot be before 'since' time")
        }</span>
        <span class="cov0" title="0">expiration, err := checkSystemUserPresence(assert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // "global" system-user assertion can only be valid for 1y
        <span class="cov0" title="0">if len(models) == 0 &amp;&amp; until.After(since.AddDate(1, 0, 0)) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'until' time cannot be more than 365 days in the future when no models are specified")
        }</span>

        <span class="cov0" title="0">return &amp;SystemUser{
                assertionBase:       assert,
                series:              series,
                models:              models,
                serials:             serials,
                sshKeys:             sshKeys,
                since:               since,
                until:               until,
                expiration:          expiration,
                forcePasswordChange: forcePasswordChange,
        }, nil</span>
}

func systemUserFormatAnalyze(headers map[string]any, body []byte) (formatnum int, err error) <span class="cov0" title="0">{
        formatnum = 0

        serials, err := checkStringList(headers, "serials")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if len(serials) &gt; 0 </span><span class="cov0" title="0">{
                formatnum = 1
        }</span>

        <span class="cov0" title="0">presence, err := checkOptionalString(headers, "user-presence")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if presence != "" </span><span class="cov0" title="0">{
                formatnum = 2
        }</span>

        <span class="cov0" title="0">return formatnum, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2020 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 */

package asserts

import (
        "errors"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/snapcore/snapd/snap/naming"
        "github.com/snapcore/snapd/strutil"
)

// Presence represents a presence constraint.
type Presence string

const (
        PresenceRequired Presence = "required"
        PresenceOptional Presence = "optional"
        PresenceInvalid  Presence = "invalid"
)

func presencesAsStrings(presences ...Presence) []string <span class="cov8" title="1">{
        strs := make([]string, len(presences))
        for i, pres := range presences </span><span class="cov8" title="1">{
                strs[i] = string(pres)
        }</span>
        <span class="cov8" title="1">return strs</span>
}

var validValidationSetSnapPresences = presencesAsStrings(PresenceRequired, PresenceOptional, PresenceInvalid)

func checkOptionalPresence(headers map[string]any, which string, valid []string) (Presence, error) <span class="cov0" title="0">{
        presence, err := checkOptionalStringWhat(headers, "presence", which)
        if err != nil </span><span class="cov0" title="0">{
                return Presence(""), err
        }</span>
        <span class="cov0" title="0">if presence != "" &amp;&amp; !strutil.ListContains(valid, presence) </span><span class="cov0" title="0">{
                return Presence(""), fmt.Errorf("presence %s must be one of %s", which, strings.Join(valid, "|"))
        }</span>
        <span class="cov0" title="0">return Presence(presence), nil</span>
}

func checkPresence(headers map[string]any, which string, valid []string) (Presence, error) <span class="cov0" title="0">{
        presence, err := checkExistsStringWhat(headers, "presence", which)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if presence != "" &amp;&amp; !strutil.ListContains(valid, presence) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("presence %s must be one of %s", which, strings.Join(valid, "|"))
        }</span>
        <span class="cov0" title="0">return Presence(presence), nil</span>
}

// ValidationSetSnap holds the details about a snap constrained by a validation-set assertion.
type ValidationSetSnap struct {
        Name   string
        SnapID string

        Presence Presence

        Revision   int
        Components map[string]ValidationSetComponent
}

type ValidationSetComponent struct {
        Presence Presence
        Revision int
}

// SnapName implements naming.SnapRef.
func (s *ValidationSetSnap) SnapName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ID implements naming.SnapRef.
func (s *ValidationSetSnap) ID() string <span class="cov0" title="0">{
        return s.SnapID
}</span>

func checkValidationSetSnap(snap map[string]any) (*ValidationSetSnap, error) <span class="cov0" title="0">{
        snapName, err := checkNotEmptyStringWhat(snap, "name", "of snap")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := naming.ValidateSnap(snapName); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid snap name %q", snapName)
        }</span>

        <span class="cov0" title="0">what := fmt.Sprintf("of snap %q", snapName)

        snapID, err := checkStringMatchesWhat(snap, "id", what, naming.ValidSnapID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">presence, err := checkOptionalPresence(snap, what, validValidationSetSnapPresences)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var snapRevision int
        if _, ok := snap["revision"]; ok </span><span class="cov0" title="0">{
                var err error
                snapRevision, err = checkSnapRevisionWhat(snap, "revision", what)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if snapRevision != 0 &amp;&amp; presence == PresenceInvalid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`cannot specify revision %s at the same time as stating its presence is invalid`, what)
        }</span>

        <span class="cov0" title="0">components, err := checkValidationSetComponents(snapName, snap, snapRevision)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ValidationSetSnap{
                Name:       snapName,
                SnapID:     snapID,
                Presence:   presence,
                Revision:   snapRevision,
                Components: components,
        }, nil</span>
}

func checkValidationSetComponents(snapName string, snap map[string]any, snapRevision int) (map[string]ValidationSetComponent, error) <span class="cov0" title="0">{
        mapping, err := checkMapWhat(snap, "components", fmt.Sprintf("of snap %q", snapName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(`"components" field in "snaps" header must be a map`)
        }</span>

        <span class="cov0" title="0">if len(mapping) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">components := make(map[string]ValidationSetComponent, len(mapping))
        for name, comp := range mapping </span><span class="cov0" title="0">{
                var parsed map[string]any
                switch c := comp.(type) </span>{
                case map[string]any:<span class="cov0" title="0">
                        parsed = c</span>
                case string:<span class="cov0" title="0">
                        parsed = map[string]any{"presence": c}</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New(`each field in "components" map must be either a map or a string`)</span>
                }

                <span class="cov0" title="0">component, err := checkValidationSetComponent(name, parsed, snapName, snapRevision)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">components[name] = component</span>
        }

        <span class="cov0" title="0">return components, nil</span>
}

func checkValidationSetComponent(compName string, comp map[string]any, snapName string, snapRevision int) (ValidationSetComponent, error) <span class="cov0" title="0">{
        if err := naming.ValidateSnap(compName); err != nil </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, fmt.Errorf("invalid component name %q", compName)
        }</span>

        <span class="cov0" title="0">what := fmt.Sprintf("of component %q", naming.NewComponentRef(snapName, compName))

        presence, err := checkPresence(comp, what, validValidationSetSnapPresences)
        if err != nil </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, err
        }</span>

        <span class="cov0" title="0">revision, err := checkOptionalSnapRevisionWhat(comp, "revision", what)
        if err != nil </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, err
        }</span>

        <span class="cov0" title="0">if revision != 0 &amp;&amp; presence == PresenceInvalid </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, fmt.Errorf("cannot specify component revision %s at the same time as stating its presence is invalid", what)
        }</span>

        <span class="cov0" title="0">if snapRevision != 0 &amp;&amp; revision == 0 &amp;&amp; presence != PresenceInvalid </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, fmt.Errorf("must specify revision %s since its associated snap specifies a revision", what)
        }</span>

        <span class="cov0" title="0">if snapRevision == 0 &amp;&amp; revision != 0 </span><span class="cov0" title="0">{
                return ValidationSetComponent{}, fmt.Errorf("cannot specify revision %s if its associated snap does not specify a revision", what)
        }</span>

        <span class="cov0" title="0">return ValidationSetComponent{
                Presence: presence,
                Revision: revision,
        }, nil</span>
}

func checkValidationSetSnaps(snapList any) ([]*ValidationSetSnap, error) <span class="cov0" title="0">{
        const wrongHeaderType = `"snaps" header must be a list of maps`

        entries, ok := snapList.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(wrongHeaderType)
        }</span>

        <span class="cov0" title="0">seen := make(map[string]bool, len(entries))
        seenIDs := make(map[string]string, len(entries))
        snaps := make([]*ValidationSetSnap, 0, len(entries))
        for _, entry := range entries </span><span class="cov0" title="0">{
                snap, ok := entry.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(wrongHeaderType)
                }</span>
                <span class="cov0" title="0">valSetSnap, err := checkValidationSetSnap(snap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if seen[valSetSnap.Name] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot list the same snap %q multiple times", valSetSnap.Name)
                }</span>
                <span class="cov0" title="0">seen[valSetSnap.Name] = true
                snapID := valSetSnap.SnapID
                if underName := seenIDs[snapID]; underName != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot specify the same snap id %q multiple times, specified for snaps %q and %q", snapID, underName, valSetSnap.Name)
                }</span>
                <span class="cov0" title="0">seenIDs[snapID] = valSetSnap.Name

                if valSetSnap.Presence == "" </span><span class="cov0" title="0">{
                        valSetSnap.Presence = PresenceRequired
                }</span>

                <span class="cov0" title="0">snaps = append(snaps, valSetSnap)</span>
        }

        <span class="cov0" title="0">return snaps, nil</span>
}

// ValidationSet holds a validation-set assertion, which is a
// statement by an account about a set snaps and possibly revisions
// for which an extrinsic/implied property is valid (e.g. they work
// well together). validation-sets are organized in sequences under a
// name.
type ValidationSet struct {
        assertionBase

        seq int

        snaps []*ValidationSetSnap

        timestamp time.Time
}

// SequenceKey returns the sequence key for this validation set.
func (vs *ValidationSet) SequenceKey() string <span class="cov0" title="0">{
        return vsSequenceKey(vs.Series(), vs.AccountID(), vs.Name())
}</span>

func vsSequenceKey(series, accountID, name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s", series, accountID, name)
}</span>

// Series returns the series for which the snap in the set are declared.
func (vs *ValidationSet) Series() string <span class="cov0" title="0">{
        return vs.HeaderString("series")
}</span>

// AccountID returns the identifier of the account that signed this assertion.
func (vs *ValidationSet) AccountID() string <span class="cov0" title="0">{
        return vs.HeaderString("account-id")
}</span>

// Name returns the name under which the validation-set is organized.
func (vs *ValidationSet) Name() string <span class="cov0" title="0">{
        return vs.HeaderString("name")
}</span>

// Sequence returns the sequential number of the validation-set in its
// named sequence.
func (vs *ValidationSet) Sequence() int <span class="cov0" title="0">{
        return vs.seq
}</span>

// Snaps returns the constrained snaps by the validation-set.
func (vs *ValidationSet) Snaps() []*ValidationSetSnap <span class="cov0" title="0">{
        return vs.snaps
}</span>

// Timestamp returns the time when the validation-set was issued.
func (vs *ValidationSet) Timestamp() time.Time <span class="cov0" title="0">{
        return vs.timestamp
}</span>

func checkSequence(headers map[string]any, name string) (int, error) <span class="cov0" title="0">{
        seqnum, err := checkInt(headers, name)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">if seqnum &lt; 1 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("%q must be &gt;=1: %v", name, seqnum)
        }</span>
        <span class="cov0" title="0">return seqnum, nil</span>
}

var (
        validValidationSetName = regexp.MustCompile("^[a-z0-9](?:-?[a-z0-9])*$")
)

func assembleValidationSet(assert assertionBase) (Assertion, error) <span class="cov0" title="0">{
        authorityID := assert.AuthorityID()
        accountID := assert.HeaderString("account-id")
        if accountID != authorityID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authority-id and account-id must match, validation-set assertions are expected to be signed by the issuer account: %q != %q", authorityID, accountID)
        }</span>

        <span class="cov0" title="0">_, err := checkStringMatches(assert.headers, "name", validValidationSetName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">seq, err := checkSequence(assert.headers, "sequence")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">snapList, ok := assert.headers["snaps"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(`"snaps" header is mandatory`)
        }</span>
        <span class="cov0" title="0">snaps, err := checkValidationSetSnaps(snapList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timestamp, err := checkRFC3339Date(assert.headers, "timestamp")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ValidationSet{
                assertionBase: assert,
                seq:           seq,
                snaps:         snaps,
                timestamp:     timestamp,
        }, nil</span>
}

func IsValidValidationSetName(name string) bool <span class="cov0" title="0">{
        return validValidationSetName.MatchString(name)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
