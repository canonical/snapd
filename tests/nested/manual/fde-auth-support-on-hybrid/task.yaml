summary: End-to-end test for FDE PIN and passphrase support on hybrid systems

details: |
  This test installs an encrypted hybrid Ubuntu system using muinstaller
  which is then protected by PIN and passphrase authentication after
  first boot. Multiple transitions between the available authentication
  modes are exercised (PIN <-> Passphrase <-> None).

systems:
  # FIXME: make it work on 26
  - ubuntu-24*

environment:
  # Defaults
  MODEL_VERSION: "25.10"
  GADGET_VERSION: "classic-25.10"
  KERNEL_VERSION: "25.10"
  KDF_TYPE: default

  MODEL_VERSION/2510: "25.10"
  GADGET_VERSION/2510: "classic-25.10"
  KERNEL_VERSION/2510: "25.10"

  MODEL_VERSION/2404: "24.04"
  GADGET_VERSION/2404: classic-24.04
  KERNEL_VERSION/2404: "24"

  MODEL_VERSION/2504: "25.04"
  GADGET_VERSION/2504: "classic-25.04"
  KERNEL_VERSION/2504: "25.04"

  # XXX: Add UC test variant? It is not officially supported
  # but might help spot edge cases.

  KDF_TYPE/pbkdf2: pbkdf2
  KDF_TYPE/argon2i: argon2i
  KDF_TYPE/argon2id: argon2id

  NESTED_ENABLE_TPM: true
  NESTED_ENABLE_SECURE_BOOT: true
  NESTED_BUILD_SNAPD_FROM_CURRENT: true
  NESTED_REPACK_KERNEL_SNAP: true
  NESTED_KEEP_FIRMWARE_STATE: true

  # Store related setup.
  STORE_ADDR: localhost:11028
  STORE_DIR: $(pwd)/fake-store-blobdir

prepare: |
  if [ "$TRUST_TEST_KEYS" = "false" ]; then
      echo "This test needs test keys to be trusted"
      exit
  fi

  # shellcheck source=tests/lib/prepare.sh
  . "$TESTSLIB/prepare.sh"
  #shellcheck source=tests/lib/nested.sh
  . "$TESTSLIB"/nested.sh

  # Fakestore is needed for "snap prepare-image".
  "$TESTSTOOLS"/store-state setup-fake-store "$STORE_DIR"

  # Expose the needed assertions through the fakestore.
  cp "$TESTSLIB"/assertions/developer1.account "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/developer1.account-key "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/testrootorg-store.account-key "$STORE_DIR/asserts"
  export SNAPPY_FORCE_SAS_URL=http://$STORE_ADDR

  # Retrieve the gadget
  snap download --basename=pc --channel="$GADGET_VERSION/edge" pc

  # Retrieve kernel.
  snap download --basename=pc-kernel --channel="$KERNEL_VERSION/${KERNEL_CHANNEL}" pc-kernel
  # Build kernel with initramfs with the compiled snap-bootstrap
  uc24_build_initramfs_kernel_snap "$PWD/pc-kernel.snap" "$NESTED_ASSETS_DIR"
  mv "${NESTED_ASSETS_DIR}"/pc-kernel_*.snap pc-kernel.snap

  if [ "$MODEL_VERSION" = "25.04" ]; then
    # 25.04 dangerous model is missing core24 (which is a dependency of pc gadget), let's use local one for now
    # https://github.com/canonical/models/blob/master/ubuntu-classic-2504-amd64-dangerous.json
    cp "$TESTSLIB"/assertions/developer1-2504-classic-dangerous.json classic.json
  else
    # fetch upstream models
    model_version_string="${MODEL_VERSION//\./}"
    curl -q https://raw.githubusercontent.com/canonical/models/refs/heads/master/ubuntu-classic-"${model_version_string}"-amd64-dangerous.json > classic.json
    # but only keep relevant snaps
    gojq 'del(.snaps[] | select(.name | test("^(pc|pc-kernel|core.*|snapd)$") | not))' classic.json > classic-tmp.json
    mv classic-tmp.json classic.json
    # and replace authority-id and brand-id
    gojq '."authority-id" = "developer1" | ."brand-id" = "developer1"' classic.json > classic-tmp.json
    mv classic-tmp.json classic.json
  fi

  gendeveloper1 sign-model < classic.json > classic.model

  cat << EOF > ./prepare-rootfs.sh
  rootfs="\$1"
  echo ID=ubuntu > \${rootfs}/etc/os-release
  echo VERSION_ID="${MODEL_VERSION}" >> \${rootfs}/etc/os-release
  EOF

  export HYBRID_SYSTEM_MK_ROOT_FS="${PWD}/prepare-rootfs.sh"

  # 25.10 gadget require much larger disks
  # https://github.com/canonical/pc-gadget/commit/814d80acbcc0de4ac799b3bcb67f7ec625d6c53a
  if [ "${MODEL_VERSION}" == "25.10" ]; then
    truncate --size=10G disk.img
  else
    truncate --size=6G disk.img
  fi

  # setup_nested_hybrid_system.sh runs the muinstaller to install a hybrid system.
  "${TESTSTOOLS}"/setup_nested_hybrid_system.sh \
    --model classic.model \
    --store-dir "${STORE_DIR}" \
    --gadget pc.snap \
    --gadget-assertion pc.assert \
    --kernel pc-kernel.snap \
    --kernel-assertion pc-kernel.assert \
    --disk disk.img

restore: |
  "$TESTSTOOLS"/store-state teardown-fake-store "$STORE_DIR"
  rm -rf pc-kernel.* pc.* initrd* linux* kernel* tmp* pc-gadget

debug: |
  if [ -f containers.out ]; then
    echo "Last system-volumes value (containers.out)"
    cat containers.out
  fi

  echo "Current system-volumes"
  remote.exec sudo snap debug api /v2/system-volumes

execute: |
  # the APIs tested here shouldn't be available on anything before 25.10
  if [ "${MODEL_VERSION}" != "25.10" ]; then
    remote.exec sudo snap debug api /v2/system-volumes | gojq .result.message | MATCH "this action is not supported on this system"
    exit 0
  fi

  # Check encryption
  remote.exec sudo snap debug api /v2/system-volumes > containers.out

  # system-boot is not encrypted
  gojq '.result."by-container-role"."system-boot"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^false$"
  gojq '.keyslots | length' < container.out | MATCH "^0$"

  # system-seed is also not encrypted
  gojq '.result."by-container-role"."system-seed"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^false$"
  gojq '.keyslots | length' < container.out | MATCH "^0$"

  # system-data is encrypted but not protected by a passphrase or PIN yet
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"

  # system-save is also encrypted not protected by a passphrase or PIN yet
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"

  # shellcheck source=tests/lib/prepare.sh
  . "$TESTSLIB/prepare.sh"
  #shellcheck source=tests/lib/nested.sh
  . "$TESTSLIB"/nested.sh

  remote_action_request()
  {
    local json_req="$1"
    echo "echo '$json_req' | sudo snap debug api -H \"Content-Type: application/json\" -X POST /v2/system-volumes" > action_request
    remote.exec "$(cat action_request)" > resp
  }

  reboot_with_passphrase()
  {
    tests.nested vm set-passphrase "$1"
    tests.nested vm stop
    tests.nested vm start
  }

  # Test setting a passphrase after first boot
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "passphrase", "passphrase": "ubuntu-1"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "ubuntu-1"

  # Check keyslots
  remote.exec sudo snap debug api /v2/system-volumes > containers.out

  # system-data is encrypted and protected by a passphrase
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^passphrase$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^passphrase$"

  # system-save is also encrypted and protected by a passphrase
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^passphrase$"

  # Test changing passphrases
  remote_action_request '{"action": "change-passphrase", "old-passphrase": "ubuntu-1", "new-passphrase": "ubuntu-2"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "ubuntu-2"

  # Let's reset the passphrase as root (without providing old passphrase)
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "passphrase", "passphrase": "ubuntu-3"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "ubuntu-3"

  # Let's switch to PINs as root
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "pin", "pin": "1234"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "1234"

  # Test changing PINs
  remote_action_request '{"action": "change-pin", "old-pin": "1234", "new-pin": "4321"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "4321"

  # Let's remove auth protection completely
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "none"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase ""

  # And bring it back (similar to first boot experience but now for PINs)
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "pin", "pin": "6789"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "6789"

  # refresh rebooting snap
  # $1: path to snap file
  # $2: snap name
  refresh_rebooting_snap()
  {
      local snap_filename=$1
      local snap_name=$2

      boot_id=$(tests.nested boot-id)

      printf "Test installing snap from file %s\n" "$snap_filename"
      remote.push "$snap_filename"
      # install will exit when waiting for the reboot
      remote.exec sudo snap install --dangerous "$snap_filename" | MATCH "Task set to wait until a system restart allows to continue"

      # Check that a reboot notification was setup.
      remote.exec test -f /run/reboot-required
      remote.exec cat /run/reboot-required.pkgs | MATCH "snap:${snap_name}"

      remote.exec sudo reboot || true
      remote.wait-for reboot --wait 1 -n 100 "$boot_id"
      remote.exec sudo snap watch --last=install
  }
  # Ensure update-notifier-common is installed so that reboot notification works.
  remote.exec "sudo apt install -y update-notifier-common"

  # Save PCR profile
  remote.exec "sudo cat /var/lib/snapd/state.json" | gojq -r '.data.fde."keyslot-roles".run.params.all."tpm2-pcr-profile"'  > pcr_profile

  # Test gadget refresh causing reseal.

  # Changing cmdline should force a reseal.
  unsquashfs -d pc-gadget pc.snap
  echo 'console=ttyS0 systemd.journald.forward_to_console=1 loglevel=4' > pc-gadget/cmdline.extra
  KEY_NAME=$(tests.nested download snakeoil-key)
  SNAKEOIL_KEY="$PWD/$KEY_NAME.key"
  SNAKEOIL_CERT="$PWD/$KEY_NAME.pem"
  tests.nested secboot-sign gadget pc-gadget "$SNAKEOIL_KEY" "$SNAKEOIL_CERT"
  snap pack --filename=pc-new.snap pc-gadget/
  refresh_rebooting_snap pc-new.snap pc

  # We expect a reseal, PCR profile should have been updated.
  remote.exec "sudo cat /var/lib/snapd/state.json" | gojq -r '.data.fde."keyslot-roles".run.params.all."tpm2-pcr-profile"'  > pcr_profile_current
  not diff pcr_profile pcr_profile_current
  mv pcr_profile_current pcr_profile

  # Test kernel refresh causing reseal.

  # Resigning kernel should be enough to trigger a reseal.
  uc24_build_initramfs_kernel_snap "$PWD/pc-kernel.snap" "$PWD/pc-kernel-new.snap"
  refresh_rebooting_snap pc-kernel-new.snap pc

  # We expect a reseal, PCR profile should have been updated.
  remote.exec "sudo cat /var/lib/snapd/state.json" | gojq -r '.data.fde."keyslot-roles".run.params.all."tpm2-pcr-profile"'  > pcr_profile_current
  not diff pcr_profile pcr_profile_current
  mv pcr_profile_current pcr_profile

  # Check encryption again for good measure
  remote.exec sudo snap debug api /v2/system-volumes > containers.out

  # system-data is encrypted and protected by a PIN
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^pin$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^pin$"

  # system-save is also encrypted and protected by a PIN
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^2$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^pin$"

  # Let's switch to a passphrase one more time for good measure
  remote_action_request '{"action": "replace-platform-key", "auth-mode": "passphrase", "passphrase": "ubuntu-4"}'
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  reboot_with_passphrase "ubuntu-4"
