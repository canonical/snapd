summary: End-to-end test for FDE recovery key APIs on hybrid systems

details: |
  This test installs an encrypted hybrid Ubuntu system using muinstaller
  and checks that the following recovery key operations work as expected:
    - Installer can set a recovery key during installtion
    - Users can check their recovery key is valid at runtime (need as a
      part of the firmware update flow)
    - Users can replace their recovery key at runtime
    - Users can add new recovery keys at runtime

systems:
  - ubuntu-24*
  - ubuntu-26*

environment:
  NESTED_ENABLE_TPM: true
  NESTED_ENABLE_SECURE_BOOT: true
  NESTED_BUILD_SNAPD_FROM_CURRENT: true
  NESTED_REPACK_KERNEL_SNAP: true
  # store related setup
  STORE_ADDR: localhost:11028
  STORE_DIR: $(pwd)/fake-store-blobdir

skip:
    - reason: This test needs test keys to be trusted
      if: |
        [ "$TRUST_TEST_KEYS" = "false" ]

prepare: |
  # TODO: this setup for hybrid tests is repeated in other tests
  # check if it can be made into helper or extend setup_nested_hybrid_system.sh

  # shellcheck source=tests/lib/prepare.sh
  . "$TESTSLIB/prepare.sh"
  #shellcheck source=tests/lib/nested.sh
  . "$TESTSLIB"/nested.sh

  "$TESTSTOOLS"/store-state setup-fake-store "$STORE_DIR"

  echo "Expose the needed assertions through the fakestore"
  cp "$TESTSLIB"/assertions/developer1.account "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/developer1.account-key "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/testrootorg-store.account-key "$STORE_DIR/asserts"
  export SNAPPY_FORCE_SAS_URL=http://$STORE_ADDR

  version="$(nested_get_version)"

  # Retrieve the gadget
  snap download --basename=pc --channel="$version/edge" pc

  # Retrieve kernel
  snap download --basename=pc-kernel-from-store --channel="$version/${KERNEL_CHANNEL}" pc-kernel
  # the fakestore needs this assertion
  snap ack pc-kernel-from-store.assert
  # Build kernel with initramfs with the compiled snap-bootstrap
  uc24_build_initramfs_kernel_snap "$PWD/pc-kernel-from-store.snap" "$NESTED_ASSETS_DIR"
  mv "${NESTED_ASSETS_DIR}"/pc-kernel_*.snap pc-kernel-repacked.snap

  gendeveloper1 sign-model < "$TESTSLIB"/assertions/developer1-"$version"-classic-dangerous.json > classic.model

  # setup_nested_hybrid_system.sh runs the muinstaller to install a hybrid
  # system
  # shellcheck disable=SC2086
  "${TESTSTOOLS}"/setup_nested_hybrid_system.sh \
     --model classic.model \
     --store-dir "${STORE_DIR}" \
     --gadget pc.snap \
     --gadget-assertion pc.assert \
     --kernel pc-kernel-repacked.snap \
     --kernel-assertion pc-kernel-from-store.assert \
     --recovery-key-out "$(pwd)"/rkey-pre-install.out

  echo "Check recovery key is generated and stored"
  MATCH '[0-9]{5}-[0-9]{5}-[0-9]{5}-[0-9]{5}-[0-9]{5}-[0-9]{5}-[0-9]{5}-[0-9]{5}' < rkey-pre-install.out

restore: |
  "$TESTSTOOLS"/store-state teardown-fake-store "$STORE_DIR"

execute: |
  # The APIs tested here shouldn't be available on anything before 25.10
  if os.query is-ubuntu-lt 25.10; then
    remote.exec sudo snap debug api /v2/system-volumes | gojq .result.message | MATCH "this action is not supported on this system"
    exit 0
  fi

  api_get_v2_system_info_storage_encrypted() {
      remote.exec "sudo snap debug api /v2/system-info/storage-encrypted 2>/dev/null"
  }

  api_get_v2_system_info_storage_encrypted | gojq '.result.status' | MATCH "active"

  # Check encryption
  remote.exec sudo snap debug api /v2/system-volumes > containers.out

  # system-boot is not encrypted
  gojq '.result."by-container-role"."system-boot"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^false$"
  gojq '.keyslots | length' < container.out | MATCH "^0$"

  # system-seed is also not encrypted
  gojq '.result."by-container-role"."system-seed"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^false$"
  gojq '.keyslots | length' < container.out | MATCH "^0$"

  # system-data is encrypted and has a recovery key
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^3$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"

  # system-save is also encrypted and protected by a passphrase
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^3$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"

  clear_tpm_and_reboot()
  {
    echo "Clear TPM and reboot to force recovery key request"
    tests.nested vm stop
    tests.nested vm clear-tpm
    tests.nested vm start
  }

  # Check we can boot with recovery key
  tests.nested vm set-recovery-key "$(cat rkey-pre-install.out)"
  clear_tpm_and_reboot

  remote_action_request()
  {
    local json_req="$1"
    echo "echo '$json_req' | sudo snap debug api -H \"Content-Type: application/json\" -X POST /v2/system-volumes" > action_request
    remote.exec "$(cat action_request)" > resp
  }

  # Checking recovery key during runtime works
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-pre-install.out)\"}"
  MATCH '"status": "OK"' < resp

  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"25606-44385-33636-39319-37657-55378-59317-07706\"}"
  MATCH '"status": "Bad Request"' < resp
  MATCH "invalid recovery key" < resp

  # Replace recovery key
  remote_action_request '{"action": "generate-recovery-key"}'
  gojq --raw-output '.result."key-id"' < resp > rkey-id.out
  gojq --raw-output '.result."recovery-key"' < resp > rkey-post-install.out

  remote_action_request "{\"action\": \"replace-recovery-key\", \"key-id\": \"$(cat rkey-id.out)\"}"
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  # Runtime recovery check works with the new key
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-post-install.out)\"}"
  MATCH '"status": "OK"' < resp

  # but now old recovery key is no longer valid
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-pre-install.out)\"}"
  MATCH '"status": "Bad Request"' < resp
  MATCH "invalid recovery key" < resp

  # We can boot with new recovery key
  tests.nested vm set-recovery-key "$(cat rkey-post-install.out)"
  clear_tpm_and_reboot

  api_get_v2_system_info_storage_encrypted | gojq '.result.status' | MATCH "recovery"

  # Check new/old recovery keys after reboot for good measure
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-post-install.out)\"}"
  MATCH '"status": "OK"' < resp

  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-pre-install.out)\"}"
  MATCH '"status": "Bad Request"' < resp
  MATCH "invalid recovery key" < resp

  # Check keyslots again for good measure
  remote.exec sudo snap debug api /v2/system-volumes > containers.out

  # system-data is encrypted and has a recovery key
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^3$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"

  # system-save is also encrypted and protected by a passphrase
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^3$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"

  # Add new recovery key
  remote_action_request '{"action": "generate-recovery-key"}'
  gojq --raw-output '.result."key-id"' < resp > rkey-id.out
  gojq --raw-output '.result."recovery-key"' < resp > rkey-extra.out

  remote_action_request "{\"action\": \"add-recovery-key\", \"key-id\": \"$(cat rkey-id.out)\", \"keyslots\": [{\"name\": \"landscape-recovery\"}]}"
  change_id="$(gojq --raw-output .change < resp)"
  remote.exec sudo snap watch "$change_id"

  # Runtime recovery check works with the new key
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-extra.out)\"}"
  MATCH '"status": "OK"' < resp

  # but also work with the existing key
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-post-install.out)\"}"
  MATCH '"status": "OK"' < resp

  # We can boot with newly added recovery key
  tests.nested vm set-recovery-key "$(cat rkey-extra.out)"
  clear_tpm_and_reboot

  # Check recovery keys after reboot for good measure
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-extra.out)\"}"
  MATCH '"status": "OK"' < resp
  remote_action_request "{\"action\": \"check-recovery-key\", \"recovery-key\": \"$(cat rkey-post-install.out)\"}"
  MATCH '"status": "OK"' < resp

  # Check keyslots include the new recovery key
  remote.exec sudo snap debug api /v2/system-volumes > containers.out
  
  # system-data is encrypted and has two recovery keys
  gojq '.result."by-container-role"."system-data"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^4$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"
  gojq --raw-output '.keyslots."landscape-recovery".type' < container.out | MATCH "^recovery$"

  # system-save is also encrypted and protected by a passphrase
  gojq '.result."by-container-role"."system-save"' < containers.out > container.out
  gojq '.encrypted' < container.out | MATCH "^true$"
  gojq '.keyslots | length' < container.out | MATCH "^4$"
  gojq --raw-output '.keyslots.default."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-fallback"."auth-mode"' < container.out | MATCH "^none$"
  gojq --raw-output '.keyslots."default-recovery".type' < container.out | MATCH "^recovery$"
  gojq --raw-output '.keyslots."landscape-recovery".type' < container.out | MATCH "^recovery$"

  # Check we can boot with the default recovery key for good measure
  tests.nested vm set-recovery-key "$(cat rkey-post-install.out)"
  clear_tpm_and_reboot

  api_get_v2_system_info_storage_encrypted | gojq '.result.status' | MATCH "recovery"

  # TODO:FDEM: Grow test to check that we can reprovision and reseal
  # then reboot without recovery keys
