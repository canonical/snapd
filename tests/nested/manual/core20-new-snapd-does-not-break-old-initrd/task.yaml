summary: verify that new snapd's do not break old snap-bootstrap/kernel initrds

details: |
  The snapd secure boot implementation is complex, and some of the elements that live in the
  snapd.git repository end up as a part of the signed kernel package's initrd
  file. This inadvertently allows a skew to occur, where a future snapd is booted with a past
  initrd.

  The test exercises two scenarios:
  
  1. We start with stable kernel + stable snapd -> refresh to new snapd
  2. We start with stable kernel + new snapd

  In both cases we then trigger a reseal operation and reboot to make sure that
  the old snap-bootstrap/initrd in the stable kernel can still unlock the
  encrypted partitions

# ubuntu-22.04-64: enable on uc22 once pc-kernel is on 22/candidate channel
systems: [ubuntu-20.04-64]


environment:
  NESTED_CUSTOM_MODEL: $TESTSLIB/assertions/ubuntu-core-{VERSION}-amd64.model

  # don't bundle the snapd snap via nested.sh's machinery, instead we will
  # side-load our snapd snap built from this branch into the image via
  # extra-snaps since we still want to use MS keys and such for this image, and
  # defining this to be true brings with it i.e. snakeoil keys in the OVMF
  # firmware for example
  NESTED_BUILD_SNAPD_FROM_CURRENT: false

  # we want snaps from the stable channel by default with the exception of the
  # snapd snap which we will conditionally repack as per NESTED_BUILD_SNAPD_FROM_CURRENT
  NESTED_CORE_CHANNEL: stable

  START_SNAPD_VERSION/startwithnew: new
  START_SNAPD_VERSION/startwithold: old

  # all variants need encryption turned on
  NESTED_ENABLE_TPM: true
  NESTED_ENABLE_SECURE_BOOT: true

  INITIAL_KERNEL_REV_URL: https://storage.googleapis.com/snapd-spread-tests/snaps/pc-kernel_838.snap
  INITIAL_GADGET_REV_URL: https://storage.googleapis.com/snapd-spread-tests/snaps/pc_132.snap

prepare: |
  # always build the snapd snap from this branch - on the new variant it gets
  # put into the image, on the old variant it will be refreshed to
  # shellcheck source=tests/lib/prepare.sh
  . "$TESTSLIB"/prepare.sh
  build_snapd_snap .
  mv snapd_*.snap snapd-from-branch.snap

  # on both variants we use a local, non-asserted version of the snapd snap
  # for the startwithnew variant, we use the snapd from this branch, for the
  # startwithold variant, we use the snapd from stable but unpack it to 
  # prevent auto-refreshes from happening which may affect the test setup
  if [ "$START_SNAPD_VERSION" = "new" ]; then
    mv snapd-from-branch.snap "$(tests.nested get extra-snaps-path)"
  else
    # TODO: download a specific version of snapd from a GCE bucket instead
    snap download snapd --stable --basename=snapd-stable-store
    unsquashfs -d snapd snapd-stable-store.snap
    touch ./snapd/in-case-mksquashfs-becomes-deterministic-someday
    sudo snap pack snapd --filename=snapd-stable.snap
    mv snapd-stable.snap "$(tests.nested get extra-snaps-path)"
  fi

  # use a specific version of the kernel snap and thus initramfs that we know
  # doesn't support v2 secboot keys
  wget --quiet "$INITIAL_KERNEL_REV_URL"
  # use a gadget snap that works with this kernel
  wget --quiet "$INITIAL_GADGET_REV_URL"

  # unpack it and repack it so it doesn't match any store assertions and thus
  # won't be automatically refreshed behind our backs when we boot the VM
  unsquashfs -d pc-kernel-snap pc-kernel_838.snap
  touch ./pc-kernel-snap/in-case-mksquashfs-becomes-deterministic-someday
  snap pack pc-kernel-snap --filename=pc-kernel.snap
  mv pc-kernel.snap "$(tests.nested get extra-snaps-path)" 

  unsquashfs -d pc-snap pc_132.snap
  touch ./pc-snap/in-case-mksquashfs-becomes-deterministic-someday
  snap pack pc-snap --filename=pc.snap
  mv pc.snap "$(tests.nested get extra-snaps-path)" 

  # Get the nested system version
  VERSION="$(tests.nested show version)"

  # download the new kernel to try and refresh to, triggering a reseal
  snap download pc-kernel --channel="$VERSION/candidate" --basename=new-kernel

  # build the image and start the VM up
  tests.nested build-image core
  tests.nested create-vm core

execute: |
  # on the old variant, copy and install the new snapd to it
  if [ "$START_SNAPD_VERSION" = "old" ]; then
    remote.push snapd-from-branch.snap
    # This may trigger a reboot if the "managed boot config assets" change
    # (e.g. grub.cfg). Hence this waits unti lthe change is completed even
    # across reboots (retry will ensure that even if ssh cannot connect
    # during the reboot it keeps trying).
    REMOTE_CHG_ID=$(remote.exec "sudo snap install --dangerous snapd-from-branch.snap --no-wait")
    retry --wait 5 -n 24 sh -c "remote.exec \"snap changes\" | MATCH ^${REMOTE_CHG_ID}.*Done"
  fi

  # try a refresh to a new kernel revision which will trigger a reseal and then
  # a reboot
  remote.push new-kernel.snap

  boot_id="$( tests.nested boot-id )"
  REMOTE_CHG_ID=$(remote.exec "sudo snap install --dangerous new-kernel.snap --no-wait")
  remote.wait-for reboot "${boot_id}"
  remote.exec sudo snap watch "${REMOTE_CHG_ID}"

  remote.exec "snap changes" | tail -n +2 | awk '{print $2}' | NOMATCH Error

  # TODO: also check transitioning to the recovery seed system too?
