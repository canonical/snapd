summary: verify that new snapd's do not break old snap-bootstrap/kernel initrds

systems: [ubuntu-20.04-64]

# we have two variants here:
#
# 1. we start with stable kernel + stable snapd -> refresh to new snapd
# 2. we start with stable kernel + new snapd
#
# and then in both cases we then trigger a reseal operation and reboot to make
# sure that the old snap-bootstrap/initrd in the stable kernel can still unlock
# the encrypted partitions

environment:
  NESTED_CUSTOM_MODEL: $TESTSLIB/assertions/ubuntu-core-20-amd64.model

  # don't bundle the snapd snap via nested.sh's machinery, instead we will
  # side-load our snapd snap built from this branch into the image via
  # extra-snaps since we still want to use MS keys and such for this image, and
  # defining this to be true brings with it i.e. snakeoil keys in the OVMF
  # firmware for example
  NESTED_BUILD_SNAPD_FROM_CURRENT: false

  # for all variants keep the kernel, gadget, and base snap without repacking
  # them - though for the kernel note we use a specific rev via extra-snaps in
  # prepare
  NESTED_NO_REPACK_KERNEL_SNAP: true
  NESTED_NO_REPACK_GADGET_SNAP: true
  NESTED_NO_REPACK_BASE_SNAP: true

  # we want snaps from the stable channel by default with the exception of the
  # snapd snap which we will conditionally repack as per NESTED_BUILD_SNAPD_FROM_CURRENT
  NESTED_CORE_CHANNEL: stable

  START_SNAPD_VERSION/startwithnew: new
  START_SNAPD_VERSION/startwithstable: old

  NESTED_IMAGE_ID: uc20-breakages-testing-$START_SNAPD_VERSION

  # all variants need encryption turned on
  NESTED_ENABLE_TPM: true
  NESTED_ENABLE_SECURE_BOOT: true

prepare: |
  # always build the snapd snap from this branch - on the new variant it gets
  # put into the image, on the old variant it will be refreshed to
  snap download --channel="latest/edge" snapd
  "$TESTSTOOLS"/snaps-state repack_snapd_deb_into_snap snapd
  mv snapd-from-deb.snap snapd-from-branch.snap  

  # only install it on the image in the "new" variant
  if [ "$START_SNAPD_VERSION" = "new" ]; then
    mv snapd-from-branch.snap extra-snaps
  fi

  # TODO: use the gce bucket URL for this instead

  # use a specific version of the kernel snap and thus initramfs that we know
  # doesn't support v2 secboot keys
  snap download pc-kernel --channel=20/stable
  # unpack it and repack it so it doesn't match any store assertions and thus
  # won't be automatically refreshed behind our backs when we boot the VM
  unsquashfs -d pc-kernel-snap pc-kernel_*.snap 
  snap pack pc-kernel-snap --filename=pc-kernel.snap
  mv pc-kernel.snap extra-snaps/

  # download the new kernel to try and refresh to, triggering a reseal
  snap download pc-kernel --channel=20/candidate --basename=new-kernel

  # build the image and start the VM up
  tests.nested build-image core
  tests.nested create-vm core

execute: |
  # on the old variant, copy and install the new snapd to it
  if [ "$START_SNAPD_VERSION" = "old" ]; then
    tests.nested copy snapd-from-branch.snap  
    tests.nested exec "sudo snap install --dangerous snapd-from-branch.snap"
  fi

  # try a refresh to a new kernel revision which will trigger a reseal and then
  # a reboot
  snap download pc-kernel --channel=20/candidate --basename=new-kernel
  tests.nested copy new-kernel.snap

  boot_id="$( tests.nested boot-id )"
  REMOTE_CHG_ID=$(tests.nested exec "sudo snap install --dangerous new-kernel.snap --no-wait")
  tests.nested wait-for reboot "${boot_id}"
  tests.nested exec sudo snap watch "${REMOTE_CHG_ID}"

  tests.nested exec "snap changes"
  exit 1

  # TODO: also check transitioning to the recovery seed system too?
