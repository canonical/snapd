summary: Check that EFI boot variables are successfully on UC20+

details: >
    This test checks that EFI boot variables are correctly set during
    installation.  In particular, there should be a Boot#### variable with
    data pointing to either \EFI\ubuntu\shimx64.efi or \EFI\boot\bootx64.efi,
    depending on the version of the pc-gadget snap, and the first number in the
    BootOrder variable should be the corresponding number.

systems: [ubuntu-2*]

environment:
    DESCRIPTION/BOOTDIR: "Install with assets in EFI/boot/, then update to gadget with assets in EFI/ubuntu/"
    DESCRIPTION/UBUNTUDIR: "Install with assets in EFI/ubuntu/, then update to gadget with assets in EFI/boot/"

    INITIAL_ASSET_DIR/BOOTDIR: "boot"
    INITIAL_ASSET_DIR/UBUNTUDIR: "ubuntu"

    FINAL_ASSET_DIR/BOOTDIR: "ubuntu"
    FINAL_ASSET_DIR/UBUNTUDIR: "boot"

prepare: |
    snap install yq

    VERSION=$(tests.nested show version)
    echo "Download pc-gadget to use in initial image"
    snap download --basename=pc --channel="$VERSION/edge" pc
    unsquashfs -d pc-gadget pc.snap

    ARCH=$(find pc-gadget -name 'grub*.efi' -printf '%f\n' | sed 's/grub//;s/\.efi//')

    case "${ARCH}" in
        x64  ) ;;
        aa64 ) ;;
        *    ) ERROR "Invalid architecture '${ARCH}': must be 'x64' or 'aa64'" ;;
    esac

    echo "Set up gadget with EFI assets in EFI/${INITIAL_ASSET_DIR}"
    case "${INITIAL_ASSET_DIR}" in
        boot )
            sh modify-gadget.sh pc-gadget "$ARCH" no-fallback
            ;;
        ubuntu )
            sh modify-gadget.sh pc-gadget "$ARCH" fallback
            ;;
        * )
            ERROR "Invalid initial asset dir: ${INITIAL_ASSET_DIR}"
            ;;
    esac

    echo "Get snakeoil key"
    KEY_NAME=$(tests.nested download snakeoil-key)
    SNAKEOIL_KEY="$PWD/$KEY_NAME.key"
    SNAKEOIL_CERT="$PWD/$KEY_NAME.pem"

    echo "Sign assets in the modified pc-gadget"
    tests.nested secboot-sign gadget pc-gadget "${SNAKEOIL_KEY}" "${SNAKEOIL_CERT}"

    echo "Repack the modified pc-gadget"
    snap pack pc-gadget/ "$(tests.nested get extra-snaps-path)"
    # No need to re-sign again after repacking
    echo "Build core image around modified pc-gadget"
    tests.nested build-image core
    echo "Create VM around custom image"
    tests.nested create-vm core

debug: |
    VERSION=$(tests.nested show version)
    echo "Current state of the remote EFI variables:"
    remote.exec "sudo snap install --channel=${VERSION}/edge toolbox"
    # The usual toolbox setup assumes bash, so just set PATH and LD_LIBRARY_PATH
    # manually when executing efibootmgr.
    augmented_path="/snap/toolbox/current/bin:/snap/toolbox/current/sbin:/snap/toolbox/current/usr/bin:/snap/toolbox/current/usr/sbin:${PATH}" # Host path is fine as base
    augmented_ld_path="/lib:/usr/lib:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/snap/toolbox/current/lib:/snap/toolbox/current/usr/lib:/snap/toolbox/current/lib/x86_64-linux-gnu:/snap/toolbox/current/usr/lib/x86_64-linux-gnu"
    remote.exec "PATH=${augmented_path} LD_LIBRARY_PATH=${augmented_ld_path} sh -c 'efibootmgr -v'"

    echo "Current state of the gadget.yaml"
    if [ -f pc-gadget/meta/gadget.yaml ]; then
        cat pc-gadget/meta/gadget.yaml
    fi

execute: |
    VERSION=$(tests.nested show version)
    ARCH="$(find pc-gadget -name 'grub*.efi' -printf '%f\n' | sed 's/grub//;s/\.efi//')"
    ARCH_UPPER="$(echo "$ARCH" | tr '[:lower:]' '[:upper:]')"

    case "${ARCH}" in
        x64  ) ;;
        aa64 ) ;;
        *    ) ERROR "Invalid architecture '${ARCH}': must be 'x64' or 'aa64'" ;;
    esac

    echo "${DESCRIPTION}"

    echo "#### Initial gadget: ####"

    echo "Wait for device to be initialized"
    remote.wait-for device-initialized

    echo "Wait for the system to be seeded"
    remote.exec "sudo snap wait system seed.loaded"

    echo "Install and set up toolbox on nested VM"
    remote.exec "sudo snap install --channel=${VERSION}/edge toolbox"
    # The usual toolbox setup assumes bash, so just set PATH and LD_LIBRARY_PATH
    # manually when executing efibootmgr.
    remote_exec_efibootmgr() {
        augmented_path="/snap/toolbox/current/bin:/snap/toolbox/current/sbin:/snap/toolbox/current/usr/bin:/snap/toolbox/current/usr/sbin:${PATH}" # Host path is fine as base
        augmented_ld_path="/lib:/usr/lib:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/snap/toolbox/current/lib:/snap/toolbox/current/usr/lib:/snap/toolbox/current/lib/x86_64-linux-gnu:/snap/toolbox/current/usr/lib/x86_64-linux-gnu"
        remote.exec "PATH=${augmented_path} LD_LIBRARY_PATH=${augmented_ld_path} sh -c 'efibootmgr -v'"
    }

    # Check that the EFI assets are correctly situated
    check_efi_assets() {
        if [ "$1" = "boot" ]; then
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/boot/boot${ARCH}.efi"
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/boot/grub${ARCH}.efi"
        elif [ "$1" = "ubuntu" ]; then
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/ubuntu/BOOT${ARCH_UPPER}.CSV"
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/ubuntu/grub${ARCH}.efi"
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/ubuntu/shim${ARCH}.efi"
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/boot/boot${ARCH}.efi"
            remote.exec "ls /run/mnt/ubuntu-seed/EFI/boot/fb${ARCH}.efi"
        fi
    }

    # Print the number of the first boot option in BootOrder.
    get_bootorder_first_number() {
        remote_exec_efibootmgr | MATCH "^BootOrder: "
        remote_exec_efibootmgr | grep  "^BootOrder: " | cut -d ' ' -f 2 | cut -d ',' -f 1
    }
    # Check that a boot option variable exists for the given shim path, and
    # that it is the first option in the BootOrder variable.
    check_efi_variables() {
        shim_path="$(echo "$1" | sed 's/\//\\\\/g')"
        boot_var_pattern="^Boot[0-9A-F][0-9A-F][0-9A-F][0-9A-F]. ubuntu.*/File.${shim_path}.$"
        echo "Check that there exists one EFI boot variable for ${shim_path}"
        remote_exec_efibootmgr | MATCH "${boot_var_pattern}"
        remote_exec_efibootmgr | grep -c "${boot_var_pattern}" | MATCH "^1$"
        echo "Get boot number associated with that boot variable"
        boot_num=$(remote_exec_efibootmgr | grep "${boot_var_pattern}" | grep -o '^Boot....' | sed 's/Boot//')
        echo "Check that first boot option in BootOrder matches ${boot_num}"
        get_bootorder_first_number | MATCH "^${boot_num}$"
    }

    echo "Check that EFI assets in EFI/${INITIAL_ASSET_DIR} and variables are set correctly"
    check_efi_assets "$INITIAL_ASSET_DIR"
    if [ "${INITIAL_ASSET_DIR}" = "boot" ]; then
        check_efi_variables "/EFI/boot/boot${ARCH}.efi"
    elif [ "${INITIAL_ASSET_DIR}" = "ubuntu" ]; then
        check_efi_variables "/EFI/ubuntu/shim${ARCH}.efi"
    fi

    echo "All good!"

    echo "Set up gadget with EFI assets in EFI/${FINAL_ASSET_DIR}"
    case "${FINAL_ASSET_DIR}" in
        boot )
            sh modify-gadget.sh pc-gadget "$ARCH" no-fallback
            ;;
        ubuntu )
            sh modify-gadget.sh pc-gadget "$ARCH" fallback
            ;;
        * )
            ERROR "Invalid initial asset dir: ${FINAL_ASSET_DIR}"
            ;;
    esac

    echo "Get snakeoil key"
    KEY_NAME=$(tests.nested download snakeoil-key)
    SNAKEOIL_KEY="$PWD/$KEY_NAME.key"
    SNAKEOIL_CERT="$PWD/$KEY_NAME.pem"

    echo "Sign the modified pc-gadget"
    tests.nested secboot-sign gadget pc-gadget "${SNAKEOIL_KEY}" "${SNAKEOIL_CERT}"

    snap pack --filename=pc.snap pc-gadget
    remote.push pc.snap

    boot_id=$(tests.nested boot-id)

    echo "Install new gadget"
    #FIXME: the gadget does not yet remove the fallback binary which will reintroduce the old
    if [ "${FINAL_ASSET_DIR}" = "boot" ]; then
      remote.exec sudo systemd-inhibit --what=shutdown bash -c "'snap install --dangerous pc.snap; rm -f /boot/efi/EFI/ubuntu/grub${ARCH}.efi /boot/efi/EFI/boot/fbx64.efi /boot/efi/EFI/ubuntu/shim${ARCH}.efi'"
    else
      remote.exec sudo snap install --dangerous pc.snap
    fi
    # VM should reboot now
    echo "Wait for reboot"
    remote.wait-for reboot "${boot_id}"
    # Wait for previous change to finish before continuing
    remote.exec sudo snap watch --last=install

    echo "#### Updated gadget: ####"

    echo "Check that EFI assets in EFI/${INITIAL_ASSET_DIR} and variables are set correctly"
    check_efi_assets "$FINAL_ASSET_DIR"
    if [ "${FINAL_ASSET_DIR}" = "boot" ]; then
        check_efi_variables "/EFI/boot/boot${ARCH}.efi"
    elif [ "${FINAL_ASSET_DIR}" = "ubuntu" ]; then
        check_efi_variables "/EFI/ubuntu/shim${ARCH}.efi"
    fi

    echo "All good!"
