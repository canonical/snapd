summary: End-to-end test for FDE passphrase support on hybrid systems

details: |
  This test installs an encrypted hybrid Ubuntu system using muinstaller
  which is protected by passphrase authentication.

systems: [ubuntu-24.04-64]

# TODO: Remove this when passphrase support lands.
manual: true

environment:
  NESTED_ENABLE_TPM: true
  NESTED_ENABLE_SECURE_BOOT: true

  # TODO: Swap 24.10 with 25.04 when the kernel/gadget snaps are available in the store.
  # Mimic default channels specified in https://github.com/canonical/models/blob/master/ubuntu-classic-2504-amd64-dangerous.json.
  GADGET_CHANNEL: classic-24.10/edge
  KERNEL_CHANNEL: 24.10/edge
  CORE_VERSION: 22

  PASSPHRASE: ubuntu
  # "pbkdf2" is less memory intensive than argon2i* so we use it by default.
  # TODO: Add argon2i* variants.
  KDF_TYPE: pbkdf2

  # Ensure we use our latest code.
  NESTED_BUILD_SNAPD_FROM_CURRENT: true
  NESTED_REPACK_KERNEL_SNAP: true
  NESTED_ENABLE_OVMF: true
  # Store related setup.
  STORE_ADDR: localhost:11028
  STORE_DIR: $(pwd)/fake-store-blobdir

prepare: |
  if [ "$TRUST_TEST_KEYS" = "false" ]; then
      echo "This test needs test keys to be trusted"
      exit
  fi
  apt install dosfstools kpartx
  snap install jq
  snap install yq

  # Fakestore is needed for "snap prepare-image".
  "$TESTSTOOLS"/store-state setup-fake-store "$STORE_DIR"

restore: |
  "$TESTSTOOLS"/store-state teardown-fake-store "$STORE_DIR"
  rm -rf ./classic-root

execute: |
  # shellcheck source=tests/lib/prepare.sh
  . "$TESTSLIB/prepare.sh"
  #shellcheck source=tests/lib/nested.sh
  . "$TESTSLIB"/nested.sh

  # Expose the needed assertions through the fakestore.
  cp "$TESTSLIB"/assertions/developer1.account "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/developer1.account-key "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/testrootorg-store.account-key "$STORE_DIR/asserts"
  export SNAPPY_FORCE_SAS_URL=http://$STORE_ADDR

  # Retrieve the gadget.
  snap download --basename=pc --channel="$GADGET_CHANNEL" pc

  # Modify gadget and resign with snakeoil keys.
  unsquashfs -d pc-gadget pc.snap
  echo 'console=ttyS0 systemd.journald.forward_to_console=1' > pc-gadget/cmdline.extra
  echo "Sign the shim binary"
  KEY_NAME=$(tests.nested download snakeoil-key)
  SNAKEOIL_KEY="$PWD/$KEY_NAME.key"
  SNAKEOIL_CERT="$PWD/$KEY_NAME.pem"
  tests.nested secboot-sign gadget pc-gadget "$SNAKEOIL_KEY" "$SNAKEOIL_CERT"
  snap pack --filename=pc.snap pc-gadget/

  # Retrieve kernel.
  snap download --basename=pc-kernel --channel="$KERNEL_CHANNEL" pc-kernel
  # Build kernel with initramfs with the compiled snap-bootstrap
  uc24_build_initramfs_kernel_snap "$PWD/pc-kernel.snap" "$NESTED_ASSETS_DIR"
  mv "${NESTED_ASSETS_DIR}"/pc-kernel_*.snap pc-kernel.snap

  # Create new disk for the installer to work on and attach to VM.
  truncate --size=6G disk.img

  # setup_nested_hybrid_system.sh runs the muinstaller to install a hybrid
  # system.
  gendeveloper1 sign-model < "$TESTSLIB"/assertions/developer1-2410-classic-dangerous.json > classic.model
  "${TESTSTOOLS}"/setup_nested_hybrid_system.sh \
     --model classic.model \
     --store-dir "${STORE_DIR}" \
     --gadget pc.snap \
     --gadget-assertion pc.assert \
     --kernel pc-kernel.snap \
     --kernel-assertion pc-kernel.assert \
     --passphrase "$PASSPHRASE" \
     --extra-muinstaller-args "-kdf-type $KDF_TYPE" \
     --disk disk.img

  # Basic things look fine.
  remote.exec "cat /etc/os-release" | MATCH 'NAME="Ubuntu"'
  remote.exec "snap changes" | MATCH "Done.* Initialize system state"
  remote.exec "snap list" | MATCH pc-kernel

  # Check encryption.
  remote.exec "sudo test -d /var/lib/snapd/device/fde"
  remote.exec "sudo test -e /var/lib/snapd/device/fde/marker"
  remote.exec "sudo test -e /var/lib/snapd/device/fde/marker"
  remote.exec "sudo blkid /dev/disk/by-label/ubuntu-data-enc" | MATCH crypto_LUKS

  # Check disk mappings.
  remote.exec "sudo snap install jq"
  # TODO: no ubuntu-save right now because:
  #       "ERROR cannot store device key pair: internal error: cannot access device keypair manager if ubuntu-save is unavailable"
  #DISK_MAPPINGS=(/run/mnt/ubuntu-save/device/disk-mapping.json
  #               /run/mnt/data/var/lib/snapd/device/disk-mapping.json)
  DISK_MAPPINGS=(/run/mnt/data/var/lib/snapd/device/disk-mapping.json)
  for DM in "${DISK_MAPPINGS[@]}"; do
      remote.exec "sudo cat $DM | jq '.pc.\"structure-encryption\".\"ubuntu-save\".method'" | MATCH '"LUKS"'
      remote.exec "sudo cat $DM | jq '.pc.\"structure-encryption\".\"ubuntu-data\".method'" | MATCH '"LUKS"'
  done

  # Check that on an already provisioned system the API will give a
  # sensible reason why the system cannot be installed without further
  # action.
  remote.exec "sudo snap debug api /v2/systems/classic" > system
  jq '.result."storage-encryption".support' < system | MATCH "unavailable"
  jq '.result."storage-encryption"."unavailable-reason"' < system | MATCH "not encrypting device storage as checking TPM gave: the TPM is in DA lockout mode"

  # refresh rebooting snap
  # $1: path to snap file
  # $2: snap name
  # $3: reboot action ("reboot"/"no-reboot")
  refresh_rebooting_snap()
  {
      local snap_filename=$1
      local snap_name=$2
      local reboot_action=$3

      boot_id=$(tests.nested boot-id)

      printf "Test installing snap from file %s\n" "$snap_filename"
      remote.push "$snap_filename"
      # install will exit when waiting for the reboot
      remote.exec sudo snap install --dangerous "$snap_filename" | MATCH "Task set to wait until a system restart allows to continue"

      # Check that a reboot notification was setup.
      remote.exec test -f /run/reboot-required
      remote.exec cat /run/reboot-required.pkgs | MATCH "snap:${snap_name}"
      # Check that no reboot has been scheduled, then force a reboot
      remote.exec not test -f /run/systemd/shutdown/scheduled

      if [ "$reboot_action" = "reboot" ]; then
          local log_file="$NESTED_LOGS_DIR"/serial.log
          # Clear old log file to avoid matching passphrase prompt from previous boot.
          echo "" > "$log_file"
          remote.exec sudo reboot || true
          remote.wait-for reboot --wait 1 -n 200 --expect-passphrase "ubuntu" --log-file "$log_file" "$boot_id"
          remote.exec sudo snap watch --last=install
      fi
  }
  # Ensure update-notifier-common is installed so that reboot notification works.
  remote.exec "sudo apt install -y update-notifier-common"

  # Initial reseal count.
  remote.exec sudo cat /var/lib/snapd/device/fde/boot-chains > boot-chains-before.json
  reseal_count_start="$(jq -r '.["reseal-count"]' < boot-chains-before.json )"

  fetch_and_check_reseal_count_equal() {
      local reseal_count_now
      remote.exec sudo cat /var/lib/snapd/device/fde/boot-chains > boot-chains.json
      reseal_count_now="$(jq -r '.["reseal-count"]' < boot-chains.json )"
      test "$reseal_count_now" = "$1"
  }

  # 1. Test gadget refresh causing reseal.

  # Changing cmdline should force a reseal.
  echo 'console=ttyS0 systemd.journald.forward_to_console=1 loglevel=4' > pc-gadget/cmdline.extra
  tests.nested secboot-sign gadget pc-gadget "$SNAKEOIL_KEY" "$SNAKEOIL_CERT"
  snap pack --filename=pc-new.snap pc-gadget/
  refresh_rebooting_snap pc-new.snap pc reboot

  # We expect two reseals, one before the update and one after.
  fetch_and_check_reseal_count_equal "$((reseal_count_start + 2))"

  # 2. Test kernel refresh causing reseal.

  # Resigning kernel should be enough to trigger a reseal.
  uc24_build_initramfs_kernel_snap "$PWD/pc-kernel.snap" "$PWD/pc-kernel-new.snap"
  refresh_rebooting_snap pc-kernel-new.snap pc reboot

  # We expect two reseals, one before the update and one after.
  fetch_and_check_reseal_count_equal "$((reseal_count_start + 4))"

  # TODO: 3. Try refreshing to an unsupported kernel when snapd-info files
  # are available.

  # TODO: 4. Remodelling?
