summary: Ensure that service and apparmor profiles work after a reboot

details: |
    The test checks that after a system reboot during a fundamental snap refresh can
    be handled and the change steps can be undone properly.

systems: [ubuntu-2*]

environment: 
    TAG/base_update_link_snap: link-snap
    TAG/snapd_update_link_snap: link-snap
    TAG/kernel_update_link_snap: link-snap
    TAG/gadget_update_link_snap: link-snap
    TAG/base_refresh_auto_connect: after-auto-connect
    TAG/kernel_auto_connect: after-auto-connect
    TAG/base_auto_connect: after-auto-connect
    TAG/gadget_auto_connect: after-auto-connect
    TAG/snapd_auto_connect: after-auto-connect

    # still not checked
    TAG/gadget_update_config_bootloader: update-config-bootloader
    TAG/gadget_update_command_line_gadget: update-command-line-gadget
    TAG/kernel_prepare_kernel_components: prepare-kernel-components
    TAG/gadget_refresh_gadget_assets: refresh-gadget-assets
    TAG/snapd_refresh_gadget_assets: refresh-gadget-assets
    TAG/kernel_refresh_gadget_assets: refresh-gadget-assets
    


    # These should go in a remodel test
    #TAG/gadget_remodel_boot_assets: remodel-boot-assets
    #TAG/kernel_remodel_boot_assets: remodel-boot-assets

    FAULT: panic

prepare: |
    # automatically cleaned up in restore
    echo "Inject a $FAULT on $TAG"
    cat <<EOF > fault-inject.conf
    [Service]
    Environment=SNAPPY_TESTING=1
    Environment=SNAPD_FAULT_INJECT=$TAG:$FAULT
    EOF

    echo "Wait for the system to be seeded first"
    remote.exec "sudo snap wait system seed.loaded"

    remote.push fault-inject.conf
    remote.exec "sudo mkdir -p /etc/systemd/system/snapd.service.d"
    remote.exec "sudo cp -v fault-inject.conf /etc/systemd/system/snapd.service.d/"
    remote.exec "sudo systemctl daemon-reload"
    remote.exec "sudo systemctl restart snapd.service"

execute: |
    VERSION="$(tests.nested show version)"
    SNAP=
    CHANNEL=edge
    REBOOT=false

    if [ "$FAULT" = reboot ]; then
        REBOOT=true
    fi

    case "$SPREAD_VARIANT" in
        base_*)
            SNAP="core${VERSION}"
            REBOOT=true
            ;;    
        gadget_*)
            SNAP=pc
            CHANNEL="$VERSION/$CHANNEL"
            ;;
        kernel_*)
            SNAP=pc-kernel
            CHANNEL="$VERSION/beta"
            REBOOT=true
            ;;
        snapd_*)
            SNAP=snapd
            ;;
        *)
            echo "scenario no supported: $SPREAD_VARIANT"
            exit 1
            ;;
    esac
        
    # Refresh and reboot before the process is completed
    boot_id="$(tests.nested boot-id)"
    change_id="$(remote.exec "sudo snap refresh --amend --channel $CHANNEL --no-wait $SNAP")"

    if [ "$REBOOT" = true ]; then
        remote.wait-for reboot "$boot_id"
    fi

    if [ "$FAULT" = panic ]; then
        echo "And snap install completes"
        remote.exec "snap watch $change_id"

        echo "Ensure the panic was injected and triggered stamp file is present"
        remote.exec sudo journalctl -u snapd | grep panic > output
        MATCH "$TAG":panic < output
        MATCH "osutil.injectFault" < output
    fi

    retry --wait 1 -n 30 --env "CHANGE_ID=$change_id" --env "SNAP=$SNAP" sh -c 'remote.exec snap changes | MATCH "${CHANGE_ID} .* Done .*"'
