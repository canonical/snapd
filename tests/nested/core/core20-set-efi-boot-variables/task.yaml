summary: Tests for the code that sets EFI boot variables, as if it were a library separate from snapd

details: >
    This test uses snapd as a library to set UEFI boot entries. This
    is useful for installers.

systems: [ubuntu-2*]

prepare: |
    "$(command -v go)" build -o setefivars setefivars.go

    VERSION=$(tests.nested show version)

    echo "Wait for the system to be seeded"
    remote.exec "sudo snap wait system seed.loaded"

    echo "Wait for device initialization to be done"
    remote.exec "retry --wait 5 -n 10 sh -c 'snap changes | MATCH \"Done.*Initialize device\"'"

    echo "Install toolbox (to get efibootmgr)"
    remote.exec "sudo snap install --channel=$VERSION toolbox" || true

debug: |
    # The usual toolbox setup assumes bash, so just set PATH and LD_LIBRARY_PATH
    # manually when executing efibootmgr.
    remote_exec_efibootmgr() {
        augmented_path="/snap/toolbox/current/bin:/snap/toolbox/current/sbin:/snap/toolbox/current/usr/bin:/snap/toolbox/current/usr/sbin:${PATH}" # Host path is fine as base
        augmented_ld_path="/lib:/usr/lib:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/snap/toolbox/current/lib:/snap/toolbox/current/usr/lib:/snap/toolbox/current/lib/x86_64-linux-gnu:/snap/toolbox/current/usr/lib/x86_64-linux-gnu"
        remote.exec "PATH=${augmented_path} LD_LIBRARY_PATH=${augmented_ld_path} sh -c 'efibootmgr -v'"
    }
    if [ -f orig_vars.txt ]; then
        echo "Original EFI boot variables:"
        cat orig_vars.txt
        echo "Current EFI boot variables:"
        remote_exec_efibootmgr
    else
        echo "Original EFI variables were never recorded"
    fi

execute: |
    # The usual toolbox setup assumes bash, so just set PATH and LD_LIBRARY_PATH
    # manually when executing efibootmgr.
    remote_exec_efibootmgr() {
        augmented_path="/snap/toolbox/current/bin:/snap/toolbox/current/sbin:/snap/toolbox/current/usr/bin:/snap/toolbox/current/usr/sbin:${PATH}" # Host path is fine as base
        augmented_ld_path="/lib:/usr/lib:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/snap/toolbox/current/lib:/snap/toolbox/current/usr/lib:/snap/toolbox/current/lib/x86_64-linux-gnu:/snap/toolbox/current/usr/lib/x86_64-linux-gnu"
        remote.exec "PATH=${augmented_path} LD_LIBRARY_PATH=${augmented_ld_path} sh -c 'efibootmgr -v'"
    }

    echo "Store original variables"
    remote_exec_efibootmgr > orig_vars.txt
    echo "Store original boot order"
    remote_exec_efibootmgr | grep BootOrder | cut -d ' ' -f 2 > orig_bootorder.txt

    echo "Push locally-built setefivars binary"
    remote.push setefivars

    echo "Execute setefivars binary"
    remote.exec "sudo ./setefivars"

    echo "Check that new boot order differs from original"
    new_bootorder="$(remote_exec_efibootmgr | grep 'BootOrder' | cut -d ' ' -f 2)"
    new_first="$(echo "$new_bootorder" | cut -d ',' -f 1)"
    orig_bootorder="$(cat orig_bootorder.txt)"

    remote_exec_efibootmgr -v | grep 'spread-test-var' | MATCH "^Boot${new_first}"

    if [ "$new_bootorder" != "${new_first},${orig_bootorder}" ]; then
        ERROR "New BootOrder variable is not set correctly"
    fi

    echo "Check that running the code again results does not modify boot vars again"
    remote_exec_efibootmgr -v > new_vars.txt
    remote.exec "sudo ./setefivars"
    remote_exec_efibootmgr -v > newest_vars.txt
    diff new_vars.txt newest_vars.txt

