#!/usr/bin/env python3

import argparse
import os
import re
import sys


class LockTrace:
    def __init__(self, lines: list[str]):
        self.lines = lines

    def get_trace_lines(self) -> list[str]:
        return self.lines
    
    def match(self, part: str) -> bool:
        for line in self.lines:
            if part in line:
                return True
        
        return False
    
    def __str__(self) -> str:
        return "".join(self.lines)

    def __hash__(self):
      return hash(str(self))

    def __eq__(self, other) -> bool: 
        if not isinstance(other, LockTrace):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return hash(str(self)) == hash(str(other))

class Lock:
    def __init__(self, lines: list[str]):
        self.trace = LockTrace(lines[1:])
        self.header = lines[0]
        self.held_time = 0
        self.wait_time = 0
        self._calc_held_ms(self.header)
        self._calc_wait_ms(self.header)

    def _calc_held_ms(self, line: str) -> int:
        match = re.search('.*held: (.+?) ms.*', line)
        if match:
            self.held_time = int(match.group(1))

    def _calc_wait_ms(self, line: str) -> int:
        match = re.search('.*wait (.+?) ms.*', line)
        if match:
            self.wait_time = int(match.group(1))

    def get_held_time(self) -> int:
        return self.held_time

    def get_wait_time(self) -> int:
        return self.wait_time

    def get_trace(self) -> LockTrace:
        return self.trace

    def str(self) -> str:
        all_lines = list[str](self.header)
        all_lines.extend(self.trace.get_trace_lines())
        return "".join(all_lines)



class LocksGroup:

    LOCK_PREFIX = "### "

    def __init__(self, lines: list[str]):
        self.lines = lines
        self.header = self.lines[0]
        self.locks = list[Lock]()

        self._read()

    def _read(self):
        current_line = 1
        while True:
            if current_line >= len(self.lines):
                return

            lock_lines = self._current_lock(current_line)
            if len(lock_lines) == 0:
                print("Error parsing lock")
                sys.exit(1)

            self.locks.append(Lock(lock_lines))
            current_line = current_line + len(lock_lines)

    def _is_lock(self, line: str) -> bool:
        return line.startswith(self.LOCK_PREFIX)

    # This function works to detect the current test but also for the current project
    def _current_lock(self, start_line: int) -> list[str]:
        curr_lock = []
        curr_lock.append(self.lines[start_line])

        current_line = start_line + 1
        while True:
            if current_line >= len(self.lines) or self._is_lock(self.lines[current_line]): 
                return curr_lock
            
            curr_lock.append(self.lines[current_line])
            current_line = current_line + 1

    def get_name(self) -> str:
        return self.header

    def filter(self, held_time: int, wait_time: int):
        filtered_locks = []

        for lock in self.locks:
            filter_ok = True
            if held_time and held_time > lock.get_held_time():
                filter_ok = False
            if wait_time and wait_time > lock.get_wait_time():
                filter_ok = False

            if filter_ok:
                filtered_locks.append(lock)

        self.locks = filtered_locks

    def match(self, match_names: list[str]):
        filtered_locks = []

        for lock in self.locks:
            match = False
            for match_name in match_names:
                if lock.get_trace().match(match_name):
                    match = True
                    break

            if match:
                filtered_locks.append(lock)

        self.locks = filtered_locks

    def skip(self, skip_names: list[str]):
        filtered_locks = []

        for lock in self.locks:
            match_skip = False
            for skip_name in skip_names:
                if skip_name in lock.get_trace():
                    match_skip = True
                    break

            if not match_skip:
                filtered_locks.append(lock)

        self.locks = filtered_locks

    def get_locks(self) -> list[Lock]:
        return self.locks

    def get_max_held(self) -> int:
        max_held = 0
        for lock in self.locks:
            if lock.get_held_time() > max_held:
                max_held = lock.get_held_time()
                
        return max_held

    def get_max_wait(self) -> int:
        max_wait = 0
        for lock in self.locks:
            if lock.get_wait_time() > max_wait:
                max_wait = lock.get_wait_time()
                
        return max_wait

    def get_traces(self) -> list[LockTrace]:
        traces = []
        for lock in self.locks:
            traces.append(lock.get_trace())
        return traces
    
    def get_lock_held_time(self, trace) -> int:
        for lock in self.locks:
            if lock.get_trace() == trace:
                return lock.get_held_time()
            
        return 0
    
    def get_lock_wait_time(self, trace) -> int:
        for lock in self.locks:
            if lock.get_trace() == trace:
                return lock.get_wait_time()
            
        return 0

    def show(self):        
        print(self.header)
        for lock in self.locks:
            print(lock.str())

class LocksFilter:

    def __init__(self, groups: list[LocksGroup]):
        self.groups = groups

    def filter(self, held_time: int, wait_time: int):
        filtered_groups = []
        for group in self.groups:
            group.filter(held_time, wait_time)
            if len(group.get_locks()) > 0:
                filtered_groups.append(group)

        self.groups = filtered_groups

    def match(self, match_names: list[str]):
        filtered_groups = []
        for group in self.groups:
            group.match(match_names)
            if len(group.get_locks()) > 0:
                filtered_groups.append(group)

        self.groups = filtered_groups

    def skip(self, skip_names: list[str]):
        filtered_groups = []
        for group in self.groups:
            group.skip(skip_names)
            if len(group.get_locks()) > 0:
                filtered_groups.append(group)
        
        self.groups = filtered_groups

    def get_groups(self) -> list[LocksGroup]:
        return self.groups


class GroupTimes:
    def __init__(self, group_name: str, held_time: int, wait_time: int):
        self.group_name = group_name
        self.held_time = held_time
        self.wait_time = wait_time

    def get_group_name(self) -> str: 
        return self.group_name

    def get_held_time(self) -> int: 
        return self.held_time

    def get_wait_time(self) -> int: 
        return self.wait_time

class LocksPrinter:
    def __init__(self, groups: list[LocksGroup]):
        self.groups = groups

    def _get_traces_times(self) -> dict[LockTrace, list[GroupTimes]]:
        traces = dict[LockTrace, list[GroupTimes]]()
        for group in self.groups:
            group_traces = group.get_traces()
            for trace in group_traces:
                group_time = GroupTimes(group.get_name(), 
                                        group.get_lock_held_time(trace),
                                        group.get_lock_wait_time(trace))
                if not self._is_trace_in_list(trace, traces.keys()):
                    traces[trace] = list[GroupTimes]()
                traces.get(trace).append(group_time)

        return traces

    def _is_trace_in_list(self, trace: LockTrace, traces: list[LockTrace]) -> bool:
        for t in traces:
            if t == trace:
                return True
            
        return False

    def print(self, group_results, sort_held_time, sort_wait_time):
        if not group_results:
            if sort_held_time:
                groups = sorted(self.groups, key=lambda x: x.get_max_held(), reverse=True)
            elif sort_wait_time:
                groups = sorted(self.groups, key=lambda x: x.get_max_wait(), reverse=True)

            for group in groups:
                group.show()
        else:
            traces_times = self._get_traces_times()

            if sort_held_time:
                for trace, times in traces_times.items():
                    traces_times[trace] = sorted(times, key=lambda x: x.get_held_time(), reverse=True)
            if sort_wait_time:
                for trace, times in traces_times.items():
                    traces_times[trace] = sorted(times, key=lambda x: x.get_held_time(), reverse=True)

            for trace, times in traces_times.items():                
                print("-"*20+"TRACE"+"-"*20)
                print(trace)
                print("")
                for time in times:
                    print("{} held: {} ms, wait: {} ms".format(time.get_group_name(), time.get_held_time(), time.get_wait_time()))
                print("")                

class LocksFileReader:

    PROJECT_PREFIX = "###START: SNAPD PROJECT"
    TEST_PREFIX = "###START:"

    def __init__(self, locks_file: str):
        self.locks_file = locks_file
        self.lines = list[str]()
        self.groups = list[LocksGroup]()

        self._read()

    def _read(self):
        with open(self.locks_file, "r") as f:
            self.lines = f.readlines()

        current_line = 0
        if not self._is_project(self.lines[current_line]):
            print("First time expected to be the project start.")
            sys.exit(1)

        # Read the tests
        while True:
            if current_line >= len(self.lines):
                return

            group_lines = self._current_group(current_line)
            if len(group_lines) == 0:
                print("Error parsing test.")
                sys.exit(1)

            self.groups.append(LocksGroup(group_lines))
            current_line = current_line + len(group_lines)

    # Indicates if the line is a test
    def _is_test(self, line: str) -> bool:
        return not self._is_project(line) and line.startswith(self.TEST_PREFIX)

    def _is_project(self, line: str) -> bool:
        return line.startswith(self.PROJECT_PREFIX)
    
    # This function works to detect the current test but also for the current project
    def _current_group(self, start_line: int) -> list[str]:
        curr_test = []
        curr_test.append(self.lines[start_line])

        current_line = start_line + 1
        while True:
            if current_line >= len(self.lines) or self._is_test(self.lines[current_line]): 
                return curr_test
            
            curr_test.append(self.lines[current_line])
            current_line = current_line + 1

    def get_groups(self) -> list[LocksGroup]:
        return self.groups         


def _make_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="spread filter helper")
    parser.add_argument("-f", "--locks-file", type=str, required=True, help="Locks file")
    parser.add_argument("-ht", "--held-time", type=int, default=0, help="Include locks with longer held time")
    parser.add_argument("-wt", "--wait-time", type=int, default=0, help="Include locks with longer wait time")
    parser.add_argument("-m", "--match", action="append", default=[], help="Include functions to match")
    parser.add_argument("-s", "--skip", action="append", default=[], help="Include functions to skip")
    parser.add_argument("--sort-held-time", action='store_true', help="Sort higher held times first")
    parser.add_argument("--sort-wait-time", action='store_true', help="Sort higher wait times first")
    parser.add_argument("-g", "--group-results", action='store_true', help="Group results with the same traces")
    
    return parser


if __name__ == "__main__":
    parser = _make_parser()
    args = parser.parse_args()

    if not os.path.isfile(args.locks_file):
        print("state-lock-filter: locks file '{}' does not exist".format(args.locks_file))
        sys.exit(1)

    if args.sort_held_time and args.sort_wait_time:
        print("state-lock-filter: define just 1 sorting (by held or wait times)")
        sys.exit(1)

    locks_reader = LocksFileReader(args.locks_file)
    locks_filter = LocksFilter(locks_reader.get_groups())

    # First filter by time
    if args.held_time > 0 or args.wait_time > 0:
        locks_filter.filter(args.held_time, args.wait_time)

    # Then keep traces with matches
    if args.match:
        locks_filter.match(args.match)

    # Then skip traces with matches
    if args.skip:
        locks_filter.skip(args.skip)

    # Once the locks have been filtered, it is time to print them
    locks_printer = LocksPrinter(locks_filter.get_groups())

    # And finally print the results
    locks_printer.print(args.group_results, args.sort_held_time, args.sort_wait_time)   