#!/usr/bin/env python3

import argparse
import os
import re
import sys

"""
LockTrace: Represents a trace in the log file.
It holds the lines for the trace and allows matching against a part of the trace.
"""


class LockTrace:
    def __init__(self, lines: list[str]):
        self.lines = lines

    def get_trace_lines(self) -> list[str]:
        return self.lines

    def match(self, part: str) -> bool:
        for line in self.lines:
            if part in line:
                return True

        return False

    def __str__(self) -> str:
        return "".join(self.lines)

    def __hash__(self):
        return hash(str(self))

    def __eq__(self, other) -> bool:
        if not isinstance(other, LockTrace):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return hash(str(self)) == hash(str(other))


"""
Lock: Represents a lock in the log file, including its header and times (held and wait times).
It is tied to the LockTrace class.
"""


class Lock:
    def __init__(self, lines: list[str]):
        self.trace = LockTrace(lines[1:])
        self.header = lines[0]
        self.held_time = 0
        self.wait_time = 0
        self._calc_held_ms(self.header)
        self._calc_wait_ms(self.header)

    def _calc_held_ms(self, line: str) -> int:
        match = re.search(".*held: (.+?) ms.*", line)
        if match:
            self.held_time = int(match.group(1))

    def _calc_wait_ms(self, line: str) -> int:
        match = re.search(".*wait (.+?) ms.*", line)
        if match:
            self.wait_time = int(match.group(1))

    def get_held_time(self) -> int:
        return self.held_time

    def get_wait_time(self) -> int:
        return self.wait_time

    def get_trace(self) -> LockTrace:
        return self.trace


"""
LocksGroup: Represents a group of locks, which could correspond to a test case or a project setup.
It holds a header (name) and a list of Lock objects.
"""


class LocksGroup:

    LOCK_PREFIX = "### "

    def __init__(self, lines: list[str]):
        self.lines = lines
        self.header = self.lines[0]
        self.locks = list[Lock]()

        self._read()

    def _read(self):
        current_line = 1
        while True:
            if current_line >= len(self.lines):
                return

            lock_lines = self._current_lock(current_line)
            if len(lock_lines) == 0:
                print("Error parsing lock")
                sys.exit(1)

            self.locks.append(Lock(lock_lines))
            current_line = current_line + len(lock_lines)

    def __str__(self) -> str:
        return "".join(self.lines)

    def _is_lock(self, line: str) -> bool:
        return line.startswith(self.LOCK_PREFIX)

    # This function works to detect the current test but also for the current project
    def _current_lock(self, start_line: int) -> list[str]:
        curr_lock = []
        curr_lock.append(self.lines[start_line])

        current_line = start_line + 1
        while True:
            if current_line >= len(self.lines) or self._is_lock(
                self.lines[current_line]
            ):
                return curr_lock

            curr_lock.append(self.lines[current_line])
            current_line = current_line + 1

    def get_name(self) -> str:
        return self.header

    def get_locks(self) -> list[Lock]:
        return self.locks

    def get_traces(self) -> list[LockTrace]:
        traces = []
        for lock in self.locks:
            traces.append(lock.get_trace())
        return traces

    def get_lock_held_time(self, trace) -> int:
        for lock in self.locks:
            if lock.get_trace() == trace:
                return lock.get_held_time()

        return 0

    def get_lock_wait_time(self, trace) -> int:
        for lock in self.locks:
            if lock.get_trace() == trace:
                return lock.get_wait_time()

        return 0


"""
GroupTimes: A tuple-like class that associates the group name with the held and wait times for each lock trace.
"""


class GroupTimes:
    def __init__(self, group_name: str, held_time: int, wait_time: int):
        self.group_name = group_name
        self.held_time = held_time
        self.wait_time = wait_time

    def get_group_name(self) -> str:
        return self.group_name

    def get_held_time(self) -> int:
        return self.held_time

    def get_wait_time(self) -> int:
        return self.wait_time


"""
LockTraceManager: Handles filtering and managing the lock traces and associated group times.
It provides methods to filter the traces by time and to print the results in a sorted manner.
"""


class LockTraceManager:
    def __init__(self, traces: dict[LockTrace, list[GroupTimes]]):
        self.traces = traces

    # Filter the times for each trace
    def filter(self, held_time: int, wait_time: int):
        filtered_traces = dict[LockTrace, list[GroupTimes]]()
        for trace, times in self.traces.items():
            filtered_times = [
                time
                for time in self.traces.get(trace)
                if time.get_held_time() >= held_time
                and time.get_wait_time() >= wait_time
            ]
            if len(filtered_times) > 0:
                filtered_traces[trace] = filtered_times

        self.traces = filtered_traces

    # Keep the traces that match with the params
    def match(self, match_names: list[str]):
        filtered_traces = dict[LockTrace, list[GroupTimes]]()
        for trace, times in self.traces.items():
            for match_name in match_names:
                if trace.match(match_name):
                    filtered_traces[trace] = times

        self.traces = filtered_traces

    # print the traces with their times for each test
    def print(self, sort_held_time, sort_wait_time):
        if sort_held_time:
            for trace, times in self.traces.items():
                self.traces[trace] = sorted(
                    times, key=lambda x: x.get_held_time(), reverse=True
                )
        if sort_wait_time:
            for trace, times in self.traces.items():
                self.traces[trace] = sorted(
                    times, key=lambda x: x.get_held_time(), reverse=True
                )

        for trace, times in self.traces.items():
            print("-" * 20 + "TRACE" + "-" * 20)
            print("")
            print(trace)
            print("")
            for time in times:
                print(
                    "{} held: {} ms, wait: {} ms".format(
                        time.get_group_name(),
                        time.get_held_time(),
                        time.get_wait_time(),
                    )
                )
            print("")


"""
LocksFileReader: Reads the lock file and parses the different test cases and groups.
It extracts the relevant trace data and stores it in LocksGroup instances.
It can also return a dictionary of traces and associated group times.
"""


class LocksFileReader:

    PROJECT_PREFIX = "###START: SNAPD PROJECT"
    TEST_PREFIX = "###START:"

    def __init__(self, locks_file: str):
        self.locks_file = locks_file
        self.lines = list[str]()
        self.groups = list[LocksGroup]()

        self._read()

    def _read(self):
        with open(self.locks_file, "r") as f:
            self.lines = f.readlines()

        current_line = 0
        if not self._is_project(self.lines[current_line]):
            print("First time expected to be the project start.")
            sys.exit(1)

        # Read the tests
        while True:
            if current_line >= len(self.lines):
                return

            group_lines = self._current_group(current_line)
            if len(group_lines) == 0:
                print("Error parsing test.")
                sys.exit(1)

            self.groups.append(LocksGroup(group_lines))
            current_line = current_line + len(group_lines)

    # Indicates if the line is a test
    def _is_test(self, line: str) -> bool:
        return not self._is_project(line) and line.startswith(self.TEST_PREFIX)

    # Indicates if the line is the project declaration
    def _is_project(self, line: str) -> bool:
        return line.startswith(self.PROJECT_PREFIX)

    # This function works to detect the current test but also for the current project
    def _current_group(self, start_line: int) -> list[str]:
        curr_test = []
        curr_test.append(self.lines[start_line])

        current_line = start_line + 1
        while True:
            if current_line >= len(self.lines) or self._is_test(
                self.lines[current_line]
            ):
                return curr_test

            curr_test.append(self.lines[current_line])
            current_line = current_line + 1

    # Retrieve the test lines
    def get_test(self, test: str) -> list[str]:
        for group in self.groups:
            if test in group.get_name():
                return str(group)

        return ""

    # Retrieve the times for each trace in the file
    # For each trace, there is a list with the times for each test where the trace appears
    def get_traces_times(self) -> dict[LockTrace, list[GroupTimes]]:
        traces = dict[LockTrace, list[GroupTimes]]()
        for group in self.groups:
            group_traces = group.get_traces()
            for trace in group_traces:
                group_time = GroupTimes(
                    group.get_name(),
                    group.get_lock_held_time(trace),
                    group.get_lock_wait_time(trace),
                )
                if not trace in traces.keys():
                    traces[trace] = list[GroupTimes]()
                traces.get(trace).append(group_time)

        return traces


def _make_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="spread filter helper")
    parser.add_argument(
        "-f", "--locks-file", type=str, required=True, help="Locks file"
    )
    parser.add_argument(
        "--test",
        default="",
        help="Show results for this test, when test is selected no other filters are applied.",
    )
    parser.add_argument(
        "--match",
        action="append",
        default=[],
        help="Show traces that match this specific word",
    )
    parser.add_argument(
        "--held-time", type=int, default=0, help="Include locks with longer held time"
    )
    parser.add_argument(
        "--wait-time", type=int, default=0, help="Include locks with longer wait time"
    )
    parser.add_argument(
        "--sort-held-time",
        action="store_true",
        help="Sort higher times first by held time",
    )
    parser.add_argument(
        "--sort-wait-time",
        action="store_true",
        help="Sort higher times first by wait time",
    )

    return parser


if __name__ == "__main__":
    parser = _make_parser()
    args = parser.parse_args()

    if not os.path.isfile(args.locks_file):
        print(
            "state-lock-filter: locks file '{}' does not exist".format(args.locks_file)
        )
        sys.exit(1)

    if args.sort_held_time and args.sort_wait_time:
        print("state-lock-filter: define just 1 sorting (by held or wait times)")
        sys.exit(1)

    locks_reader = LocksFileReader(args.locks_file)
    if args.test:
        print(locks_reader.get_test(args.test))
        sys.exit()

    trace_manager = LockTraceManager(locks_reader.get_traces_times())

    # Then keep traces with matches
    if args.match:
        trace_manager.match(args.match)

    # First filter by time
    if args.held_time > 0 or args.wait_time > 0:
        trace_manager.filter(args.held_time, args.wait_time)

    # And finally print the sorted results (if required)
    trace_manager.print(args.sort_held_time, args.sort_wait_time)
