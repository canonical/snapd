summary: measuring basic properties of device cgroup v2

# skip all systems that do not use unified cgroup hierarchy by default
systems:
  - -amazon-*
  - -opensuse-15*
  - -ubuntu-14.04-*
  - -ubuntu-16.04-*
  - -ubuntu-18.04-*
  - -ubuntu-20.04-*
  - -ubuntu-21.04-*
  # using ubuntu-21.10-* would also disable ubuntu-21.10-64-cgroupv2
  - -ubuntu-21.10-64
  - -ubuntu-core-*
  - -debian-9-*
  - -debian-10-*
  - -centos-7-*
  - -centos-8-*

prepare: |
    tests.session -u test prepare

restore: |
    tests.session -u test restore

execute: |
    dump_cgroup_device_progs() {
        # dump all progs but those that are assigned to systemd, in which case
        # they have the pids list non empty
        bpftool prog list -j | jq -r '.[] | select(.type == "cgroup_device") | select(.pids == null) | .id'
    }
    echo "Dump BPF programs that are of type cgroup_device"
    dump_cgroup_device_progs > cgroup_device.progs-1

    echo "Install a test service"
    # Because this service is of type "simple" it is considered "ready" instantly.
    # In reality the process needs to go through snap "run" chain to be really
    # ready. As a workaround, touch a "remove-me" file that is removed by the
    # service on startup, restart the service and the wait for the file to
    # disappear.
    mkdir -p /var/snap/test-snapd-service/common
    touch /var/snap/test-snapd-service/common/remove-me
    "$TESTSTOOLS"/snaps-state install-local test-snapd-service
    # Wait for the service to really be alive and running. Otherwise the "main pid"
    # will be still tracking snap-run-confine-exec chain and be unreliable.
    retry -n 5 test ! -e /var/snap/test-snapd-service/common/remove-me

    echo "Extract the PID of the main process tracked by systemd"
    # It would be nicer to use "systemctl show --property=... --value" but it doesn't work on older systemd.
    pid=$(systemctl show snap.test-snapd-service.test-snapd-service.service --property=ExecMainPID | cut -d = -f 2)

    echo "Extract the cgroup of the main process"
    cgroup=$(grep 0:: < "/proc/$pid/cgroup" | cut -d : -f 3)

    # The service always runs in a device cgroup created by systemd (or in a
    # scope created snap run for user processes)
    test "$cgroup" = /system.slice/snap.test-snapd-service.test-snapd-service.service

    # Initially since there are no devices assigned to snap, there is no map with device access
    test ! -e /sys/fs/bpf/snap/snap_test-snapd-service_test-snapd-service
    # Do another dump
    dump_cgroup_device_progs > cgroup_device.progs-2
    echo "Verify no new device cgroup programs are present"
    test "$(wc -l < cgroup_device.progs-1)" = "$(wc -l < cgroup_device.progs-2)"

    echo "Connect the joystick interface"
    snap connect test-snapd-service:joystick

    # a device cgroup is not added until the service gets restarted
    test ! -e /sys/fs/bpf/snap/snap_test-snapd-service_test-snapd-service
    # or the command gets run
    test ! -e /sys/fs/bpf/snap/snap_test-snapd-service_sh

    echo "Run /bin/true from the snap, so that snap-confine creates the device cgroup"
    # shellcheck disable=SC2016
    snap run test-snapd-service.sh -c 'cat /proc/self/cgroup > $SNAP_COMMON/own.cgroup && /bin/true'
    # the content is:
    # 0::/user.slice/user-0.slice/user@0.service/app.slice/snap.test-snapd-service.sh.<uuid>.scope
    testshcgroup=$(cut -f3 -d: < /var/snap/test-snapd-service/common/own.cgroup)
    test -n "$testshcgroup"
    # with new devices assigned to the service, we see a map listing the devices
    # that access is allowed to
    echo "Verify that device access map for the application is present and is pinned to a file"
    test -e /sys/fs/bpf/snap/snap_test-snapd-service_sh
    # but there are no new programs, as they go away when cgroup is removed
    # (also wait until systemd cleans up the cgroup)
    retry -n 10 test ! -e "/sys/fs/cgroup/$testshcgroup"
    dump_cgroup_device_progs > cgroup_device.progs-3
    test "$(wc -l < cgroup_device.progs-1)" = "$(wc -l < cgroup_device.progs-3)"

    # dump the map
    bpftool map dump pinned /sys/fs/bpf/snap/snap_test-snapd-service_sh > device-access.map-app

    # NOTE: the actual permissions may drift over time. We just care about the fact
    # that there *are* some constraints here now and there were none before.
    echo "Verify the constraints in device cgroup imposed by snapd on the snap application"
    # the key checked below corresponds to /dev/null device, which is a char
    # device with major:minor 1:3, breaking that up into the key representation:
    # - 0x63 - single byte, 'c'
    # - 0x01 0x00 0x00 0x00 - uint32, host endian, value 1
    # - 0x03 0x00 0x00 0x00 - uint32, host endian, value 3
    MATCH 'key: 63 01 00 00 00 03 00 00 +00 +value: 01' < device-access.map-app

    echo "Restart the test service"
    touch /var/snap/test-snapd-service/common/remove-me
    snap restart test-snapd-service
    retry -n 5 test ! -e /var/snap/test-snapd-service/common/remove-me

    echo "Refresh the value of the main pid after restart"
    pid=$(systemctl show snap.test-snapd-service.test-snapd-service.service --property=ExecMainPID | cut -d = -f 2)
    # sanity check
    MATCH "$pid" < "/sys/fs/cgroup/$cgroup/cgroup.procs"

    echo "Verify that device access map for the service is present and is pinned to a file"
    test -e /sys/fs/bpf/snap/snap_test-snapd-service_test-snapd-service
    # dump the map
    bpftool map dump pinned /sys/fs/bpf/snap/snap_test-snapd-service_test-snapd-service > device-access.map-service

    # we use a hash map, and there may be a random element introduced affecting
    # the ordering, so just verify the basics
    echo "Verify the constraints in device cgroup imposed by snapd on the snap service"
    MATCH 'key: 63 01 00 00 00 03 00 00 +00 +value: 01' < device-access.map-service

    # since the service is up, we'll observe that a new program was loaded
    dump_cgroup_device_progs > cgroup_device.progs-4
    test "$(wc -l < cgroup_device.progs-1)" -lt "$(wc -l < cgroup_device.progs-4)"
