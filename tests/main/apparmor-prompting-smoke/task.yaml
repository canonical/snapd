summary: Check that AppArmor Prompting works end-to-end for home interface

details: |
    Test that AppArmor Prompting is working for the home interface. The test checks for the
    correct handling of permission prompts as well as rules created by responses to prompts.
    To do so, it uses the prompt-requester to attempt to read a file which it does not have
    read permission for triggering a prompt which is allowed or denied for either
    a single request or some duration lifespan. The test then checks if the rules created as a
    result of prompt response have the correct effect on the original and following request.

environment:
    TARGET_FILE/allow_prompt_single_lifespan: "/home/test/test_allow_prompt_single_lifespan/foo"
    TARGET_FILE/deny_prompt_single_lifespan: "/home/test/test_deny_prompt_single_lifespan/foo"
    TARGET_FILE/allow_prompt_timespan_lifespan: "/home/test/test_allow_prompt_timespan_lifespan/foo"
    TARGET_FILE/deny_prompt_timespan_lifespan: "/home/test/test_deny_prompt_timespan_lifespan/foo"

    PROMPT_RESPONSE/allow_prompt_single_lifespan: "allow"
    PROMPT_RESPONSE/deny_prompt_single_lifespan: "deny"
    PROMPT_RESPONSE/allow_prompt_timespan_lifespan: "allow"
    PROMPT_RESPONSE/deny_prompt_timespan_lifespan: "deny"

    LIFESPAN/allow_prompt_single_lifespan: "single"
    LIFESPAN/deny_prompt_single_lifespan: "single"
    LIFESPAN/allow_prompt_timespan_lifespan: "timespan"
    LIFESPAN/deny_prompt_timespan_lifespan: "timespan"

    DURATION: "20s"

systems:
    - ubuntu-2*

skip:
   - if: os.query is-ubuntu 20.04
     reason: Ubuntu 20.04 kernel doesn't support prompting
   - if: os.query is-ubuntu 22.04 && os.query is-kernel-lt 6.7
     reason: Ubuntu 22.04 kernel before 6.7 doesn't support prompting
   - if: os.query is-ubuntu 22.04 && not tests.info is-reexec-in-use
     reason: Ubuntu 22.04 AppArmor parser doesn't support prompting without reexec

prepare: |
    # Avoid checking for new release, it could cause lock on apt
    sed -i 's/^Prompt=.*$/Prompt=never/' /etc/update-manager/release-upgrades

    # Disable daily checks for updates to avoid apt locks
    sudo systemctl disable --now apt-daily{,-upgrade}.{timer,service}

    # Prerequisite for having a prompts handler service
    snap set system experimental.user-daemons=true

    dir="$(dirname $TARGET_FILE)"
    mkdir -p "$dir"
    echo "hello-foo" > $TARGET_FILE

    # Install a snap which identifies itself to snapd as a prompting handler-service
    "$TESTSTOOLS"/snaps-state install-local test-snapd-prompt-handler
    snap connect test-snapd-prompt-handler:snap-interfaces-requests-control

    # Install a snap which will trigger prompts
    "$TESTSTOOLS"/snaps-state install-local prompt-requester
    snap connect prompt-requester:home
restore: |
    echo "Disable AppArmor prompting experimental feature"
    snap set system experimental.apparmor-prompting=false

    echo "Remove any new listener ID file"
    rm -rf /{run,var/lib}/snapd/insterfaces-requests

    snap remove test-snapd-prompt-handler
    rm -rf $(dirname $TARGET_FILE)

debug: |
    uname -a
    snap debug api /v2/system-info

execute: |
    echo "Remove any existing listener ID file so snapd will register new listener"
    rm -f /run/snapd/interfaces-requests/listener-id

    # Enable prompting
    SNAPD_PID="$(systemctl show --property MainPID snapd.service | cut -f2 -d=)"

    echo "Enable AppArmor prompting experimental feature"
    snap set system experimental.apparmor-prompting=true

    echo "Wait for snapd to begin restart"
    #shellcheck disable=SC2016
    retry --wait 1 -n 300 sh -c 'test '"$SNAPD_PID"' != $(systemctl show --property MainPID snapd.service | cut -f2 -d=)'

    echo "Wait until snapd is active"
    retry --wait 1 -n 300 systemctl is-active snapd

    echo "Check that there are no prompts initially"
    RESULT="$(tests.session -u test exec snap debug api /v2/interfaces/requests/prompts)"
    echo "$RESULT" | MATCH '"status-code": 200'
    echo "$RESULT" | gojq '.result | length' | MATCH 0

    START="$(date --utc --rfc-3339 ns | tr -s ' ' T | sed 's/+00:00/Z/')" # Replace UTC 00:00 with Z
    sleep 1

    TMP_STDOUT=$(mktemp)
    TMP_STDERR=$(mktemp)

    echo "Trigger prompt by reading $TARGET_FILE"
    tests.session -u test exec prompt-requester.cat "$TARGET_FILE" >"$TMP_STDOUT" 2>"$TMP_STDERR" &
    REQUESTER_PID="$!"

    echo "Wait for notice for first prompt"
    RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-prompt&timeout=60s&after=$START")"
    echo "$RESULT" | MATCH '"status-code": 200'
    echo "$RESULT" | gojq '.result | length' | MATCH 1

    NOTICE_KEY="$(echo "$RESULT" | gojq .result[0].key | tr -d '"')"
    LAST_NOTICE_TIMESTAMP="$(echo "$RESULT" | gojq '.result[0]."last-repeated"' | tr -d '"')"

    echo "Check that the prompt with the ID given by the first notice is present"
    RESULT="$(tests.session -u test exec snap debug api "/v2/interfaces/requests/prompts/$NOTICE_KEY")"
    echo "$RESULT" | MATCH '"status-code": 200'
    echo "$RESULT" | gojq .result.constraints.path | MATCH "${TARGET_FILE}"
    PROMPT_ID="$(echo "$RESULT" | gojq .result.id | tr -d '"')"

    if [[ "$LIFESPAN" == "single" ]]; then
      echo "Reply to the prompt with $PROMPT_RESPONSE for single lifespan"
      RESPONSE="{\"action\": \"$PROMPT_RESPONSE\", \"lifespan\": \"single\", \"constraints\": {\"path-pattern\": \"$TARGET_FILE\", \"permissions\": [\"read\"]}}"
    elif [[ "$LIFESPAN" == "timespan" ]]; then
      echo "Reply to the prompt with $PROMPT_RESPONSE for timespan lifespan for a duration of $DURATION"
      RESPONSE="{\"action\": \"$PROMPT_RESPONSE\", \"lifespan\": \"timespan\", \"duration\": \"$DURATION\", \"constraints\": {\"path-pattern\": \"$TARGET_FILE\", \"permissions\": [\"read\"]}}"
    fi
    echo "$RESPONSE" | tests.session -u test exec snap debug api -X POST "/v2/interfaces/requests/prompts/$PROMPT_ID" | MATCH '"status-code": 200'

    echo "Wait for requester process to finish"
    wait "$REQUESTER_PID" || true

    echo "Check the process exited correctly"
    case "$PROMPT_RESPONSE" in
      "allow") cat "$TMP_STDOUT" | MATCH "hello-foo" ;;
      "deny")
        cat "$TMP_STDOUT" | MATCH "failed"
        cat "$TMP_STDERR" | MATCH "Permission denied"
        ;;
    esac

    if [[ "$LIFESPAN" == "timespan" ]]; then
      echo "Check that there is a notice for rule creation"
      RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-rule-update&timeout=60s&after=$LAST_NOTICE_TIMESTAMP")"
      echo "$RESULT" | MATCH '"status-code": 200'
      echo "$RESULT" | gojq '.result | length' | MATCH 1
      RULE_KEY="$(echo "$RESULT" | gojq .result[0].key | tr -d '"')"

      echo "Check that the rule with the corresponding ID exists"
      RESULT="$(tests.session -u test exec snap debug api "/v2/interfaces/requests/rules/$RULE_KEY")"
      echo "$RESULT" | gojq .result.interface | MATCH "home"
      echo "$RESULT" | gojq .result.constraints.permissions.read.outcome | MATCH "$PROMPT_RESPONSE"
      echo "$RESULT" | gojq .result.constraints.permissions.read.lifespan | MATCH "$LIFESPAN"
      echo "$RESULT" | MATCH '"status-code": 200'
    fi

    echo "Wait for notices for replied prompts"
    RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-prompt&timeout=60s&after=$LAST_NOTICE_TIMESTAMP")"
    echo "$RESULT" | MATCH '"status-code": 200'
    echo "$RESULT" | gojq '.result | length' | MATCH 1
    echo "$RESULT" | gojq '.result.[]."last-data"' | MATCH '"resolved": "replied"'
    LAST_NOTICE_TIMESTAMP="$(echo "$RESULT" | gojq '.result[0]."last-repeated"' | tr -d '"')"

    echo "Check that the prompts were resolved"
    RESULT="$(tests.session -u test exec snap debug api /v2/interfaces/requests/prompts)"
    echo "$RESULT" | MATCH '"status-code": 200'
    echo "$RESULT" | gojq '.result | length' | MATCH 0

    # START="$(date --utc --rfc-3339 ns | tr -s ' ' T | sed 's/+00:00/Z/')" # Replace UTC 00:00 with Z
    # echo "START: $START"
    echo "Run command to read $TARGET_FILE again"
    tests.session -u test exec prompt-requester.cat "$TARGET_FILE" >"$TMP_STDOUT" 2>"$TMP_STDERR" &
    REQUESTER_PID="$!"

    case "$LIFESPAN" in
      "timespan")
        echo "Check for notices"
        RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-prompt&timeout=10s&after=$LAST_NOTICE_TIMESTAMP")"
        echo "Ensure that request is autohandled"
        echo "$RESULT" | MATCH '"status-code": 200'
        echo "$RESULT" | gojq '.result | length' | MATCH 0
        ;;
      "single")
        echo "Wait for notice for prompt"
        RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-prompt&timeout=60s&after=$LAST_NOTICE_TIMESTAMP")"
        echo "Ensure that request is not autohandled"
        echo "$RESULT" | MATCH '"status-code": 200'
        echo "$RESULT" | gojq '.result | length' | MATCH 1
        NOTICE_KEY="$(echo "$RESULT" | gojq .result[0].key | tr -d '"')"
        LAST_NOTICE_TIMESTAMP="$(echo "$RESULT" | gojq '.result[0]."last-repeated"' | tr -d '"')"

        echo "Check that the prompt with the ID given by this notice is present"
        RESULT="$(tests.session -u test exec snap debug api "/v2/interfaces/requests/prompts/$NOTICE_KEY")"
        echo "$RESULT" | MATCH '"status-code": 200'
        echo "$RESULT" | gojq .result.constraints.path | MATCH "${TARGET_FILE}"
        PROMPT_ID="$(echo "$RESULT" | gojq .result.id | tr -d '"')"

        echo "Reply to the prompt with $PROMPT_RESPONSE for single lifespan"
        RESPONSE="{\"action\": \"$PROMPT_RESPONSE\", \"lifespan\": \"single\", \"constraints\": {\"path-pattern\": \"$TARGET_FILE\", \"permissions\": [\"read\"]}}"
        echo "$RESPONSE" | tests.session -u test exec snap debug api -X POST "/v2/interfaces/requests/prompts/$PROMPT_ID" | MATCH '"status-code": 200'

        echo "Wait for notices for second replied prompt"
        RESULT="$(tests.session -u test exec snap debug api "/v2/notices?types=interfaces-requests-prompt&timeout=60s&after=$LAST_NOTICE_TIMESTAMP")"
        echo "$RESULT" | MATCH '"status-code": 200'
        echo "$RESULT" | gojq '.result | length' | MATCH 1
        echo "$RESULT" | gojq '.result.[]."last-data"' | MATCH '"resolved": "replied"'

        echo "Check that the second prompt was resolved"
        RESULT="$(tests.session -u test exec snap debug api /v2/interfaces/requests/prompts)"
        echo "$RESULT" | MATCH '"status-code": 200'
        echo "$RESULT" | gojq '.result | length' | MATCH 0
        ;;
    esac

    echo "Wait for requester process to finish"
    wait "$REQUESTER_PID" || true

    echo "Check the process exited correctly"
    case "$PROMPT_RESPONSE" in
      "allow") cat "$TMP_STDOUT" | MATCH "hello-foo" ;;
      "deny")
        cat "$TMP_STDOUT" | MATCH "failed"
        cat "$TMP_STDERR" | MATCH "Permission denied"
        ;;
    esac

    rm -f "$TMP_STDOUT" "$TMP_STDOUT"

