summary: |
   Test that config defaults specified in the gadget are picked up
   for first boot snaps

systems: [ubuntu-core-1*-64]

environment:
    SERVICE/rsyslog: rsyslog
    GADGET_FILE/rsyslog: gadget-rsyslog.yaml
    SERVICE/ssh_common: ssh
    GADGET_FILE/ssh_common: gadget-ssh-common.yaml
    SERVICE/ssh_oneline: ssh
    GADGET_FILE/ssh_oneline: gadget-ssh-oneline.yaml

prepare: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi
    #shellcheck source=tests/lib/systemd.sh
    . "$TESTSLIB"/systemd.sh
    #shellcheck source=tests/lib/systems.sh
    . "$TESTSLIB"/systems.sh

    TARGET_SNAP=test-snapd-with-configure
    if is_core18_system; then
        TARGET_SNAP=test-snapd-with-configure-core18
    fi

    snap download --edge "$TARGET_SNAP"
    TEST_SNAP_ID="$(snap info $TARGET_SNAP | grep snap-id: | awk '{print $2}')"

    systemctl stop snapd.service snapd.socket
    rm -rf /var/lib/snapd/assertions/*
    rm -rf /var/lib/snapd/device
    rm -rf /var/lib/snapd/state.json

    unsquashfs -no-progress /var/lib/snapd/snaps/pc_*.snap

    # Update the gadget config file
    cat "$GADGET_FILE" >> squashfs-root/meta/gadget.yaml
    sed -i -e "s/TEST_SNAP_ID/$TEST_SNAP_ID/" squashfs-root/meta/gadget.yaml

    mksquashfs squashfs-root pc_x1.snap -comp xz -no-fragments -no-progress
    rm -rf squashfs-root
    cp pc_x1.snap /var/lib/snapd/seed/snaps/
    cp ${TARGET_SNAP}_*.snap /var/lib/snapd/seed/snaps/
    mv /var/lib/snapd/seed/assertions/model model.bak
    cp /var/lib/snapd/seed/seed.yaml seed.yaml.bak
    python3 ./manip_seed.py /var/lib/snapd/seed/seed.yaml "${TARGET_SNAP}"_*.snap "${TARGET_SNAP}"
    cp "$TESTSLIB"/assertions/developer1.account /var/lib/snapd/seed/assertions
    cp "$TESTSLIB"/assertions/developer1.account-key /var/lib/snapd/seed/assertions
    if is_core18_system; then
        cp "$TESTSLIB"/assertions/developer1-pc-18-w-config.model /var/lib/snapd/seed/assertions/developer1-pc-w-config.model
    else
        cp "$TESTSLIB"/assertions/developer1-pc-w-config.model /var/lib/snapd/seed/assertions
    fi
    cp "$TESTSLIB"/assertions/testrootorg-store.account-key /var/lib/snapd/seed/assertions
    cp ${TARGET_SNAP}_*.assert /var/lib/snapd/seed/assertions

    # kick first boot again
    systemctl start snapd.service snapd.socket

restore: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi

    #shellcheck source=tests/lib/systems.sh
    . "$TESTSLIB"/systems.sh

    TARGET_SNAP=test-snapd-with-configure
    if is_core18_system; then
        TARGET_SNAP=test-snapd-with-configure-core18
    fi

    echo "Undo the service disable"
    if [ "$SERVICE" = ssh ]; then
        rm -f /etc/ssh/sshd_not_to_be_run
    else
        systemctl unmask "$SERVICE.service" || true
    fi
    systemctl enable "$SERVICE.service" || true
    systemctl start "$SERVICE.service" || true

    #shellcheck source=tests/lib/systemd.sh
    . "$TESTSLIB"/systemd.sh
    systemctl stop snapd.service snapd.socket
    rm -rf /var/lib/snapd/assertions/*
    rm -rf /var/lib/snapd/device
    rm -rf /var/lib/snapd/state.json

    if systemctl status snap-pc-x1.mount ; then
       systemctl stop snap-pc-x1.mount
       rm -f /etc/systemd/system/snap-pc-x1.mount
       rm -f /etc/systemd/system/multi-user.target.wants/snap-pc-x1.mount
       rm -f /var/lib/snapd/snaps/pc_x1.snap
       systemctl daemon-reload
    fi
    rm /var/lib/snapd/seed/snaps/pc_x1.snap

    TEST_REVNO=$(awk "/^snap-revision: / {print \$2}" ${TARGET_SNAP}_*.assert)
    if systemctl status "$(systemd-escape --path /snap/test-snapd-with-configure/"$TEST_REVNO".mount)"; then
       systemctl stop "$(systemd-escape --path /snap/test-snapd-with-configure/"$TEST_REVNO".mount)"
       rm -f "/etc/systemd/system/${TARGET_SNAP}-${TEST_REVNO}.mount"
       rm -f "/etc/systemd/system/multi-user.target.wants/${TARGET_SNAP}-${TEST_REVNO}.mount"
       rm -f /var/lib/snapd/snaps/"${TARGET_SNAP}"_*.snap
       systemctl daemon-reload
    fi
    rm /var/lib/snapd/seed/snaps/"${TARGET_SNAP}"_*.snap

    cp seed.yaml.bak /var/lib/snapd/seed/seed.yaml
    rm -f /var/lib/snapd/seed/assertions/developer1.account
    rm -f /var/lib/snapd/seed/assertions/developer1.account-key
    rm -f /var/lib/snapd/seed/assertions/developer1-pc-w-config.model
    rm -f /var/lib/snapd/seed/assertions/testrootorg-store.account-key
    rm -f /var/lib/snapd/seed/assertions/"${TARGET_SNAP}"_*.assert
    cp model.bak /var/lib/snapd/seed/assertions/model
    # kick first boot again
    systemctl start snapd.service snapd.socket
    # wait for first boot to be done
    while ! snap changes | grep -q "Done.*Initialize system state"; do sleep 1; done

execute: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi

    #shellcheck source=tests/lib/systems.sh
    . "$TESTSLIB"/systems.sh

    TARGET_SNAP=test-snapd-with-configure
    BASE_SNAP=core
    if is_core18_system; then
        TARGET_SNAP=test-snapd-with-configure-core18
        BASE_SNAP=core18
    fi

    echo "Wait for first boot to be done"
    while ! snap changes | grep -q "Done.*Initialize system state"; do sleep 1; done
    echo "We have a model assertion"
    snap known model | MATCH "model: my-model-w-config"

    echo "The configurable snap was installed"
    snap list | MATCH "${TARGET_SNAP}"

    echo "The configuration defaults from the gadget where applied"
    snap get "${TARGET_SNAP}" a | MATCH "^A$"
    snap get "${TARGET_SNAP}" b | MATCH "^B$"

    echo "The configuration for $BASE_SNAP is applied"
    snap get "${BASE_SNAP}" "service.$SERVICE.disable" | MATCH true

    if [ "$SERVICE" = ssh ]; then
        echo "And the ssh service is disabled"
        MATCH "SSH has been disabled by snapd system configuration" < /etc/ssh/sshd_not_to_be_run
        systemctl status "$SERVICE.service" | MATCH inactive
    else
        echo "And the service is masked"
        systemctl status "$SERVICE.service" | MATCH masked
    fi
