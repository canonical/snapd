summary: Check that snapd successfully starts with AppArmor prompting enabled

details: |
    When snapd starts up with the AppArmor prompting flag enabled, it attempts
    to load any existing rules from disk and records notices for them, expiring
    any rules which have expiration timestamps in the past. This test checks
    that snapd can successfully start with prompting enabled, and that it can
    load and expire rules and record notices appropriately.

systems:
  - ubuntu-2*

prepare: |
    # prerequisite for having a prompt handler service
    snap set system experimental.user-daemons=true
    "$TESTSTOOLS"/snaps-state install-local test-snapd-prompt-handler
    snap connect test-snapd-prompt-handler:snap-interfaces-requests-control

execute: |
    RULES_PATH="/var/lib/snapd/interfaces-requests/request-rules.json"

    echo "Write two rules to disk, one of which is expired"
    mkdir -p "$(dirname $RULES_PATH)"
    echo '{"rules":[{"id":"0000000000000002","timestamp":"2004-10-20T14:05:08.901174186-05:00","user":1000,"snap":"shellcheck","interface":"home","constraints":{"path-pattern":"/home/test/Projects/**","permissions":["read"]},"outcome":"allow","lifespan":"forever","expiration":"0001-01-01T00:00:00Z"},{"id":"0000000000000003","timestamp":"2004-10-20T16:47:32.138415627-05:00","user":1000,"snap":"firefox","interface":"home","constraints":{"path-pattern":"/home/test/Downloads/**","permissions":["read","write"]},"outcome":"allow","lifespan":"timespan","expiration":"2005-04-08T00:00:00Z"}]}' | tee "$RULES_PATH"

    # Prompting is disabled everywhere but the Ubuntu systems
    # TODO: on Ubuntu releases < 24.04 we need the snapd snap for testing
    if ! os.query is-ubuntu || os.query is-ubuntu-lt 24.04 || os.query is-core ; then
        not snap set system experimental.apparmor-prompting=true >& err.out
        if os.query is-core; then
            # there is a more specific error on Ubuntu Core
            MATCH "cannot enable prompting feature as it is not supported on Ubuntu Core systems" < err.out
        else
            MATCH "cannot enable prompting feature as it is not supported by the system" < err.out
        fi
        # even if unsupported setting it to false should succeed
        snap set system experimental.apparmor-prompting=false
        exit 0
    fi

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    # Wait a second to make sure any notices are recorded after CURRTIME
    sleep 1

    echo "Enable AppArmor prompting experimental feature"
    snap set system experimental.apparmor-prompting=true

    # Wait for snapd to begin restart
    sleep 5

    echo "Check that snapd is able to start up"
    retry --wait 1 -n 60 systemctl is-active snapd

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".enabled' | MATCH true

    # Write expected rules after the expired rule has been removed
    echo '{"rules":[{"id":"0000000000000002","timestamp":"2004-10-20T14:05:08.901174186-05:00","user":1000,"snap":"shellcheck","interface":"home","constraints":{"path-pattern":"/home/test/Projects/**","permissions":["read"]},"outcome":"allow","lifespan":"forever","expiration":"0001-01-01T00:00:00Z"}]}' | jq | tee expected.json
    # Parse existing rules through jq so they can be compared
    jq < "$RULES_PATH" > current.json

    echo "Check that rules on disk match what is expected"
    diff expected.json current.json

    echo "Check that we received two notices"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result | length' | MATCH 2
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result' | grep -c '"removed": "expired"' | MATCH 1

    echo "Check that only the former rule is still valid (must be done with UID 1000)"
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result | length' | MATCH 1
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result[0].id' | MATCH "0000000000000002"

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl stop snapd.service snapd.socket
    # Try for a while to make sure it's not in failure mode
    echo "Check that systemctl is-failed is never true after a while"
    not retry --wait 1 -n 30 systemctl is-failed snapd.service snapd.socket

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Restart snapd and ensure it starts properly"
    systemctl start snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk still match what is expected"
    diff expected.json current.json

    echo "Check that we received one notices for the non-expired rule"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result | length' | MATCH 1
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result[0].key' | MATCH "0000000000000002"

    echo "Check that only the non-expired rule is still valid (must be done with UID 1000)"
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result | length' | MATCH 1
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result[0].id' | MATCH "0000000000000002"

    echo '### Simulate failure to open interfaces requests manager ###'

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl stop snapd.service snapd.socket
    # Try for a while to make sure it's not in failure mode
    echo "Check that systemctl is-failed is never true after a while"
    not retry --wait 1 -n 30 systemctl is-failed snapd.service snapd.socket

    echo "Corrupt the max prompt ID file (by making it a dir) so it will fail to start up next time"
    # This simulates what would happen on system restart, if e.g. /run/snapd did not yet exist during StartUp
    MAX_ID_FILEPATH="/run/snapd/request-prompt-max-id"
    rm -f "$MAX_ID_FILEPATH"
    mkdir -p "$MAX_ID_FILEPATH"

    echo "Restart snapd and ensure it starts properly"
    systemctl start snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    # XXX: in the future, we should set enabled to be false if m.AppArmorPromptingRunning() is false,
    # such as because creating the interfaces requests manager failed.
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk still match what is expected"
    diff expected.json current.json

    echo "Check that accessing a prompting endpoint results in an expected error"
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '."status-code"' | MATCH 500
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result.message' | MATCH -i "Apparmor Prompting is not running"

    echo '### Remove the corrupted max prompt ID file and check that prompting backends can start again ###'

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl stop snapd.service snapd.socket
    # Try for a while to make sure it's not in failure mode
    echo "Check that systemctl is-failed is never true after a while"
    not retry --wait 1 -n 30 systemctl is-failed snapd.service snapd.socket

    echo "Remove corrupted max prompt ID file"
    rm -rf "$MAX_ID_FILEPATH"

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Restart snapd and ensure it starts properly"
    systemctl start snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | jq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk still match what is expected"
    diff expected.json current.json

    echo "Check that we received one notices for the non-expired rule"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result | length' | MATCH 1
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | jq '.result[0].key' | MATCH "0000000000000002"

    echo "Check that the non-expired rule is still valid (must be done with UID 1000)"
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result | length' | MATCH 1
    sudo -iu '#1000' snap debug api /v2/interfaces/requests/rules | jq '.result[0].id' | MATCH "0000000000000002"
