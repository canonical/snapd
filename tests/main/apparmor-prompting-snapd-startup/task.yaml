summary: Check that snapd successfully starts with AppArmor prompting enabled

details: |
    When snapd starts up with the AppArmor prompting flag enabled, it attempts
    to load any existing rules from disk and records notices for them, expiring
    any rules which have expiration timestamps in the past. This test checks
    that snapd can successfully start with prompting enabled, and that it can
    load and expire rules and record notices appropriately.

systems:
  - ubuntu-2*

skip:
    - if: os.query is-ubuntu 20.04
      reason: Ubuntu 20.04 kernel doesn't support prompting
    - if: os.query is-ubuntu 22.04 && os.query is-kernel-lt 6.7
      reason: Ubuntu 22.04 kernel before 6.7 doesn't support prompting
    - if: os.query is-ubuntu 22.04 && not tests.info is-reexec-in-use
      reason: Ubuntu 22.04 AppArmor parser doesn't support prompting without reexec

prepare: |
    # prerequisite for having a prompt handler service
    snap set system experimental.user-daemons=true
    "$TESTSTOOLS"/snaps-state install-local test-snapd-prompt-handler
    snap connect test-snapd-prompt-handler:snap-interfaces-requests-control

    tests.pkgs install attr

restore: |
    snap remove --purge test-snapd-prompt-handler || true
    snap set system experimental.apparmor-prompting=false

debug: |
    echo "Check kernel version"
    uname -a
    echo "Check kernel notification socket presence"
    if ls /sys/kernel/security/apparmor/.notify ; then
        echo "kernel notification socket exists"
    else
        echo "kernel notification socket does not exist"
    fi
    echo "Check system info"
    snap debug api /v2/system-info

execute: |
    RULES_PATH="/var/lib/snapd/interfaces-requests/request-rules.json"

    echo "Since there is no user 1000 active on the system, write a known user session ID xattr to /run/user/1000/"
    USER_SESSION_PATH="/run/user/1000"
    mkdir -p "$USER_SESSION_PATH"
    setfattr -n trusted.snapd_user_session_id -v "0123456789ABCDEF" "$USER_SESSION_PATH"

    echo "Enable AppArmor prompting experimental feature"
    snap set system experimental.apparmor-prompting=true

    # Wait for snapd to begin restart
    sleep 5

    echo "Check that snapd is able to start up"
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".enabled' | MATCH true

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Add first rule (which we'll later modify manually to expire some permissions)"
    echo '{
      "action": "add",
      "rule": {
        "snap": "shellcheck",
        "interface": "home",
        "constraints": {
          "path-pattern": "/home/test/Projects/**",
          "permissions": {
            "read": {
              "outcome": "allow",
              "lifespan": "forever"
            },
            "write": {
              "outcome": "allow",
              "lifespan": "timespan",
              "duration": "1h"
            },
            "execute": {
              "outcome": "deny",
              "lifespan": "timespan",
              "duration": "100h"
            }
          }
        }
      }
    }' | gojq | snap debug api -X POST '/v2/interfaces/requests/rules?user-id=1000' > result.json
    MATCH '"status-code": 200' < result.json
    RULE1_ID="$(gojq '.result.id' < result.json)"

    echo "Check that we received a notice when the rule was added"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^1$'
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result[0].key' | MATCH "$RULE1_ID"

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Add second rule (which we'll later modify manually to expire all permissions)"
    echo '{
      "action": "add",
      "rule": {
        "snap": "firefox",
        "interface": "home",
        "constraints": {
          "path-pattern": "/home/test/Downloads/**",
          "permissions": {
            "read": {
              "outcome": "deny",
              "lifespan": "timespan",
              "duration": "15m"
            },
            "write": {
              "outcome": "allow",
              "lifespan": "timespan",
              "duration": "1h"
            },
            "execute": {
              "outcome": "deny",
              "lifespan": "session"
            }
          }
        }
      }
    }' | gojq | snap debug api --fail -X POST '/v2/interfaces/requests/rules?user-id=1000' > result.json
    MATCH '"status-code": 200' < result.json
    RULE2_ID="$(gojq '.result.id' < result.json)"

    echo "Check that we received a notice when the rule was added"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^1$'
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result[0].key' | MATCH "$RULE2_ID"

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Add third rule (which we'll leave unchanged on disk)"
    echo '{
      "action": "add",
      "rule": {
        "snap": "thunderbird",
        "interface": "home",
        "constraints": {
          "path-pattern": "/home/test/Downloads/thunderbird.tmp/**",
          "permissions": {
            "read": {
              "outcome": "allow",
              "lifespan": "forever"
            },
            "write": {
              "outcome": "allow",
              "lifespan": "timespan",
              "duration": "1h"
            },
            "execute": {
              "outcome": "deny",
              "lifespan": "session"
            }
          }
        }
      }
    }' | gojq | snap debug api --fail -X POST '/v2/interfaces/requests/rules?user-id=1000' > result.json
    MATCH '"status-code": 200' < result.json
    RULE3_ID="$(gojq '.result.id' < result.json)"

    echo "Check that we received a notice when the rule was added"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^1$'
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result[0].key' | MATCH "$RULE3_ID"

    echo "Stop snapd so we can edit rules on disk, and ensure it is not in failure mode"
    systemctl disable --now snapd.service snapd.socket
    not retry --wait 1 -n 10 systemctl is-failed snapd.service snapd.socket

    echo "Edit the rules on disk to expire some permissions"
    gojq '(.rules.[] | select(.id == '"$RULE1_ID"')).constraints.permissions.write.expiration = "2005-04-08T00:00:00Z"' < "$RULES_PATH" | \
    gojq '(.rules.[] | select(.id == '"$RULE2_ID"')).constraints.permissions.read.expiration = "2005-04-08T00:00:00Z"' | \
    gojq '(.rules.[] | select(.id == '"$RULE2_ID"')).constraints.permissions.write.expiration = "2005-04-08T00:00:00Z"' | \
    gojq '(.rules.[] | select(.id == '"$RULE2_ID"')).constraints.permissions.execute."session-id" = "F00BA4F00BA40000"' | tee modified.json
    mv modified.json "$RULES_PATH"

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Enable snapd so it will remove the expired permissions and record notices"
    systemctl enable --now snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that only the first and last rules are still valid (must be done with UID 1000)"
    snap debug api --fail "/v2/interfaces/requests/rules?user-id=1000" | gojq
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result | length' | MATCH '^2$'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE1_ID"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE3_ID"

    echo "Check that the expired permissions of the non-expired rules were removed"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[] | select(.id == '"$RULE1_ID"') | .constraints.permissions | length' | MATCH '^2$'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[] | select(.id == '"$RULE1_ID"') | .constraints.permissions.write' | MATCH 'null'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[] | select(.id == '"$RULE3_ID"') | .constraints.permissions | length' | MATCH '^3$'

    echo "Check that we received two notices, one of which marked a rule as expired"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^2$'
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result.[].key' | MATCH "$RULE1_ID"
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result.[].key' | MATCH "$RULE2_ID"
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result' | grep -c '"removed": "expired"' | MATCH '^1$'
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result.[] | select(.key == '"$RULE2_ID"')' | MATCH '"removed": "expired"'

    cp "$RULES_PATH" expected.json

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl disable --now snapd.service snapd.socket
    not retry --wait 1 -n 10 systemctl is-failed snapd.service snapd.socket

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Restart snapd and ensure it starts properly"
    systemctl enable --now snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk were not changed after snapd restart"
    diff expected.json "$RULES_PATH"

    echo "Check that only the non-expired rules are still valid (must be done with UID 1000)"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result | length' | MATCH '^2$'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE1_ID"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE3_ID"

    echo "Check that we received no new notices since the rules were not changed on load"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^0$'

    echo '### Simulate failure to open interfaces requests manager ###'

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl disable --now snapd.service snapd.socket
    not retry --wait 1 -n 10 systemctl is-failed snapd.service snapd.socket

    echo "Corrupt the max prompt ID file (by making it a dir) so it will fail to start up next time"
    # This simulates what would happen on system restart, if e.g. /run/snapd did not yet exist during StartUp
    MAX_ID_FILEPATH="/run/snapd/interfaces-requests/request-prompt-max-id"
    mv "$MAX_ID_FILEPATH" "$MAX_ID_FILEPATH".bak
    mkdir -p "$MAX_ID_FILEPATH"

    echo "Restart snapd and ensure it starts properly"
    systemctl enable --now snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    # XXX: in the future, we should set enabled to be false if m.AppArmorPromptingRunning() is false,
    # such as because creating the interfaces requests manager failed.
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk still match what is expected"
    diff expected.json "$RULES_PATH"

    echo "Check that accessing a prompting endpoint results in an expected error"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '."status-code"' | MATCH '^500$'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.message' | MATCH -i "Apparmor Prompting is not running"

    echo '### Remove the corrupted max prompt ID file and check that prompting backends can start again ###'

    echo "Stop snapd and ensure it is not in failure mode"
    systemctl disable --now snapd.service snapd.socket
    not retry --wait 1 -n 10 systemctl is-failed snapd.service snapd.socket

    echo "Remove corrupted max prompt ID file"
    rm -rf "$MAX_ID_FILEPATH"
    mv "$MAX_ID_FILEPATH".bak "$MAX_ID_FILEPATH"

    CURRTIME="$(date --rfc-3339=ns --utc | tr ' ' 'T' | sed 's/\+00:00/Z/')"

    echo "Restart snapd and ensure it starts properly"
    systemctl enable --now snapd.service snapd.socket
    retry --wait 1 -n 60 systemctl is-active snapd.service snapd.socket

    echo "Check that apparmor prompting is supported and enabled"
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".supported' | MATCH true
    snap debug api "/v2/system-info" | gojq '.result.features."apparmor-prompting".enabled' | MATCH true

    echo "Check that rules on disk still match what is expected"
    diff expected.json "$RULES_PATH"

    echo "Check that the non-expired rules are still valid (must be done with UID 1000)"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result | length' | MATCH '^2$'
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE1_ID"
    snap debug api "/v2/interfaces/requests/rules?user-id=1000" | gojq '.result.[].id' | MATCH "$RULE3_ID"

    echo "Check that we received no new notices, as the non-expired rules did not changed on restart"
    snap debug api --fail "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | gojq
    snap debug api "/v2/notices?after=$CURRTIME&types=interfaces-requests-rule-update&user-id=1000" | \
        gojq '.result | length' | MATCH '^0$'
