summary: Ensure network errors are handled gracefully

details: |
    Check that snapd handles and logs network errors correctly. The test does
    this by rejecting DNS queries with iptables, flushing the DNS cache and
    then forcing snapd to trigger a query.

# no iptables on core18+
systems: [-ubuntu-core-18-*, -ubuntu-core-2*]

prepare: |
    if [ -f /etc/systemd/system/snapd.service.d/proxy.conf ]; then
        "$TESTSTOOLS"/fs-state mock-file /etc/systemd/system/snapd.service.d/proxy.conf
        tests.cleanup defer "$TESTSTOOLS"/fs-state restore-file /etc/systemd/system/snapd.service.d/proxy.conf
    fi

    if [ -f /etc/environment ]; then
        "$TESTSTOOLS"/fs-state mock-file /etc/environment
        tests.cleanup defer "$TESTSTOOLS"/fs-state restore-file /etc/environment
    fi

    systemd-run --service-type=notify --uid=test --unit tinyproxy-stalling -- \
        python3 "$TESTSLIB/tinyproxy/tinyproxy.py" --stall-for-seconds=60
    tests.systemd wait-for-service -n 30 --state active tinyproxy-stalling

restore: |
    systemctl stop tinyproxy-stalling || true
    systemctl reset-failed tinyproxy-stalling || true

debug: |
    systemctl status tinyproxy-stalling || true

execute: |
    # Do a store op to avoid an unexpected device auth refresh on snap find
    # below, which would produce different kind of error.
    snap refresh

    systemctl stop snapd.{socket,service}

    if [ -f /etc/environment ]; then
        echo > /etc/environment
    fi

    tinyproxy_addr=127.0.0.1:3128
    mkdir -p /etc/systemd/system/snapd.service.d
    cat <<EOF > /etc/systemd/system/snapd.service.d/proxy.conf
    [Service]
    Environment=HTTPS_PROXY=$tinyproxy_addr
    Environment=HTTP_PROXY=$tinyproxy_addr
    Environment=https_proxy=$tinyproxy_addr
    Environment=http_proxy=$tinyproxy_addr
    EOF

    systemctl daemon-reload
    systemctl start snapd.{socket,service}

    OUT=$(snap find test 2>&1 || true)
    echo "$OUT" | MATCH "error: unable to contact snap store"
