summary: Ensure that the security rules for private tmp are in place.
prepare: |
    snap pack test-snapd-tmp-a
    snap pack test-snapd-tmp-b
    snap install --dangerous test-snapd-tmp-a_1_all.snap
    snap install --dangerous test-snapd-tmp-b_1_all.snap
    # The per-snap base directory is not carried over across tests.
    test ! -e /tmp/snap.test-snapd-tmp-a
    test ! -e /tmp/snap.test-snapd-tmp-b
restore: |
    snap remove test-snapd-tmp-a
    snap remove test-snapd-tmp-b
    rm -f test-snapd-tmp-{a,b}-1_all.snap
    rm -rf /tmp/snap.test-snapd-tmp-{a,b}
execute: |
    # shellcheck source=tests/lib/dirs.sh
    . "$TESTSLIB"/dirs.sh

    # Each snap gets a private /tmp directory
    test-snapd-tmp-a.sh -c 'echo secret-a > /tmp/private'
    test-snapd-tmp-b.sh -c 'echo secret-b > /tmp/private'

    # The view of the /tmp directory persists across snap command invocations.
    test "$(test-snapd-tmp-a.sh -c 'cat /tmp/private')" = secret-a
    test "$(test-snapd-tmp-b.sh -c 'cat /tmp/private')" = secret-b

    # The private /tmp directory persists even if the mount namespace is discarded.
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-tmp-a
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-tmp-b
    test "$(test-snapd-tmp-a.sh -c 'cat /tmp/private')" = secret-a
    test "$(test-snapd-tmp-b.sh -c 'cat /tmp/private')" = secret-b

    # The private /tmp directories are stored in the /tmp directory on the host.
    test "$(cat /tmp/snap.test-snapd-tmp-a/tmp/private)" = secret-a
    test "$(cat /tmp/snap.test-snapd-tmp-b/tmp/private)" = secret-b

    # The so-called base directory is root owned and root-accessible only.
    test "$(stat -c %a /tmp/snap.test-snapd-tmp-a)" = 700
    test "$(stat -c %u.%g /tmp/snap.test-snapd-tmp-a)" = 0.0

    # The private /tmp directory is root owned and has permissions typically of a tmp directory.
    test "$(stat -c %a /tmp/snap.test-snapd-tmp-a/tmp)" = 1777
    test "$(stat -c %u.%g /tmp/snap.test-snapd-tmp-a/tmp)" = 0.0

    # This part is new and depends on the hardening.

    # snap-confine detects permission violations of base directory
    # but only during the initial construction of the mount namespace.
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-tmp-a
    chmod 770 /tmp/snap.test-snapd-tmp-a
    test-snapd-tmp-a.sh -c true 2>&1 | MATCH "cannot proceed with non-0700-mode base directory"
    chmod 700 /tmp/snap.test-snapd-tmp-a
    chown 1.0 /tmp/snap.test-snapd-tmp-a
    test-snapd-tmp-a.sh -c true 2>&1 | MATCH "cannot proceed with non-root-owned base directory"
    chown 0.1 /tmp/snap.test-snapd-tmp-a
    test-snapd-tmp-a.sh -c true 2>&1 | MATCH "cannot proceed with non-root-owned base directory"

    # snap-confine does work when both mode and ownership of the base directory is correct.
    chown 0.0 /tmp/snap.test-snapd-tmp-a
    test-snapd-tmp-a.sh -c true
