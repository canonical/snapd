summary: "regression test for LP: #1813963"
prepare: |
    #shellcheck source=tests/lib/snaps.sh
    . "$TESTSLIB"/snaps.sh
    #shellcheck source=tests/lib/dirs.sh
    . "$TESTSLIB"/dirs.sh
    # Install the versatile test snap.
    install_local test-snapd-sh
    # Discard the mount namespace in case the snap has any hooks. We rely on
    # the mount namespace to be absent and about to be constructed in the test
    # below.
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-sh

    # Install a simple service snap. This snap has a single service that just
    # runs for an hour and quits. The point is that it is just one service
    # without anything special about it.
    #
    # For the purpose of the test we want the service to be off.
    install_local test-snapd-simple-service
    systemctl stop snap.test-snapd-simple-service.test-snapd-simple-service.service
    "$LIBEXECDIR"/snapd/snap-discard-ns test-snapd-simple-service

    # Nothing should have been denied yet.
    test "$(dmesg | grep -c DENIED)" -eq 0

    # Check if we have apparmor support. When there is no apparmor we don't
    # need special profile changes below.
    if snap debug sandbox-features | grep -q apparmor; then
        apparmor=yes
    else
        apparmor=no
    fi

    systemctl stop snapd.service
    echo "snapd has been stopped" | systemd-cat

    if [ "$apparmor" = yes ]; then
        # Because we are about to replace snap-update-ns with a script we also need
        # to adjust the per-snap apparmor profile of snap-update-ns to convey
        # additional permissions about executing as a script.
        for SUN_AA in /var/lib/snapd/apparmor/profiles/snap-update-ns.test-snapd-sh /var/lib/snapd/apparmor/profiles/snap-update-ns.test-snapd-simple-service; do
            truncate --size=-2 "$SUN_AA"  # chop trailing }
            profile="$(basename "$SUN_AA")"
            {
                echo '  /bin/dash mrix,'
                echo '  /bin/sleep mrix,'
                echo "  $(pwd)"'/real-snap-update-ns mrix,'
                echo '  signal (send, receive) set=(int, pipe) peer='"$profile"','
                echo '}'
            } >> "$SUN_AA"
            apparmor_parser -r "$SUN_AA"
        done
        echo "snap-update-ns profiles have been replaced" | systemd-cat
    fi

    # Replace snap-update-ns with a fake version that waits for the given
    # amount of time before doing its real work. Since snap-update-ns doesn't
    # have access to real environment craft the script with appropriate paths
    # baked-in from the outside.
    cp "$LIBEXECDIR/snapd/snap-update-ns" ./real-snap-update-ns

    echo '#!/bin/sh -x' > fake-snap-update-ns
    # 31 seconds is one second longer than the sanity timeout.
    echo 'sleep 31' >> fake-snap-update-ns
    echo 'exec "'"$(pwd)/real-snap-update-ns"'" "$@"' >> fake-snap-update-ns
    chmod 0755 fake-snap-update-ns

    # Replace snap-update-ns in all the places it might exist in.
    mount --bind ./fake-snap-update-ns "$LIBEXECDIR/snapd/snap-update-ns"
    if [ -e "$SNAP_MOUNT_DIR/core/current/" ]; then
        mount --bind ./fake-snap-update-ns "$SNAP_MOUNT_DIR/core/current/usr/lib/snapd/snap-update-ns"
    fi
    if [ -e "$SNAP_MOUNT_DIR/snapd/current/" ]; then
        mount --bind ./fake-snap-update-ns "$SNAP_MOUNT_DIR/snapd/current/usr/lib/snapd/snap-update-ns"
    fi
    echo "snap-update-ns has been replaced" | systemd-cat
restore: |
    #shellcheck source=tests/lib/dirs.sh
    . "$TESTSLIB"/dirs.sh
    umount "$LIBEXECDIR/snapd/snap-update-ns" || true
    if [ -e "$SNAP_MOUNT_DIR/core/current/" ]; then
        umount "$SNAP_MOUNT_DIR/core/current/usr/lib/snapd/snap-update-ns" || true
    fi
    if [ -e "$SNAP_MOUNT_DIR/snapd/current/" ]; then
        umount "$SNAP_MOUNT_DIR/snapd/current/usr/lib/snapd/snap-update-ns" || true
    fi

    rm -f real-snap-update-ns
    rm -f fake-snap-update-ns
    echo "snap-update-ns has been restored" | systemd-cat

    systemctl start snapd.service
    echo "snapd has been started" | systemd-cat

    snap remove test-snapd-sh
    snap remove test-snapd-simple-service
    echo "snaps have been removed" | systemd-cat

execute: |
    # When snap-update-ns is artificially slowed down so that snap-confine
    # starts to fail on timeout errors then the exit status from the
    # snap-confine process is the regular "failed" rather than "failed due to
    # signal SIGPIPE".
    set +e
    test-snapd-sh -c /bin/true
    retcode=$?
    set -e
    test "$retcode" -eq 1

    # When we start our simple service it will fail. We anticipate this and
    # explicitly pass --wait that will otherwise wait forever.
    set +e
    systemctl start --wait snap.test-snapd-simple-service.test-snapd-simple-service.service
    retcode=$?
    set -e
    test "$retcode" -eq 1

    # Nothing should have been denied as a part of this test.
    test "$(dmesg | grep -c DENIED)" -eq 0
debug: |
    echo "Status of the test service"
    systemctl status snap.test-snapd-simple-service.test-snapd-simple-service.service || true
    echo "Apparmor denials"
    dmesg | grep DENIED || true
