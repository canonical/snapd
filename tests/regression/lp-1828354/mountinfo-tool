#!/usr/bin/env python3
from abc import ABC, abstractmethod
from argparse import ArgumentParser, FileType, RawTextHelpFormatter
from typing import Dict, List, Tuple, Any, Type, Callable, Match
import re


class Device(int):
    """
    Device is a device number with major and minor components.

    Note that this class does not attempt to mimic peculiar
    encoding used by the Linux kernel.
    """

    @classmethod
    def pack(cls, major: int, minor: int) -> 'Device':
        return cls((major << 16) | (minor & (1 << 16) - 1))

    def __str__(self) -> str:
        return '{}:{}'.format(self.major, self.minor)

    @property
    def major(self) -> int:
        """major is the higher 16 bits of the device number."""
        return self >> 16

    @property
    def minor(self) -> int:
        """minor is the lower 16 bits of the device number."""
        return self & ((1 << 16) - 1)


class OptFields(List[str]):

    def __str__(self) -> str:
        return " ".join(self)


class MountInfoEntry:
    """Single entry in /proc/pid/mointinfo, see proc(5)"""

    mount_id: int
    parent_id: int
    dev: Device
    root_dir: str
    mount_point: str
    mount_opts: str
    opt_fields: OptFields
    fs_type: str
    mount_source: str
    sb_opts: str

    @classmethod
    def parse(cls: 'Type[MountInfoEntry]', line: str) -> 'MountInfoEntry':
        it = iter(line.split())
        self = cls()
        self.mount_id = int(next(it))
        self.parent_id = int(next(it))
        dev_maj, dev_min = map(int, next(it).split(':'))
        self.dev = Device((dev_maj << 16) | dev_min)
        self.root_dir = next(it)
        self.mount_point = next(it)
        self.mount_opts = next(it)
        self.opt_fields = OptFields()
        for opt_field in it:
            if opt_field == '-':
                break
            self.opt_fields.append(opt_field)
        self.fs_type = next(it)
        self.mount_source = next(it)
        self.sb_opts = next(it)
        try:
            next(it)
        except StopIteration:
            pass
        else:
            raise ValueError("leftovers after parsing {!r}".format(line))
        return self

    def __str__(self) -> str:
        return ("{0.mount_id} {0.parent_id} {0.dev} {0.root_dir}"
                " {0.mount_point} {0.mount_opts} {opt_fields} {0.fs_type}"
                " {0.mount_source} {0.sb_opts}").format(
                    self, opt_fields=' '.join(self.opt_fields + ['-']))

    @property
    def dev_maj(self) -> int:
        return self.dev.major

    @property
    def dev_min(self) -> int:
        return self.dev.minor


class FilterExpr(ABC):

    @abstractmethod
    def __contains__(self, entry: MountInfoEntry) -> bool:
        pass


class AttrFilter(FilterExpr):
    """AttrFilter performs equality test against a given attribute."""

    def __init__(self, attr: str, value: Any):
        self.attr = attr
        self.value = value

    def __contains__(self, entry: MountInfoEntry) -> bool:
        value = getattr(entry, self.attr)
        return bool(value == self.value)


class AttrPrefixFilter(FilterExpr):
    """AttrPrefixFilter performs prefix test against a given attribute."""

    def __init__(self, attr: str, value: str):
        self.attr = attr
        self.value = value

    def __contains__(self, entry: MountInfoEntry) -> bool:
        value = str(getattr(entry, self.attr))
        return value.startswith(self.value)


def parse_filter(expr: str) -> FilterExpr:
    """parse_filter parses one of the known filter expressions."""
    if '=' in expr:
        if expr.startswith("."):
            expr = expr.lstrip(".")
        attr, value = expr.split('=', 1)
        if attr in MountInfoEntry.__annotations__:
            typ = MountInfoEntry.__annotations__[attr]
            return AttrFilter(attr, typ(value))
        raise ValueError("invalid filter expression {!r}".format(expr))
    elif expr.endswith("..."):
        return AttrPrefixFilter("mount_point", expr.rstrip("..."))
    else:
        return AttrFilter("mount_point", expr)


def parse_attr(expr: str) -> str:
    """parse_attr parses attribute references (for display)."""
    known = sorted(MountInfoEntry.__annotations__.keys())
    if expr.lstrip('.') in known:
        return expr.lstrip('.')
    raise ValueError("invalid attribute selector {!r}"
                     " (known: {})".format(expr, known))


def parse_exprs(exprs: List[str]) -> Tuple[List[FilterExpr], List[str]]:
    filters = [parse_filter(expr) for expr in exprs
               if not expr.startswith('.') or "=" in expr]
    attrs = [parse_attr(expr) for expr in exprs
             if expr.startswith('.') and "=" not in expr]
    return filters, attrs


def matches(entry: MountInfoEntry, filters: List[FilterExpr]) -> bool:
    for f in filters:
        if entry not in f:
            return False
    return True


def renumber_snap_revision(
        entry: MountInfoEntry, seen: Dict[Tuple[str, str], int]) -> None:
    parts = entry.mount_point.split('/')
    snap_name: str
    snap_rev: str
    fn: Callable[[int], List[str]]
    if len(parts) >= 4 and parts[:2] == ["", "snap"]:
        snap_name = parts[2]
        snap_rev = parts[3]

        def fn(n: int) -> List[str]:
            return parts[:3] + ["{}".format(n)] + parts[4:]
    elif len(parts) >= 7 and parts[:5] == ["", "var", "lib", "snapd", "snap"]:
        snap_name = parts[5]
        snap_rev = parts[6]

        def fn(n: int) -> List[str]:
            return parts[:6] + ["{}".format(n)] + parts[7:]
    else:
        return

    def alloc_n(snap_name: str, snap_rev: str) -> int:
        key = (snap_name, snap_rev)
        try:
            return seen[key]
        except KeyError:
            n = len([name for (name, rev) in seen if name == snap_name]) + 1
            seen[key] = n
            return n
    entry.mount_point = "/".join(fn(alloc_n(snap_name, snap_rev)))


def renumber_opt_fields(entry: MountInfoEntry, seen: Dict[int, int]) -> None:
    def alloc_n(peer_group: int) -> int:
        key = peer_group
        try:
            return seen[key]
        except KeyError:
            n = len(seen) + 1
            seen[key] = n
            return n

    def fn(m: Match[str]) -> str:
        return '{}'.format(alloc_n(int(m[1])))
    entry.opt_fields = OptFields([
        re.sub('(\\d+)', fn, opt) for opt in entry.opt_fields])


def renumber_loop_devices(entry: MountInfoEntry, seen: Dict[int, int]) -> None:
    def alloc_n(loop_nr: int) -> int:
        key = loop_nr
        try:
            return seen[key]
        except KeyError:
            n = len(seen)
            seen[key] = n
            return n

    def fn(m: Match[str]) -> str:
        return 'loop{}'.format(alloc_n(int(m[1])))
    entry.mount_source = re.sub('loop(\\d+)', fn, entry.mount_source)


def renumber_mount_ids(entry: MountInfoEntry, seen: Dict[int, int]) -> None:
    def alloc_n(mount_id: int) -> int:
        key = mount_id
        try:
            return seen[key]
        except KeyError:
            n = len(seen)
            seen[key] = n
            return n
    # NOTE: renumber the parent ahead of the mount to get more
    # expected relationship between them.
    entry.parent_id = alloc_n(entry.parent_id)
    entry.mount_id = alloc_n(entry.mount_id)


def renumber_devices(
        entry: MountInfoEntry, seen: Dict[Device, Device]) -> None:
    def alloc_n(dev: Device) -> Device:
        key = dev
        try:
            return seen[key]
        except KeyError:
            major = len({d.major for d in seen})
            if major == 0:
                major += 1
            minor = len({d.minor for d in seen if d.major == dev.major})
            n = Device.pack(major, minor)
            seen[key] = n
            return n
    entry.dev = alloc_n(entry.dev)


def rewrite_renumber(entries: List[MountInfoEntry]) -> None:
    seen_opt_fields: Dict[int, int] = {}
    seen_loops: Dict[int, int] = {}
    seen_snap_revs: Dict[Tuple[str, str], int] = {}
    seen_mount_ids: Dict[int, int] = {}
    seen_devices: Dict[Device, Device] = {}
    for entry in entries:
        renumber_mount_ids(entry, seen_mount_ids)
        renumber_devices(entry, seen_devices)
        renumber_snap_revision(entry, seen_snap_revs)
        renumber_opt_fields(entry, seen_opt_fields)
        renumber_loop_devices(entry, seen_loops)


def rewrite_rename(entries: List[MountInfoEntry]) -> None:
    # TODO: allocate devices like everything else above.
    for entry in entries:
        entry.mount_source = re.sub(
            '/dev/[sv]d([a-z])', '/dev/sd\\1', entry.mount_source)


def main() -> None:
    parser = ArgumentParser(epilog="""
Expressions are ANDed together and have one of the following forms:

    .ATTR=VALUE     mount entry attribute ATTR is equal to VALUE
    PATH            mount point is equal to PATH
    PATH...         mount point starts with PATH

In addition .ATTR syntax can be used to limit display to only certain
attributes. By default the output is identical to raw mountinfo.
Known attributes, applicable for both filtering and display.

    mount_point:    path where mount is attached in the file system
    mount_source:   path of the mounted device or bind-mount origin
    fs_type:        filesystem type
    mount_opts:     options applying to the mount point only
    sb_opts:        options applying to the mounted filesystem
    opt_fields:     optional fields, used for propagation information
    mount_id:       mount point identifier
    parent_id:      identifier of parent mount point
    dev:            major:minor numbers of the mounted device
    root_dir:       subtree of the mounted filesystem exposed at mount_point
    """, formatter_class=RawTextHelpFormatter)
    parser.add_argument(
        '-f', metavar="MOUNTINFO", dest="file", type=FileType(),
        default='/proc/self/mountinfo', help="parse specified mountinfo file")
    parser.add_argument(
        '--one', default=False, action='store_true',
        help="expect exactly one match")
    parser.add_argument(
        'exprs', metavar="EXPRESSION", nargs='*',
        help="filter or display expression (see below)")
    group = parser.add_argument_group("Rewriting rules")
    group.add_argument(
        "--renumber", action="store_true",
        help="Reassign mount IDs, device numbers, snap revisions"
             " and loopback devices")
    group.add_argument(
        "--rename", action="store_true",
        help="Reassign block device names")
    opts = parser.parse_args()
    try:
        filters, attrs = parse_exprs(opts.exprs)
    except ValueError as exc:
        raise SystemExit(exc)
    entries = [MountInfoEntry.parse(line) for line in opts.file]
    entries = [e for e in entries if matches(e, filters)]
    if opts.renumber:
        rewrite_renumber(entries)
    if opts.rename:
        rewrite_rename(entries)
    if opts.one and len(entries) != 1:
        raise SystemExit("--one requires exactly one match, found {}".format(
            len(entries)))
    for e in entries:
        if attrs:
            print(*(getattr(e, a) for a in attrs))
        else:
            print(e)


if __name__ == '__main__':
    main()
