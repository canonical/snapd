#!/bin/bash

show_help() {
    echo "usage: fs-state mock-dir <--new> [dirname]"
    echo "       fs-state restore-dir [dirname]"
    echo "       fs-state mock-file <--new> [filename]"
    echo "       fs-state restore-file [filename]"
    echo "       fs-state start-monitor"
    echo "       fs-state exclude-monitor [path]"
    echo "       fs-state check-monitor"
}

_mock_dir() {
    local dir="$1"
    if [ ! -d "$dir" ]; then
        echo "fs-state: created mock directory: $dir"
        mkdir -p "$dir"
    fi
    touch "$dir.fake"
}

mock_dir() {
    local new=0
    local dir
    while [ $# -gt 0 ]; do
        case "$1" in
            --new)
                new=1
                shift
                ;;
            *)
                dir=$1
                shift
                ;;
        esac
    done

    if [ -d "$dir" ]; then
        if [ "$new" = 1 ]; then
            mv "$dir" "$dir.back"
        else
            cp -rf "$dir" "$dir.back"
        fi
    fi
    _mock_dir "$dir"
}

restore_dir() {
    local dir="$1"

    if [ -e "$dir.fake" ]; then
        echo "fs-state: restoring mocked directory: $dir"
        rm -rf "$dir"
        rm -f "$dir.fake"
    else
        echo "fs-state: cannot restore non-mocked directory: $dir" >&2
        exit 1
    fi
    if [ -d "$dir.back" ]; then
        mv "$dir.back" "$dir"
    fi
}

_mock_file() {
    local file="$1"
    if [ ! -e "$file" ]; then
        echo "fs-state: creating file: $file"
        echo "The file is a mock file used by fs-state." > "$file"
    fi
    echo "The .fake file is a marker file used by fs-state." > "$file.fake"
}

mock_file() {
    local new=0
    local file
    while [ $# -gt 0 ]; do
        case "$1" in
            --new)
                new=1
                shift
                ;;
            *)
                file=$1
                shift
                ;;
        esac
    done

    if [ -e "$file" ]; then
        echo "fs-state: backing up original file: $file"
        if [ "$new" = 1 ]; then
            mv "$file" "$file.back"
        else
            cp -f "$file" "$file.back"
        fi
    fi
    # ensure the parent dir is available
    if [ ! -d "$(dirname "$file")" ]; then
        mkdir -p "$(dirname "$file")"
    fi
    _mock_file "$file"
}

restore_file() {
    local file="$1"
    if [ -e "$file.fake" ]; then
        echo "fs-state: restoring mocked file: $file"
        rm -f "$file"
        rm -f "$file.fake"
    else
        echo "fs-state: cannot restore non-mocked file: $file" >&2
        exit 1
    fi
    if [ -e "$file.back" ]; then
        mv "$file.back" "$file"
    fi
}

start_monitor() {
    if [ -n "$(command -v inotifywait)" ]; then
        # In systems like arch-linux the inotifywait command fails when the output file does not exist
        touch /tmp/fs.output
        touch /tmp/fs.exclude

        # Monitor files and directories creation
        SNAP_MOUNT_DIR="$(os.paths snap-mount-dir)"

        # $PWD is excluded because the backup dir is automatically restored
        # .snap files created in tests/lib/snaps are excluded as they are not deleted to be reused
        inotifywait -d -m -r -e CREATE -e DELETE -o /tmp/fs.output --exclude "($PWD|$PROJECT_PATH/tests/lib/snaps/.*/.*.snap)" /root /etc /var/lib/snapd /var/snap /home "$SNAP_MOUNT_DIR"
        retry -n 10 --wait 1 sh -c 'pgrep inotifywait &>/dev/null'
    fi
}

check_monitor() {
    if [ -n "$(command -v inotifywait)" ]; then
        # Stop inotifywait (it could be already stopped)
        if pgrep inotifywait &>/dev/null; then
            pkill inotifywait
        fi
        set +x
        local created_files created_dirs missing
        # the output file contains lines:
        # /etc/ CREATE foo          # created file /etc/foo
        # /etc/ CREATE,ISDIR foo    # created directory /etc/foo
        created_files=$(grep " CREATE " /tmp/fs.output | awk '{ print $1$3 }')
        deleted_files=$(grep " DELETE " /tmp/fs.output | awk '{ print $1$3 }')
        created_dirs=$(grep " CREATE,ISDIR " /tmp/fs.output | awk '{ print $1$3 }')
        deleted_dirs=$(grep " DELETE,ISDIR " /tmp/fs.output | awk '{ print $1$3 }')
        missing=false

        # Print the files that were created more/less than deleted
        for file in $created_files; do
            #  Skip backup files
            if [[ "$file" = *~ ]]; then
                continue
            fi
            count_created=$(echo "$created_files" | tr " " "\n" | grep -c "$file")
            count_deleted=$(echo "$deleted_files" | tr " " "\n" | grep -c "$file")
            if [ "$count_created" -gt "$count_deleted" ]; then
                echo "File $file created more times than deleted"
                missing=true
            fi
            if [ "$count_created" -lt "$count_deleted" ]; then
                echo "File $file deleted more times than created"
                missing=true
            fi
        done

        # Print the directories that were created more/less than deleted
        for dir in $created_dirs; do
            count_created=$(echo "$created_dirs" | tr " " "\n" | grep -c "$dir")
            count_deleted=$(echo "$deleted_dirs" | tr " " "\n" | grep -c "$dir")
            if [ "$count_created" -gt "$count_deleted" ]; then
                echo "Dir $dir created more times than deleted"
                missing=true
            fi
            if [ "$count_created" -lt "$count_deleted" ]; then
                echo "Dir $dir deleted more times than created"
                missing=true
            fi
        done

        # Exit in case there are files and dirs that were not properly cleaned
        if [ "$missing" = true ]; then
            exit 1
        fi
        rm -f /tmp/fs.output /tmp/fs.exclude
        set -x
    fi
}

exclude_monitor() {
    echo "$1" >> /tmp/fs.exclude
}

main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    action=
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help|'')
                show_help
                exit 0
                ;;
            *)
                action=$(echo "$1" | tr '-' '_')
                shift
                break
                ;;
        esac
    done

    "$action" "$@"
}

main "$@"
