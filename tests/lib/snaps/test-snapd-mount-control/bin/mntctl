#!/usr/bin/env python3

import argparse
import ctypes
import ctypes.util
import os
import subprocess
import sys


class MountFlags:
    MS_RDONLY = 1
    MS_NOSUID = 2
    MS_NODEV = 4
    MS_NOEXEC = 8
    MS_SYNCHRONOUS = 16
    MS_REMOUNT = 32
    MS_MANDLOCK = 64
    MS_DIRSYNC = 128
    MS_NOATIME = 1024
    MS_NODIRATIME = 2048
    MS_BIND = 4096
    MS_MOVE = 8192
    MS_REC = 16384
    MS_SILENT = 32768
    MS_POSIXACL = (1 << 16)
    MS_UNBINDABLE = (1 << 17)
    MS_PRIVATE = (1 << 18)
    MS_SLAVE = (1 << 19)
    MS_SHARED = (1 << 20)
    MS_RELATIME = (1 << 21)
    MS_KERNMOUNT = (1 << 22)
    MS_I_VERSION = (1 << 23)
    MS_STRICTATIME = (1 << 24)
    MS_LAZYTIME = (1 << 25)

    NAME_TO_VALUE = {
        'ro': MS_RDONLY,
        'nosuid': MS_NOSUID,
        'nodev': MS_NODEV,
        'noexec': MS_NOEXEC,
        'sync': MS_SYNCHRONOUS,
        'remount': MS_REMOUNT,
        'mand': MS_MANDLOCK,
        'dirsync': MS_DIRSYNC,
        'noatime': MS_NOATIME,
        'nodiratime': MS_NODIRATIME,
        'bind': MS_BIND,
        'move': MS_MOVE,
        'rec': MS_REC,
        'silent': MS_SILENT,
        'posixacl': MS_POSIXACL,
        'unbindable': MS_UNBINDABLE,
        'private': MS_PRIVATE,
        'slave': MS_SLAVE,
        'shared': MS_SHARED,
        'relatime': MS_RELATIME,
        'kernmount': MS_KERNMOUNT,
        'iversion': MS_I_VERSION,
        'strictatime': MS_STRICTATIME,
        'lazytime': MS_LAZYTIME,
    }

    OPPOSITES = {
        # Other recognized options which are just the default
        'rw': 'ro',
        'suid': 'nosuid',
        'dev': 'nodev',
        'exec': 'noexec',
        'async': 'sync',
        'atime': 'noatime',
        'diratime': 'nodiratime',
        'noiversion': 'iversion',
        'nomand': 'mand',
        'norelatime': 'relatime',
        'nostrictatime': 'strictatime',
        'nolazytime': 'lazytime',
    }

    def __init__(self):
        self.flags = 0

    def __int__(self):
        return self.flags

    def is_flag(string):
        all_names = (list(MountFlags.NAME_TO_VALUE.keys()) +
                     list(MountFlags.OPPOSITES.keys()))
        return string in all_names

    def update_from_string(self, string):
        if string in self.NAME_TO_VALUE:
            self.flags |= self.NAME_TO_VALUE[string]
        elif string in self.OPPOSITES:
            opposite = self.OPPOSITES[string]
            self.flags &= ~self.NAME_TO_VALUE[opposite]


libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
libc.mount.argtypes = (ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p,
                       ctypes.c_ulong, ctypes.c_char_p)


def parse_flags_and_options(options_string):
    flags = MountFlags()
    options = []
    for option_string in options_string.split(','):
        if MountFlags.is_flag(option_string):
            flags.update_from_string(option_string)
        else:
            options.append(option_string)
    return (int(flags), options)


def mount(source, target, fs, options=''):
    flags, opts = parse_flags_and_options(options)
    fse = fs.encode() if fs else None
    optse = ','.join(opts).encode() if opts else None
    ret = libc.mount(source.encode(), target.encode(),
                     fse, flags, optse)
    if ret < 0:
        errno = ctypes.get_errno()
        strerror = os.strerror(errno)
        raise OSError(errno, "Error mounting {source} ({fs}) on {target} with options '{options}': {strerror}".format(**locals()))



def run(args):
    mount(args.source, args.target, args.type, args.options)
    if args.command:
        subprocess.run(args.command, shell=True)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--type', default='')
    parser.add_argument('-o', '--options', default='')
    parser.add_argument('-c', '--command', help="Command to execute after successful mount")
    parser.add_argument('source')
    parser.add_argument('target')

    run(parser.parse_args())
