#!/usr/bin/env python3

import argparse
import json
import os
import subprocess
import sys


def filter_with_spread(exec_param: str):
    exec_param = exec_param.replace(',', ' ')
    cmd = ['spread', '-list']
    cmd.extend(exec_param.split())
    return subprocess.check_output(cmd, universal_newlines=True).splitlines()


def list_executed_tasks(filtered_exec_param: set, spread_logs: dict):
    executed = [log['task'] for log in spread_logs
                if log['type'] == 'phase' and log['verb'] == 'Executing']
    return filtered_exec_param.intersection(executed)


def _get_detail_lines(spread_logs, log_condition_func):
    result = [log['detail']['lines']
              for log in spread_logs if log_condition_func(log)]
    # flatten the list
    result = sum(result, [])

    def clean_entry(entry):
        entry = entry.strip()
        if entry.startswith('-'):
            entry = entry[1:]
        return entry.strip()

    return [clean_entry(log) for log in result]


def list_failed_tasks(filtered_exec_param: set, spread_logs: dict):
    def log_condition(log):
        return log['type'] == 'result' and log['result_type'] == 'Failed' and log['level'] == 'tasks'
    failed = _get_detail_lines(spread_logs, log_condition)
    return filtered_exec_param.intersection(failed)


def _list_failed(spread_logs, level, stage):
    def log_condition(log):
        return log['type'] == 'result' and log['result_type'] == 'Failed' and log['level'] == level and log['stage'] == stage
    return _get_detail_lines(spread_logs, log_condition)


def list_executed_and_failed(filtered_exec_param: set, spread_logs: dict):
    failed = list_failed_tasks(filtered_exec_param, spread_logs)
    failed_prepare = _list_failed(spread_logs, 'task', 'prepare')
    failed_restore = _list_failed(spread_logs, 'task', 'restore')
    union = failed.union(failed_restore)
    return union.difference(failed_prepare)


def list_aborted_tasks(filtered_exec_param: set, spread_logs: dict):
    executed_tasks = list_executed_tasks(filtered_exec_param, spread_logs)
    if len(executed_tasks) == 0:
        exec_and_failed = list_executed_and_failed(
            filtered_exec_param, spread_logs)
        return filtered_exec_param.difference(exec_and_failed)
    return filtered_exec_param.difference(executed_tasks)


def list_successful_tasks(filtered_exec_param: set, spread_logs: dict):
    executed_tasks = list_executed_tasks(filtered_exec_param, spread_logs)
    failed = list_failed_tasks(filtered_exec_param, spread_logs)
    failed_restore = _list_failed(spread_logs, 'task', 'restore')
    failed = failed.union(failed_restore)
    if len(failed) > 0:
        executed_tasks = executed_tasks.difference(failed)
    return executed_tasks


def list_rexecute_tasks(exec_param, filtered_exec_param: set, spread_logs: dict):
    aborted_tasks = list_aborted_tasks(filtered_exec_param, spread_logs)
    exec_and_failed = list_executed_and_failed(
        filtered_exec_param, spread_logs)
    exec_and_failed = exec_and_failed.intersection(filtered_exec_param)
    union = aborted_tasks.union(exec_and_failed)
    if len(filtered_exec_param.difference(union)) == 0:
        return set(exec_param.split())
    return union


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="""
        usage: log-analyzer list-failed-tasks <EXEC-PARAM> <PARSED-LOG>
               log-analyzer list-executed-tasks <EXEC-PARAM> <PARSED-LOG>
               log-analyzer list-successful-tasks <EXEC-PARAM> <PARSED-LOG>
               log-analyzer list-aborted-tasks <EXEC-PARAM> <PARSED-LOG>
               log-analyzer list-all-tasks <EXEC-PARAM>
               log-analyzer list-reexecute-tasks <EXEC-PARAM> <PARSED-LOG>

        The log analyzer is an utility that provides useful information about a spread
        execution. The main functionality of the analyzer utility is to determine which tests
        have to be re-executed, including aborted tests that are not included in the test results.
        The log analyzer uses as input the spread expression that was used to run the tests.
        This expression determines which tests to considered. The second input is the output of
        the log-parser utility, which generates a json file including all the information
        extracted from the raw spread log.
                                     
        COMMANDS:
            list-failed-tasks        list the tasks that failed during execute
            list-executed-tasks      list the tasks that were executed
            list-successful-tasks    list the successful tasks
            list-aborted-tasks       list the aborted tasks (needs spread to be installed)
            list-all-tasks           list all the tasks
            list-reexecute-tasks     list the tasks to re-execute to complete (includes aborted and failed tasks)
    
                                     """, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('command', help="One of {list-failed-tasks, list-executed-tasks, "
                                        "list-successful-tasks, list-aborted-tasks, "
                                        "list-all-tasks, list-reexecute-tasks}")
    parser.add_argument(
        'exec_params', help='This is the parameter used to run spread (something like this BACKEND:SYSTEM:SUITE)')
    parser.add_argument('parsed_log', nargs='?',
                        help='This is the output generated by the log-parser tool')
    args = parser.parse_args()

    filtered_exec_param = set(filter_with_spread(args.exec_params))

    log = None
    if args.parsed_log:
        if not os.path.isfile(args.parsed_log):
            print("log.analyzer: the log file %s does not exist" %
                  args.parsed_log, file=sys.stderr)
            exit(1)

        with open(args.parsed_log, 'r') as f:
            log = json.load(f)

        if not log:
            print("log.analyzer: the log file cannot be empty", file=sys.stderr)
            exit(1)

    if args.command == 'list-failed-tasks':
        print(' '.join(list_failed_tasks(filtered_exec_param, log)))
    elif args.command == 'list-executed-tasks':
        print(' '.join(list_executed_tasks(filtered_exec_param, log)))
    elif args.command == 'list-successful-tasks':
        print(' '.join(list_successful_tasks(filtered_exec_param, log)))
    elif args.command == 'list-aborted-tasks':
        print(' '.join(list_aborted_tasks(filtered_exec_param, log)))
    elif args.command == 'list-all-tasks':
        print(' '.join(filtered_exec_param))
    elif args.command == 'list-reexecute-tasks':
        print(' '.join(list_rexecute_tasks(
            args.exec_params, filtered_exec_param, log)))
    else:
        print("log.analyzer: no such command: %s" %
              args.command, file=sys.stderr)
        exit(1)
