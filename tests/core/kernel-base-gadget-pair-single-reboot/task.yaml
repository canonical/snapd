summary: Ensures that any combination of two of base, gadget and kernel will refresh with just a single reboot.

details: |
    Test ensures that if any two of the essential snaps (base, gadget and kernel) can be refreshed
    together with a single reboot. The test then reverts each of the snaps to ensure system is left
    in untouched state. (Otherwise our spread checks will complain).

systems: [ubuntu-core-18-*, ubuntu-core-2*]

# run before remodel test, unfortunately some tests mess with snaps installed
# and this causes this test to be messed with
priority: 600

environment:
    SNAP_ONE/kernel_base: core
    SNAP_TWO/kernel_base: pc-kernel

    SNAP_ONE/gadget_base: core
    SNAP_TWO/gadget_base: pc
    
    SNAP_ONE/kernel_gadget: pc
    SNAP_TWO/kernel_gadget: pc-kernel

    GADGET_CHANNEL: edge
    CORE18_GADGET_REPACK: true

    # We are uploading too much in terms of size for the snaps
    # we sideload. On UC18 this is disabled automatically, but
    # on UC20+ this has proved to be an issue
    SNAPD_NO_MEMORY_LIMIT: 1

prepare: |
    # To get VERSION_ID defined
    . /etc/os-release

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"

    # read all for simplification
    readlink /snap/pc-kernel/current > pc-kernel.rev
    readlink "/snap/$core_snap/current" > core.rev
    readlink /snap/pc/current > pc.rev

debug: |
    change_id="$(cat refresh-change-id)"
    snap debug state --change "$change_id" /var/lib/snapd/state.json

execute: |
    # To get VERSION_ID defined
    . /etc/os-release

    if not snap list pc; then
        echo "This test needs a host using 'pc' gadget snap"
        exit 1
    fi

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"
    
    # correct the naming based on the system we are testing
    if [ "$SNAP_ONE" = "core" ]; then
        SNAP_ONE=$core_snap
    elif [ "$SNAP_TWO" = "core" ]; then
        SNAP_TWO=$core_snap
    fi

    wait_and_verify_change() {
        local CHANGE_ID="$1"
        snap watch "$CHANGE_ID" || true
        snap changes | MATCH "$CHANGE_ID\s+Done"
        snap change "$CHANGE_ID" > tasks.done
        # nothing has failed
        NOMATCH '^Error' < tasks.done
        # nothing was undone
        NOMATCH '^Undone' < tasks.done
        # nothing is waiting
        NOMATCH '^Wait' < tasks.done

        # we did not even try to hijack shutdown (/bin/systemctl) because that
        # could race with snapd (if that wanted to call it), so just check that
        # the system is in a stable state once we have already determined that
        # the change is complete
        # XXX systemctl exits with non-0 when in degraded state
        # Note: on bionic, is-system-running does not support --wait
        retry -n 30 sh -c '(systemctl is-system-running || true) | MATCH "(running|degraded)"'
    }

    if [ "$SPREAD_REBOOT" = 0 ]; then
        echo Downloading snaps needed
        snap download pc-kernel --channel="$VERSION_ID"/edge

        snap download "$core_snap" --edge --basename=core-for-repack
        unsquashfs -d base-snap core-for-repack.snap
        rm core-for-repack.snap core-for-repack.assert
        snap pack base-snap

        # prepare gadget update if gadget variant
        if [[ "$SNAP_ONE" == "pc" ]] || [[ "$SNAP_TWO" == "pc" ]]; then
            # unsquash gadget for modification
            cp /var/lib/snapd/snaps/pc_*.snap gadget.snap
            unsquashfs -d pc-snap gadget.snap

            cp pc-snap/meta/gadget.yaml gadget.yaml.orig

            system_seed=""
            if os.query is-core-ge 20; then
                system_seed="--system-seed"
            fi

            # prepare update
            python3 ../gadget-update-pc/generate.py ./gadget.yaml.orig v1 $system_seed > pc-snap/meta/gadget.yaml
            echo 'this is foo-x2' > foo-x2.img
            cp foo-x2.img pc-snap/foo.img
            echo 'this is foo.cfg' > pc-snap/foo.cfg
            if os.query is-core-ge 20; then
                echo 'this is foo-seed.cfg' > pc-snap/foo-seed.cfg
            fi
            sed -i -e 's/^version: \(.*\)-1/version: \1-2/' pc-snap/meta/snap.yaml
            snap pack pc-snap --filename=pc_x1.snap
        fi

        snap install "$(ls ${SNAP_ONE}_*.snap)" "$(ls ${SNAP_TWO}_*.snap)" --dangerous --no-wait > refresh-change-id

        test -n "$(cat refresh-change-id)"
        change_id="$(cat refresh-change-id)"
        
        # wait for the link tasks to be done
        retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'

        # both link snaps should be done now, snapd was stopped, so we cannot
        # use 'snap change' and we need to inspect the state directly (even if
        # snapd was up, it would not respond to API requests as it would be busy
        # retrying auto-connect)
        snap debug state --change "$change_id" /var/lib/snapd/state.json > tasks.state
        # both link snaps are done
        MATCH " Wait\s+.*Make snap \"$SNAP_TWO\" .* available" < tasks.state
        MATCH " Done\s+.*Make snap \"$SNAP_ONE\" .* available" < tasks.state
        # auto-connect of the base is in doing and waiting for reboot
        MATCH " Do\s+.*Automatically connect eligible plugs and slots of snap \"$SNAP_ONE\"" < tasks.state
        # auto-connect of the kernel is still queued
        MATCH " Do\s+.*Automatically connect eligible plugs and slots of snap \"$SNAP_TWO\"" < tasks.state

        if os.query is-core18; then
            snap debug boot-vars > boot-vars.dump
            if [[ "$SNAP_ONE" == *"core"* ]] || [[ "$SNAP_TWO" == *"core"* ]]; then
                MATCH 'snap_mode=try' < boot-vars.dump
                MATCH 'snap_try_core=core18_.*.snap' < boot-vars.dump
            fi
            if [[ "$SNAP_ONE" == "pc-kernel" ]] || [[ "$SNAP_TWO" == "pc-kernel" ]]; then
                MATCH 'snap_mode=try' < boot-vars.dump
                MATCH 'snap_try_kernel=pc-kernel_.*.snap' < boot-vars.dump
            fi
        elif os.query is-core-ge 20; then
            if [[ "$SNAP_ONE" == "pc-kernel" ]] || [[ "$SNAP_TWO" == "pc-kernel" ]]; then
                stat /boot/grub/try-kernel.efi | MATCH 'pc-kernel.*.snap/kernel.efi'
                stat -L /boot/grub/try-kernel.efi
            fi
            if [[ "$SNAP_ONE" == *"core"* ]] || [[ "$SNAP_TWO" == *"core"* ]]; then
                MATCH "try_base=core${VERSION_ID}_.*.snap" < /var/lib/snapd/modeenv
            fi
        else
            echo "unsupported Ubuntu Core system"
            exit 1
        fi

        REBOOT
    elif [ "$SPREAD_REBOOT" = 1 ]; then
        change_id="$(cat refresh-change-id)"
        wait_and_verify_change "$change_id"
        
        expecting_kernel="$(($(grep -o -E '[0-9]+' < pc-kernel.rev) + 1))"
        expecting_gadget="$(($(grep -o -E '[0-9]+' < pc.rev) + 1))"
        expecting_core="$(($(grep -o -E '[0-9]+' < core.rev) + 1))"
        if ! grep "x" ./core.rev; then
            expecting_core="1"
        fi

        # fake refreshes generate revision numbers that are n+1
        # verify that current points to new revisions
        if [[ "$SNAP_ONE" == *"core"* ]] || [[ "$SNAP_TWO" == *"core"* ]]; then
            test "$(readlink /snap/$core_snap/current | grep -o -E '[0-9]+')" = "$expecting_core"
        fi
        if [[ "$SNAP_ONE" == "pc" ]] || [[ "$SNAP_TWO" == "pc" ]]; then
            test "$(readlink /snap/pc/current | grep -o -E '[0-9]+')" = "$expecting_gadget"
        fi
        if [[ "$SNAP_ONE" == "pc-kernel" ]] || [[ "$SNAP_TWO" == "pc-kernel" ]]; then
            test "$(readlink /snap/pc-kernel/current | grep -o -E '[0-9]+')" = "$expecting_kernel"
        fi

        # now we need to revert both snaps for restore to behave properly, go from
        # reverse order
        snap revert "$SNAP_TWO" --no-wait > revert-change-id

        # no reboot on pc revert
        if [[ "$SNAP_TWO" == "pc" ]]; then
            change_id="$(cat revert-change-id)"
            wait_and_verify_change "$change_id"

            # now the first
            snap revert "$SNAP_ONE" --no-wait > revert-change-id
        fi

        retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'
        REBOOT
    elif [ "$SPREAD_REBOOT" = 2 ] && [[ "$SNAP_ONE" != "pc" ]] && [[ "$SNAP_TWO" != "pc" ]]; then
        change_id="$(cat revert-change-id)"
        wait_and_verify_change "$change_id"

        # now the first
        snap revert "$SNAP_ONE" --no-wait > revert-change-id

        retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'
        REBOOT
    elif [ "$SPREAD_REBOOT" = 2 ] || [ "$SPREAD_REBOOT" = 3 ]; then
        change_id="$(cat revert-change-id)"
        wait_and_verify_change "$change_id"

        if [[ "$SNAP_ONE" == "pc" ]]; then
            snap revert "$SNAP_ONE" --no-wait > revert-change-id
            change_id="$(cat revert-change-id)"
            wait_and_verify_change "$change_id"
        fi
        
        # we're done, verify current symlinks to the right revisions
        test "$(readlink /snap/$core_snap/current)" = "$(cat core.rev)"
        test "$(readlink /snap/pc/current)" = "$(cat pc.rev)"
        test "$(readlink /snap/pc-kernel/current)" = "$(cat pc-kernel.rev)"
    else
        echo "unexpected reboot"
        exit 1
    fi
