summary: Ensures that any combination of two of base, gadget and kernel will undo with a single reboot in each direction.

details: |
    Test ensures that if any two of the essential snaps (base, gadget and kernel) can be refreshed
    together with a single reboot, and will also revert with no more than a single reboot.

systems: [ubuntu-core-18-*, ubuntu-core-2*]

environment:
    SNAP_ONE/kernel_base: core
    SNAP_TWO/kernel_base: pc-kernel

    SNAP_ONE/gadget_base: core
    SNAP_TWO/gadget_base: pc
    
    SNAP_ONE/kernel_gadget: pc
    SNAP_TWO/kernel_gadget: pc-kernel

    BLOB_DIR: $(pwd)/fake-store-blobdir

    # We are uploading too much in terms of size for the snaps
    # we sideload. On UC18 this is disabled automatically, but
    # on UC20+ this has proved to be an issue
    SNAPD_NO_MEMORY_LIMIT: 1

prepare: |
    # To get VERSION_ID defined
    . /etc/os-release

    # we need yq for editing yaml files
    snap install yq 

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"

    # read all for simplification
    readlink /snap/pc-kernel/current > pc-kernel.rev
    readlink "/snap/$core_snap/current" > core.rev
    readlink /snap/pc/current > pc.rev

debug: |
    change_id="$(cat refresh-change-id)"
    snap debug state --change "$change_id" /var/lib/snapd/state.json

execute: |
    # To get VERSION_ID defined
    . /etc/os-release

    if snap list pc | NOMATCH "x[1-9]"; then
        echo "This test needs a host using an unasserted 'pc' gadget snap"
        exit 1
    fi

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"
    
    # correct the naming based on the system we are testing
    if [ "$SNAP_ONE" = "core" ]; then
        SNAP_ONE=$core_snap
    elif [ "$SNAP_TWO" = "core" ]; then
        SNAP_TWO=$core_snap
    fi

    # shellcheck source=tests/lib/prepare.sh
    . "$TESTSLIB/prepare.sh"

    inject_failure_configure_hook() {
        if cat "$1/meta/snap.yaml" | yq '.hooks'; then
            # shellcheck disable=SC2094
            cat "$1/meta/snap.yaml" | yq '.hooks += {"configure": ""} | .hooks.configure tag="!!null"' >> "$1/meta/snap.yaml"
        else
            # shellcheck disable=SC2094
            cat "$1/meta/snap.yaml" | yq '. += {"hooks": {"configure": ""}} | .hooks.configure tag="!!null"' >> "$1/meta/snap.yaml"
            mkdir -p "$1/meta/hooks"
        fi
        echo 'exit 1' >> "$1/meta/hooks/configure"
        chmod +x "$1/meta/hooks/configure"
    }

    if [ "$SPREAD_REBOOT" = 0 ]; then
        echo Downloading snaps needed
        snap download pc-kernel --channel="$VERSION_ID"/edge

        snap download "$core_snap" --edge
        printf '\0' >> "$core_snap"_*.snap

        # break the pc-kernel snap if that is the last snap
        if [[ "$SNAP_TWO" == "pc-kernel" ]]; then
            unsquashfs -d pc-kernel-snap pc-kernel_*.snap
            inject_failure_configure_hook ./pc-kernel-snap
            rm pc-kernel_*.snap pc-kernel_*.assert
            snap pack pc-kernel-snap
            rm -rf pc-kernel-snap
        fi

        # prepare gadget update if gadget variant
        # and break pc gadget if that is the last snap
        if [[ "$SNAP_ONE" == "pc" ]] || [[ "$SNAP_TWO" == "pc" ]]; then
            # unsquash gadget for modification
            cp /var/lib/snapd/snaps/pc_*.snap gadget.snap
            unsquashfs -d pc-snap gadget.snap

            cp pc-snap/meta/gadget.yaml gadget.yaml.orig

            system_seed=""
            if os.query is-core-ge 20; then
                system_seed="--system-seed"
            fi

            # prepare update
            python3 ../gadget-update-pc/generate.py ./gadget.yaml.orig v1 $system_seed > pc-snap/meta/gadget.yaml
            echo 'this is foo-x2' > foo-x2.img
            cp foo-x2.img pc-snap/foo.img
            echo 'this is foo.cfg' > pc-snap/foo.cfg
            if os.query is-core-ge 20; then
                echo 'this is foo-seed.cfg' > pc-snap/foo-seed.cfg
            fi
            sed -i -e 's/^version: \(.*\)-1/version: \1-2/' pc-snap/meta/snap.yaml

            # break the gadget snap if that is the second snap
            if [[ "$SNAP_TWO" == "pc" ]]; then
                inject_failure_configure_hook ./pc-snap
            fi
            snap pack pc-snap --filename=pc_x1.snap
        fi

        snap install "$(ls ${SNAP_ONE}_*.snap)" "$(ls ${SNAP_TWO}_*.snap)" --dangerous --no-wait > refresh-change-id

        test -n "$(cat refresh-change-id)"
        change_id="$(cat refresh-change-id)"
        
        # wait for the link tasks to be done
        retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'

        # both link snaps should be done now, snapd was stopped, so we cannot
        # use 'snap change' and we need to inspect the state directly (even if
        # snapd was up, it would not respond to API requests as it would be busy
        # retrying auto-connect)
        snap debug state --change "$change_id" /var/lib/snapd/state.json > tasks.state
        # both link snaps are done
        MATCH " Wait\s+.*Make snap \"$SNAP_TWO\" .* available" < tasks.state
        MATCH " Done\s+.*Make snap \"$SNAP_ONE\" .* available" < tasks.state
        # auto-connect of the base is in doing and waiting for reboot
        MATCH " Do\s+.*Automatically connect eligible plugs and slots of snap \"$SNAP_ONE\"" < tasks.state
        # auto-connect of the kernel is still queued
        MATCH " Do\s+.*Automatically connect eligible plugs and slots of snap \"$SNAP_TWO\"" < tasks.state

        if os.query is-core18; then
            snap debug boot-vars > boot-vars.dump
            if [[ "$SNAP_ONE" == *"core"* ]] || [[ "$SNAP_TWO" == *"core"* ]]; then
                MATCH 'snap_mode=try' < boot-vars.dump
                MATCH 'snap_try_core=core18_.*.snap' < boot-vars.dump
            fi
            if [[ "$SNAP_ONE" == "pc-kernel" ]] || [[ "$SNAP_TWO" == "pc-kernel" ]]; then
                MATCH 'snap_mode=try' < boot-vars.dump
                MATCH 'snap_try_kernel=pc-kernel_.*.snap' < boot-vars.dump
            fi
        elif os.query is-core-ge 20; then
            if [[ "$SNAP_ONE" == "pc-kernel" ]] || [[ "$SNAP_TWO" == "pc-kernel" ]]; then
                stat /boot/grub/try-kernel.efi | MATCH 'pc-kernel.*.snap/kernel.efi'
                stat -L /boot/grub/try-kernel.efi
            fi
            if [[ "$SNAP_ONE" == *"core"* ]] || [[ "$SNAP_TWO" == *"core"* ]]; then
                MATCH "try_base=core${VERSION_ID}_.*.snap" < /var/lib/snapd/modeenv
            fi
        else
            echo "unsupported Ubuntu Core system"
            exit 1
        fi

        REBOOT
    elif [ "$SPREAD_REBOOT" = 1 ] || [ "$SPREAD_REBOOT" = 2 ]; then
        # Because it's the configure hook we expect the error to happen after
        # system comes up, where-as with the kernel failure it happens before
        # we're able to observe it
        if [ "$SPREAD_REBOOT" = 2 ] && [[ "$SNAP_TWO" == "core" ]]; then
            echo "unexpected reboot"
            exit 1
        fi

        change_id="$(cat refresh-change-id)"
        snap watch "$change_id" || true

        # The gadget and kernel snap continue after the reboot, and then fails, the change reverts
        # and requests another reboot for a total of 2 reboots (one for do, one for undo)
        if [ "$SPREAD_REBOOT" = 1 ] && { [ "$SNAP_TWO" = "pc" ] || [ "$SNAP_TWO" = "pc-kernel" ]; }; then
            # wait for a restart to be requested
            retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'
            REBOOT
        fi

        # we expect the change to have failed due to the kernel not booting
        # properly
        snap watch "$change_id" || true
        snap changes | MATCH "$change_id\s+Error"
        snap change "$change_id" > tasks.done
        # both link snaps were undone
        MATCH "Undone\s+.*Make snap \"$SNAP_ONE\" .* available" < tasks.done
        MATCH "Undone\s+.*Make snap \"$SNAP_TWO\" .* available" < tasks.done

        if os.query is-core18; then
            # boot variables should have been cleared
            snap debug boot-vars > boot-vars.dump
            MATCH 'snap_mode=$' < boot-vars.dump
            MATCH 'snap_try_core=$' < boot-vars.dump
            MATCH 'snap_try_kernel=$' < boot-vars.dump
        elif os.query is-core-ge 20; then
            stat /boot/grub/try-kernel.efi | NOMATCH 'pc-kernel.*.snap/kernel.efi'
            stat -L /boot/grub/try-kernel.efi && exit 1
        else
            echo "unsupported Ubuntu Core system"
            exit 1
        fi

        # make sure the system is in stable state, no pending reboots
        # XXX systemctl exits with non-0 when in degraded state
        # Note: on bionic, is-system-running does not support --wait
        retry -n 30 sh -c '(systemctl is-system-running || true) | MATCH "(running|degraded)"'

        # we're expecting the old revisions to be back
        original_kernel="$(cat pc-kernel.rev)"
        original_core="$(cat core.rev)"
        original_pc="$(cat pc.rev)"

        # verify that current points to old revisions
        test "$(readlink /snap/pc-kernel/current)" = "$original_kernel"
        test "$(readlink /snap/"${core_snap}"/current)" = "$original_core"
        test "$(readlink /snap/pc/current)" = "$original_pc"
    else
        echo "unexpected reboot"
        exit 1
    fi
