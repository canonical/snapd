summary: Upgrade the core snap and revert a few times

# ARM devices are not supported on ubuntu-core-18 due to fw_printenv/setenv are
# not provided by the system and as the devices boot with uboot so it is not
# possible to get any grub information as it is done with non arm devices.
systems: [ubuntu-core-16-*, ubuntu-core-18-32*, ubuntu-core-18-64*]

# Start early as it takes a long time.
priority: 100

environment:
    # uploading the core snap triggers OOM
    SNAPD_NO_MEMORY_LIMIT: 1

prepare: |
    TARGET_SNAP=core
    if os.query is-core18; then
        TARGET_SNAP=core18
    fi

    snap list | awk "/^${TARGET_SNAP} / {print(\$3)}" > nextBoot
    snap install test-snapd-sh

restore: |
    systemctl restart snapd
    if [ -f curChg ] ; then
        snap abort "$(cat curChg)" || true
    fi
    # Remove the revisions installed during the test.
    # The x1 revision is the one we use initially.
    snap remove core --revision=x2
    snap remove core --revision=x3

debug: |
    snap list
    "$TESTSTOOLS"/boot-state bootenv show
    cat /proc/cmdline

execute: |
    TARGET_SNAP=core
    if os.query is-core18; then
        TARGET_SNAP=core18
    fi

    # FIXME Why it starting with snap_mode=try the first time?
    # Perhaps because $TARGET_SNAP is installed after seeding? Do we
    # want that on pristine images?
    if [ "$SPREAD_REBOOT" != 0 ]; then
        echo "Waiting for snapd to clean snap_mode"
        while [ "$("$TESTSTOOLS"/boot-state bootenv show snap_mode)" != "" ]; do
            sleep 1
        done

        echo "Ensure the bootloader is correct after reboot"
        test "$("$TESTSTOOLS"/boot-state bootenv show snap_core)" = "${TARGET_SNAP}_$(cat nextBoot).snap"
        test "$("$TESTSTOOLS"/boot-state bootenv show snap_try_core)" = ""
        test "$("$TESTSTOOLS"/boot-state bootenv show snap_mode)" = ""
    fi

    snap list | awk "/^${TARGET_SNAP} / {print(\$3)}" > prevBoot

    # wait for ongoing change if there is one
    if [ -f curChg ] ; then
       snap watch "$(cat curChg)"
       rm -f curChg
    fi

    case "$SPREAD_REBOOT" in

    0) cmd="snap install --dangerous /var/lib/snapd/snaps/${TARGET_SNAP}_$(cat prevBoot).snap" ;;
    1) cmd="snap revert $TARGET_SNAP" ;;
    2) cmd="snap install --dangerous /var/lib/snapd/snaps/${TARGET_SNAP}_$(cat prevBoot).snap" ;;
    3) cmd="snap revert $TARGET_SNAP" ;;
    4) exit 0 ;;

    esac

    # start the op and get the change id
    #shellcheck disable=SC2086
    chg_id="$(eval ${cmd} --no-wait)"

    # save change id to wait later or abort
    echo "${chg_id}" >curChg

    # wait for the link task to be done
    retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'

    echo "Ensure the test snap still runs"
    test-snapd-sh.sh -c 'echo hello' | MATCH hello

    echo "Ensure the bootloader is correct before reboot"
    readlink "/snap/${TARGET_SNAP}/current" > nextBoot
    test "$(cat prevBoot)" != "$(cat nextBoot)"
    test "$("$TESTSTOOLS"/boot-state bootenv show snap_try_core)" = "${TARGET_SNAP}_$(cat nextBoot).snap"
    test "$("$TESTSTOOLS"/boot-state bootenv show snap_mode)" = "try"

    echo "Ensure the device is scheduled for auto-reboot"
    output=$(dbus-send --print-reply \
        --type=method_call \
        --system \
        --dest=org.freedesktop.login1 \
        /org/freedesktop/login1 \
        org.freedesktop.DBus.Properties.Get \
        string:org.freedesktop.login1.Manager string:ScheduledShutdown)
    if ! echo "$output" | MATCH 'string "reboot"'; then
        echo "Failed to detect scheduled reboot in logind output"
        exit 1
    fi

    REBOOT
